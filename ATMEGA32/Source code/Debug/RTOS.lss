
RTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000653e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000138  00800060  0000653e  000065d2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000068c  00800198  00800198  0000670a  2**0
                  ALLOC
  3 .stab         000090e4  00000000  00000000  0000670c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004c1d  00000000  00000000  0000f7f0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  0001440d  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000197  00000000  00000000  0001454d  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001a88  00000000  00000000  000146e4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eb7  00000000  00000000  0001616c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000df7  00000000  00000000  00017023  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  00017e1c  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000002bf  00000000  00000000  00017f7c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007f2  00000000  00000000  0001823b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 f4 12 	jmp	0x25e8	; 0x25e8 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ee e3       	ldi	r30, 0x3E	; 62
      68:	f5 e6       	ldi	r31, 0x65	; 101
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a8 39       	cpi	r26, 0x98	; 152
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	18 e0       	ldi	r17, 0x08	; 8
      78:	a8 e9       	ldi	r26, 0x98	; 152
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a4 32       	cpi	r26, 0x24	; 36
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 a2 0d 	call	0x1b44	; 0x1b44 <main>
      8a:	0c 94 9d 32 	jmp	0x653a	; 0x653a <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 cb 02 	call	0x596	; 0x596 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 fb 02 	call	0x5f6	; 0x5f6 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 fb 02 	call	0x5f6	; 0x5f6 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 56 32 	jmp	0x64ac	; 0x64ac <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a0 e9       	ldi	r26, 0x90	; 144
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 72 32 	jmp	0x64e4	; 0x64e4 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 62 32 	jmp	0x64c4	; 0x64c4 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 17 04 	call	0x82e	; 0x82e <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 7e 32 	jmp	0x64fc	; 0x64fc <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 62 32 	jmp	0x64c4	; 0x64c4 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 17 04 	call	0x82e	; 0x82e <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 7e 32 	jmp	0x64fc	; 0x64fc <__epilogue_restores__+0x18>

0000043e <__divsf3>:
     43e:	a8 e1       	ldi	r26, 0x18	; 24
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 5e 32 	jmp	0x64bc	; 0x64bc <__prologue_saves__+0x10>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	b9 e0       	ldi	r27, 0x09	; 9
     45c:	eb 2e       	mov	r14, r27
     45e:	f1 2c       	mov	r15, r1
     460:	ec 0e       	add	r14, r28
     462:	fd 1e       	adc	r15, r29
     464:	ce 01       	movw	r24, r28
     466:	01 96       	adiw	r24, 0x01	; 1
     468:	b7 01       	movw	r22, r14
     46a:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <__unpack_f>
     46e:	8e 01       	movw	r16, r28
     470:	0f 5e       	subi	r16, 0xEF	; 239
     472:	1f 4f       	sbci	r17, 0xFF	; 255
     474:	ce 01       	movw	r24, r28
     476:	05 96       	adiw	r24, 0x05	; 5
     478:	b8 01       	movw	r22, r16
     47a:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <__unpack_f>
     47e:	29 85       	ldd	r18, Y+9	; 0x09
     480:	22 30       	cpi	r18, 0x02	; 2
     482:	08 f4       	brcc	.+2      	; 0x486 <__divsf3+0x48>
     484:	7e c0       	rjmp	.+252    	; 0x582 <__divsf3+0x144>
     486:	39 89       	ldd	r19, Y+17	; 0x11
     488:	32 30       	cpi	r19, 0x02	; 2
     48a:	10 f4       	brcc	.+4      	; 0x490 <__divsf3+0x52>
     48c:	b8 01       	movw	r22, r16
     48e:	7c c0       	rjmp	.+248    	; 0x588 <__divsf3+0x14a>
     490:	8a 85       	ldd	r24, Y+10	; 0x0a
     492:	9a 89       	ldd	r25, Y+18	; 0x12
     494:	89 27       	eor	r24, r25
     496:	8a 87       	std	Y+10, r24	; 0x0a
     498:	24 30       	cpi	r18, 0x04	; 4
     49a:	11 f0       	breq	.+4      	; 0x4a0 <__divsf3+0x62>
     49c:	22 30       	cpi	r18, 0x02	; 2
     49e:	31 f4       	brne	.+12     	; 0x4ac <__divsf3+0x6e>
     4a0:	23 17       	cp	r18, r19
     4a2:	09 f0       	breq	.+2      	; 0x4a6 <__divsf3+0x68>
     4a4:	6e c0       	rjmp	.+220    	; 0x582 <__divsf3+0x144>
     4a6:	60 e9       	ldi	r22, 0x90	; 144
     4a8:	70 e0       	ldi	r23, 0x00	; 0
     4aa:	6e c0       	rjmp	.+220    	; 0x588 <__divsf3+0x14a>
     4ac:	34 30       	cpi	r19, 0x04	; 4
     4ae:	39 f4       	brne	.+14     	; 0x4be <__divsf3+0x80>
     4b0:	1d 86       	std	Y+13, r1	; 0x0d
     4b2:	1e 86       	std	Y+14, r1	; 0x0e
     4b4:	1f 86       	std	Y+15, r1	; 0x0f
     4b6:	18 8a       	std	Y+16, r1	; 0x10
     4b8:	1c 86       	std	Y+12, r1	; 0x0c
     4ba:	1b 86       	std	Y+11, r1	; 0x0b
     4bc:	04 c0       	rjmp	.+8      	; 0x4c6 <__divsf3+0x88>
     4be:	32 30       	cpi	r19, 0x02	; 2
     4c0:	21 f4       	brne	.+8      	; 0x4ca <__divsf3+0x8c>
     4c2:	84 e0       	ldi	r24, 0x04	; 4
     4c4:	89 87       	std	Y+9, r24	; 0x09
     4c6:	b7 01       	movw	r22, r14
     4c8:	5f c0       	rjmp	.+190    	; 0x588 <__divsf3+0x14a>
     4ca:	2b 85       	ldd	r18, Y+11	; 0x0b
     4cc:	3c 85       	ldd	r19, Y+12	; 0x0c
     4ce:	8b 89       	ldd	r24, Y+19	; 0x13
     4d0:	9c 89       	ldd	r25, Y+20	; 0x14
     4d2:	28 1b       	sub	r18, r24
     4d4:	39 0b       	sbc	r19, r25
     4d6:	3c 87       	std	Y+12, r19	; 0x0c
     4d8:	2b 87       	std	Y+11, r18	; 0x0b
     4da:	ed 84       	ldd	r14, Y+13	; 0x0d
     4dc:	fe 84       	ldd	r15, Y+14	; 0x0e
     4de:	0f 85       	ldd	r16, Y+15	; 0x0f
     4e0:	18 89       	ldd	r17, Y+16	; 0x10
     4e2:	ad 88       	ldd	r10, Y+21	; 0x15
     4e4:	be 88       	ldd	r11, Y+22	; 0x16
     4e6:	cf 88       	ldd	r12, Y+23	; 0x17
     4e8:	d8 8c       	ldd	r13, Y+24	; 0x18
     4ea:	ea 14       	cp	r14, r10
     4ec:	fb 04       	cpc	r15, r11
     4ee:	0c 05       	cpc	r16, r12
     4f0:	1d 05       	cpc	r17, r13
     4f2:	40 f4       	brcc	.+16     	; 0x504 <__divsf3+0xc6>
     4f4:	ee 0c       	add	r14, r14
     4f6:	ff 1c       	adc	r15, r15
     4f8:	00 1f       	adc	r16, r16
     4fa:	11 1f       	adc	r17, r17
     4fc:	21 50       	subi	r18, 0x01	; 1
     4fe:	30 40       	sbci	r19, 0x00	; 0
     500:	3c 87       	std	Y+12, r19	; 0x0c
     502:	2b 87       	std	Y+11, r18	; 0x0b
     504:	20 e0       	ldi	r18, 0x00	; 0
     506:	30 e0       	ldi	r19, 0x00	; 0
     508:	40 e0       	ldi	r20, 0x00	; 0
     50a:	50 e0       	ldi	r21, 0x00	; 0
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e4       	ldi	r27, 0x40	; 64
     514:	60 e0       	ldi	r22, 0x00	; 0
     516:	70 e0       	ldi	r23, 0x00	; 0
     518:	ea 14       	cp	r14, r10
     51a:	fb 04       	cpc	r15, r11
     51c:	0c 05       	cpc	r16, r12
     51e:	1d 05       	cpc	r17, r13
     520:	40 f0       	brcs	.+16     	; 0x532 <__divsf3+0xf4>
     522:	28 2b       	or	r18, r24
     524:	39 2b       	or	r19, r25
     526:	4a 2b       	or	r20, r26
     528:	5b 2b       	or	r21, r27
     52a:	ea 18       	sub	r14, r10
     52c:	fb 08       	sbc	r15, r11
     52e:	0c 09       	sbc	r16, r12
     530:	1d 09       	sbc	r17, r13
     532:	b6 95       	lsr	r27
     534:	a7 95       	ror	r26
     536:	97 95       	ror	r25
     538:	87 95       	ror	r24
     53a:	ee 0c       	add	r14, r14
     53c:	ff 1c       	adc	r15, r15
     53e:	00 1f       	adc	r16, r16
     540:	11 1f       	adc	r17, r17
     542:	6f 5f       	subi	r22, 0xFF	; 255
     544:	7f 4f       	sbci	r23, 0xFF	; 255
     546:	6f 31       	cpi	r22, 0x1F	; 31
     548:	71 05       	cpc	r23, r1
     54a:	31 f7       	brne	.-52     	; 0x518 <__divsf3+0xda>
     54c:	da 01       	movw	r26, r20
     54e:	c9 01       	movw	r24, r18
     550:	8f 77       	andi	r24, 0x7F	; 127
     552:	90 70       	andi	r25, 0x00	; 0
     554:	a0 70       	andi	r26, 0x00	; 0
     556:	b0 70       	andi	r27, 0x00	; 0
     558:	80 34       	cpi	r24, 0x40	; 64
     55a:	91 05       	cpc	r25, r1
     55c:	a1 05       	cpc	r26, r1
     55e:	b1 05       	cpc	r27, r1
     560:	61 f4       	brne	.+24     	; 0x57a <__divsf3+0x13c>
     562:	27 fd       	sbrc	r18, 7
     564:	0a c0       	rjmp	.+20     	; 0x57a <__divsf3+0x13c>
     566:	e1 14       	cp	r14, r1
     568:	f1 04       	cpc	r15, r1
     56a:	01 05       	cpc	r16, r1
     56c:	11 05       	cpc	r17, r1
     56e:	29 f0       	breq	.+10     	; 0x57a <__divsf3+0x13c>
     570:	20 5c       	subi	r18, 0xC0	; 192
     572:	3f 4f       	sbci	r19, 0xFF	; 255
     574:	4f 4f       	sbci	r20, 0xFF	; 255
     576:	5f 4f       	sbci	r21, 0xFF	; 255
     578:	20 78       	andi	r18, 0x80	; 128
     57a:	2d 87       	std	Y+13, r18	; 0x0d
     57c:	3e 87       	std	Y+14, r19	; 0x0e
     57e:	4f 87       	std	Y+15, r20	; 0x0f
     580:	58 8b       	std	Y+16, r21	; 0x10
     582:	be 01       	movw	r22, r28
     584:	67 5f       	subi	r22, 0xF7	; 247
     586:	7f 4f       	sbci	r23, 0xFF	; 255
     588:	cb 01       	movw	r24, r22
     58a:	0e 94 17 04 	call	0x82e	; 0x82e <__pack_f>
     58e:	68 96       	adiw	r28, 0x18	; 24
     590:	ea e0       	ldi	r30, 0x0A	; 10
     592:	0c 94 7a 32 	jmp	0x64f4	; 0x64f4 <__epilogue_restores__+0x10>

00000596 <__gesf2>:
     596:	a8 e1       	ldi	r26, 0x18	; 24
     598:	b0 e0       	ldi	r27, 0x00	; 0
     59a:	e1 ed       	ldi	r30, 0xD1	; 209
     59c:	f2 e0       	ldi	r31, 0x02	; 2
     59e:	0c 94 62 32 	jmp	0x64c4	; 0x64c4 <__prologue_saves__+0x18>
     5a2:	69 83       	std	Y+1, r22	; 0x01
     5a4:	7a 83       	std	Y+2, r23	; 0x02
     5a6:	8b 83       	std	Y+3, r24	; 0x03
     5a8:	9c 83       	std	Y+4, r25	; 0x04
     5aa:	2d 83       	std	Y+5, r18	; 0x05
     5ac:	3e 83       	std	Y+6, r19	; 0x06
     5ae:	4f 83       	std	Y+7, r20	; 0x07
     5b0:	58 87       	std	Y+8, r21	; 0x08
     5b2:	89 e0       	ldi	r24, 0x09	; 9
     5b4:	e8 2e       	mov	r14, r24
     5b6:	f1 2c       	mov	r15, r1
     5b8:	ec 0e       	add	r14, r28
     5ba:	fd 1e       	adc	r15, r29
     5bc:	ce 01       	movw	r24, r28
     5be:	01 96       	adiw	r24, 0x01	; 1
     5c0:	b7 01       	movw	r22, r14
     5c2:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <__unpack_f>
     5c6:	8e 01       	movw	r16, r28
     5c8:	0f 5e       	subi	r16, 0xEF	; 239
     5ca:	1f 4f       	sbci	r17, 0xFF	; 255
     5cc:	ce 01       	movw	r24, r28
     5ce:	05 96       	adiw	r24, 0x05	; 5
     5d0:	b8 01       	movw	r22, r16
     5d2:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <__unpack_f>
     5d6:	89 85       	ldd	r24, Y+9	; 0x09
     5d8:	82 30       	cpi	r24, 0x02	; 2
     5da:	40 f0       	brcs	.+16     	; 0x5ec <__gesf2+0x56>
     5dc:	89 89       	ldd	r24, Y+17	; 0x11
     5de:	82 30       	cpi	r24, 0x02	; 2
     5e0:	28 f0       	brcs	.+10     	; 0x5ec <__gesf2+0x56>
     5e2:	c7 01       	movw	r24, r14
     5e4:	b8 01       	movw	r22, r16
     5e6:	0e 94 64 05 	call	0xac8	; 0xac8 <__fpcmp_parts_f>
     5ea:	01 c0       	rjmp	.+2      	; 0x5ee <__gesf2+0x58>
     5ec:	8f ef       	ldi	r24, 0xFF	; 255
     5ee:	68 96       	adiw	r28, 0x18	; 24
     5f0:	e6 e0       	ldi	r30, 0x06	; 6
     5f2:	0c 94 7e 32 	jmp	0x64fc	; 0x64fc <__epilogue_restores__+0x18>

000005f6 <__fixsfsi>:
     5f6:	ac e0       	ldi	r26, 0x0C	; 12
     5f8:	b0 e0       	ldi	r27, 0x00	; 0
     5fa:	e1 e0       	ldi	r30, 0x01	; 1
     5fc:	f3 e0       	ldi	r31, 0x03	; 3
     5fe:	0c 94 66 32 	jmp	0x64cc	; 0x64cc <__prologue_saves__+0x20>
     602:	69 83       	std	Y+1, r22	; 0x01
     604:	7a 83       	std	Y+2, r23	; 0x02
     606:	8b 83       	std	Y+3, r24	; 0x03
     608:	9c 83       	std	Y+4, r25	; 0x04
     60a:	ce 01       	movw	r24, r28
     60c:	01 96       	adiw	r24, 0x01	; 1
     60e:	be 01       	movw	r22, r28
     610:	6b 5f       	subi	r22, 0xFB	; 251
     612:	7f 4f       	sbci	r23, 0xFF	; 255
     614:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <__unpack_f>
     618:	8d 81       	ldd	r24, Y+5	; 0x05
     61a:	82 30       	cpi	r24, 0x02	; 2
     61c:	61 f1       	breq	.+88     	; 0x676 <__fixsfsi+0x80>
     61e:	82 30       	cpi	r24, 0x02	; 2
     620:	50 f1       	brcs	.+84     	; 0x676 <__fixsfsi+0x80>
     622:	84 30       	cpi	r24, 0x04	; 4
     624:	21 f4       	brne	.+8      	; 0x62e <__fixsfsi+0x38>
     626:	8e 81       	ldd	r24, Y+6	; 0x06
     628:	88 23       	and	r24, r24
     62a:	51 f1       	breq	.+84     	; 0x680 <__fixsfsi+0x8a>
     62c:	2e c0       	rjmp	.+92     	; 0x68a <__fixsfsi+0x94>
     62e:	2f 81       	ldd	r18, Y+7	; 0x07
     630:	38 85       	ldd	r19, Y+8	; 0x08
     632:	37 fd       	sbrc	r19, 7
     634:	20 c0       	rjmp	.+64     	; 0x676 <__fixsfsi+0x80>
     636:	6e 81       	ldd	r22, Y+6	; 0x06
     638:	2f 31       	cpi	r18, 0x1F	; 31
     63a:	31 05       	cpc	r19, r1
     63c:	1c f0       	brlt	.+6      	; 0x644 <__fixsfsi+0x4e>
     63e:	66 23       	and	r22, r22
     640:	f9 f0       	breq	.+62     	; 0x680 <__fixsfsi+0x8a>
     642:	23 c0       	rjmp	.+70     	; 0x68a <__fixsfsi+0x94>
     644:	8e e1       	ldi	r24, 0x1E	; 30
     646:	90 e0       	ldi	r25, 0x00	; 0
     648:	82 1b       	sub	r24, r18
     64a:	93 0b       	sbc	r25, r19
     64c:	29 85       	ldd	r18, Y+9	; 0x09
     64e:	3a 85       	ldd	r19, Y+10	; 0x0a
     650:	4b 85       	ldd	r20, Y+11	; 0x0b
     652:	5c 85       	ldd	r21, Y+12	; 0x0c
     654:	04 c0       	rjmp	.+8      	; 0x65e <__fixsfsi+0x68>
     656:	56 95       	lsr	r21
     658:	47 95       	ror	r20
     65a:	37 95       	ror	r19
     65c:	27 95       	ror	r18
     65e:	8a 95       	dec	r24
     660:	d2 f7       	brpl	.-12     	; 0x656 <__fixsfsi+0x60>
     662:	66 23       	and	r22, r22
     664:	b1 f0       	breq	.+44     	; 0x692 <__fixsfsi+0x9c>
     666:	50 95       	com	r21
     668:	40 95       	com	r20
     66a:	30 95       	com	r19
     66c:	21 95       	neg	r18
     66e:	3f 4f       	sbci	r19, 0xFF	; 255
     670:	4f 4f       	sbci	r20, 0xFF	; 255
     672:	5f 4f       	sbci	r21, 0xFF	; 255
     674:	0e c0       	rjmp	.+28     	; 0x692 <__fixsfsi+0x9c>
     676:	20 e0       	ldi	r18, 0x00	; 0
     678:	30 e0       	ldi	r19, 0x00	; 0
     67a:	40 e0       	ldi	r20, 0x00	; 0
     67c:	50 e0       	ldi	r21, 0x00	; 0
     67e:	09 c0       	rjmp	.+18     	; 0x692 <__fixsfsi+0x9c>
     680:	2f ef       	ldi	r18, 0xFF	; 255
     682:	3f ef       	ldi	r19, 0xFF	; 255
     684:	4f ef       	ldi	r20, 0xFF	; 255
     686:	5f e7       	ldi	r21, 0x7F	; 127
     688:	04 c0       	rjmp	.+8      	; 0x692 <__fixsfsi+0x9c>
     68a:	20 e0       	ldi	r18, 0x00	; 0
     68c:	30 e0       	ldi	r19, 0x00	; 0
     68e:	40 e0       	ldi	r20, 0x00	; 0
     690:	50 e8       	ldi	r21, 0x80	; 128
     692:	b9 01       	movw	r22, r18
     694:	ca 01       	movw	r24, r20
     696:	2c 96       	adiw	r28, 0x0c	; 12
     698:	e2 e0       	ldi	r30, 0x02	; 2
     69a:	0c 94 82 32 	jmp	0x6504	; 0x6504 <__epilogue_restores__+0x20>

0000069e <__floatunsisf>:
     69e:	a8 e0       	ldi	r26, 0x08	; 8
     6a0:	b0 e0       	ldi	r27, 0x00	; 0
     6a2:	e5 e5       	ldi	r30, 0x55	; 85
     6a4:	f3 e0       	ldi	r31, 0x03	; 3
     6a6:	0c 94 5e 32 	jmp	0x64bc	; 0x64bc <__prologue_saves__+0x10>
     6aa:	7b 01       	movw	r14, r22
     6ac:	8c 01       	movw	r16, r24
     6ae:	61 15       	cp	r22, r1
     6b0:	71 05       	cpc	r23, r1
     6b2:	81 05       	cpc	r24, r1
     6b4:	91 05       	cpc	r25, r1
     6b6:	19 f4       	brne	.+6      	; 0x6be <__floatunsisf+0x20>
     6b8:	82 e0       	ldi	r24, 0x02	; 2
     6ba:	89 83       	std	Y+1, r24	; 0x01
     6bc:	60 c0       	rjmp	.+192    	; 0x77e <__floatunsisf+0xe0>
     6be:	83 e0       	ldi	r24, 0x03	; 3
     6c0:	89 83       	std	Y+1, r24	; 0x01
     6c2:	8e e1       	ldi	r24, 0x1E	; 30
     6c4:	c8 2e       	mov	r12, r24
     6c6:	d1 2c       	mov	r13, r1
     6c8:	dc 82       	std	Y+4, r13	; 0x04
     6ca:	cb 82       	std	Y+3, r12	; 0x03
     6cc:	ed 82       	std	Y+5, r14	; 0x05
     6ce:	fe 82       	std	Y+6, r15	; 0x06
     6d0:	0f 83       	std	Y+7, r16	; 0x07
     6d2:	18 87       	std	Y+8, r17	; 0x08
     6d4:	c8 01       	movw	r24, r16
     6d6:	b7 01       	movw	r22, r14
     6d8:	0e 94 c8 03 	call	0x790	; 0x790 <__clzsi2>
     6dc:	fc 01       	movw	r30, r24
     6de:	31 97       	sbiw	r30, 0x01	; 1
     6e0:	f7 ff       	sbrs	r31, 7
     6e2:	3b c0       	rjmp	.+118    	; 0x75a <__floatunsisf+0xbc>
     6e4:	22 27       	eor	r18, r18
     6e6:	33 27       	eor	r19, r19
     6e8:	2e 1b       	sub	r18, r30
     6ea:	3f 0b       	sbc	r19, r31
     6ec:	57 01       	movw	r10, r14
     6ee:	68 01       	movw	r12, r16
     6f0:	02 2e       	mov	r0, r18
     6f2:	04 c0       	rjmp	.+8      	; 0x6fc <__floatunsisf+0x5e>
     6f4:	d6 94       	lsr	r13
     6f6:	c7 94       	ror	r12
     6f8:	b7 94       	ror	r11
     6fa:	a7 94       	ror	r10
     6fc:	0a 94       	dec	r0
     6fe:	d2 f7       	brpl	.-12     	; 0x6f4 <__floatunsisf+0x56>
     700:	40 e0       	ldi	r20, 0x00	; 0
     702:	50 e0       	ldi	r21, 0x00	; 0
     704:	60 e0       	ldi	r22, 0x00	; 0
     706:	70 e0       	ldi	r23, 0x00	; 0
     708:	81 e0       	ldi	r24, 0x01	; 1
     70a:	90 e0       	ldi	r25, 0x00	; 0
     70c:	a0 e0       	ldi	r26, 0x00	; 0
     70e:	b0 e0       	ldi	r27, 0x00	; 0
     710:	04 c0       	rjmp	.+8      	; 0x71a <__floatunsisf+0x7c>
     712:	88 0f       	add	r24, r24
     714:	99 1f       	adc	r25, r25
     716:	aa 1f       	adc	r26, r26
     718:	bb 1f       	adc	r27, r27
     71a:	2a 95       	dec	r18
     71c:	d2 f7       	brpl	.-12     	; 0x712 <__floatunsisf+0x74>
     71e:	01 97       	sbiw	r24, 0x01	; 1
     720:	a1 09       	sbc	r26, r1
     722:	b1 09       	sbc	r27, r1
     724:	8e 21       	and	r24, r14
     726:	9f 21       	and	r25, r15
     728:	a0 23       	and	r26, r16
     72a:	b1 23       	and	r27, r17
     72c:	00 97       	sbiw	r24, 0x00	; 0
     72e:	a1 05       	cpc	r26, r1
     730:	b1 05       	cpc	r27, r1
     732:	21 f0       	breq	.+8      	; 0x73c <__floatunsisf+0x9e>
     734:	41 e0       	ldi	r20, 0x01	; 1
     736:	50 e0       	ldi	r21, 0x00	; 0
     738:	60 e0       	ldi	r22, 0x00	; 0
     73a:	70 e0       	ldi	r23, 0x00	; 0
     73c:	4a 29       	or	r20, r10
     73e:	5b 29       	or	r21, r11
     740:	6c 29       	or	r22, r12
     742:	7d 29       	or	r23, r13
     744:	4d 83       	std	Y+5, r20	; 0x05
     746:	5e 83       	std	Y+6, r21	; 0x06
     748:	6f 83       	std	Y+7, r22	; 0x07
     74a:	78 87       	std	Y+8, r23	; 0x08
     74c:	8e e1       	ldi	r24, 0x1E	; 30
     74e:	90 e0       	ldi	r25, 0x00	; 0
     750:	8e 1b       	sub	r24, r30
     752:	9f 0b       	sbc	r25, r31
     754:	9c 83       	std	Y+4, r25	; 0x04
     756:	8b 83       	std	Y+3, r24	; 0x03
     758:	12 c0       	rjmp	.+36     	; 0x77e <__floatunsisf+0xe0>
     75a:	30 97       	sbiw	r30, 0x00	; 0
     75c:	81 f0       	breq	.+32     	; 0x77e <__floatunsisf+0xe0>
     75e:	0e 2e       	mov	r0, r30
     760:	04 c0       	rjmp	.+8      	; 0x76a <__floatunsisf+0xcc>
     762:	ee 0c       	add	r14, r14
     764:	ff 1c       	adc	r15, r15
     766:	00 1f       	adc	r16, r16
     768:	11 1f       	adc	r17, r17
     76a:	0a 94       	dec	r0
     76c:	d2 f7       	brpl	.-12     	; 0x762 <__floatunsisf+0xc4>
     76e:	ed 82       	std	Y+5, r14	; 0x05
     770:	fe 82       	std	Y+6, r15	; 0x06
     772:	0f 83       	std	Y+7, r16	; 0x07
     774:	18 87       	std	Y+8, r17	; 0x08
     776:	ce 1a       	sub	r12, r30
     778:	df 0a       	sbc	r13, r31
     77a:	dc 82       	std	Y+4, r13	; 0x04
     77c:	cb 82       	std	Y+3, r12	; 0x03
     77e:	1a 82       	std	Y+2, r1	; 0x02
     780:	ce 01       	movw	r24, r28
     782:	01 96       	adiw	r24, 0x01	; 1
     784:	0e 94 17 04 	call	0x82e	; 0x82e <__pack_f>
     788:	28 96       	adiw	r28, 0x08	; 8
     78a:	ea e0       	ldi	r30, 0x0A	; 10
     78c:	0c 94 7a 32 	jmp	0x64f4	; 0x64f4 <__epilogue_restores__+0x10>

00000790 <__clzsi2>:
     790:	ef 92       	push	r14
     792:	ff 92       	push	r15
     794:	0f 93       	push	r16
     796:	1f 93       	push	r17
     798:	7b 01       	movw	r14, r22
     79a:	8c 01       	movw	r16, r24
     79c:	80 e0       	ldi	r24, 0x00	; 0
     79e:	e8 16       	cp	r14, r24
     7a0:	80 e0       	ldi	r24, 0x00	; 0
     7a2:	f8 06       	cpc	r15, r24
     7a4:	81 e0       	ldi	r24, 0x01	; 1
     7a6:	08 07       	cpc	r16, r24
     7a8:	80 e0       	ldi	r24, 0x00	; 0
     7aa:	18 07       	cpc	r17, r24
     7ac:	88 f4       	brcc	.+34     	; 0x7d0 <__clzsi2+0x40>
     7ae:	8f ef       	ldi	r24, 0xFF	; 255
     7b0:	e8 16       	cp	r14, r24
     7b2:	f1 04       	cpc	r15, r1
     7b4:	01 05       	cpc	r16, r1
     7b6:	11 05       	cpc	r17, r1
     7b8:	31 f0       	breq	.+12     	; 0x7c6 <__clzsi2+0x36>
     7ba:	28 f0       	brcs	.+10     	; 0x7c6 <__clzsi2+0x36>
     7bc:	88 e0       	ldi	r24, 0x08	; 8
     7be:	90 e0       	ldi	r25, 0x00	; 0
     7c0:	a0 e0       	ldi	r26, 0x00	; 0
     7c2:	b0 e0       	ldi	r27, 0x00	; 0
     7c4:	17 c0       	rjmp	.+46     	; 0x7f4 <__clzsi2+0x64>
     7c6:	80 e0       	ldi	r24, 0x00	; 0
     7c8:	90 e0       	ldi	r25, 0x00	; 0
     7ca:	a0 e0       	ldi	r26, 0x00	; 0
     7cc:	b0 e0       	ldi	r27, 0x00	; 0
     7ce:	12 c0       	rjmp	.+36     	; 0x7f4 <__clzsi2+0x64>
     7d0:	80 e0       	ldi	r24, 0x00	; 0
     7d2:	e8 16       	cp	r14, r24
     7d4:	80 e0       	ldi	r24, 0x00	; 0
     7d6:	f8 06       	cpc	r15, r24
     7d8:	80 e0       	ldi	r24, 0x00	; 0
     7da:	08 07       	cpc	r16, r24
     7dc:	81 e0       	ldi	r24, 0x01	; 1
     7de:	18 07       	cpc	r17, r24
     7e0:	28 f0       	brcs	.+10     	; 0x7ec <__clzsi2+0x5c>
     7e2:	88 e1       	ldi	r24, 0x18	; 24
     7e4:	90 e0       	ldi	r25, 0x00	; 0
     7e6:	a0 e0       	ldi	r26, 0x00	; 0
     7e8:	b0 e0       	ldi	r27, 0x00	; 0
     7ea:	04 c0       	rjmp	.+8      	; 0x7f4 <__clzsi2+0x64>
     7ec:	80 e1       	ldi	r24, 0x10	; 16
     7ee:	90 e0       	ldi	r25, 0x00	; 0
     7f0:	a0 e0       	ldi	r26, 0x00	; 0
     7f2:	b0 e0       	ldi	r27, 0x00	; 0
     7f4:	20 e2       	ldi	r18, 0x20	; 32
     7f6:	30 e0       	ldi	r19, 0x00	; 0
     7f8:	40 e0       	ldi	r20, 0x00	; 0
     7fa:	50 e0       	ldi	r21, 0x00	; 0
     7fc:	28 1b       	sub	r18, r24
     7fe:	39 0b       	sbc	r19, r25
     800:	4a 0b       	sbc	r20, r26
     802:	5b 0b       	sbc	r21, r27
     804:	04 c0       	rjmp	.+8      	; 0x80e <__clzsi2+0x7e>
     806:	16 95       	lsr	r17
     808:	07 95       	ror	r16
     80a:	f7 94       	ror	r15
     80c:	e7 94       	ror	r14
     80e:	8a 95       	dec	r24
     810:	d2 f7       	brpl	.-12     	; 0x806 <__clzsi2+0x76>
     812:	f7 01       	movw	r30, r14
     814:	e8 56       	subi	r30, 0x68	; 104
     816:	ff 4f       	sbci	r31, 0xFF	; 255
     818:	80 81       	ld	r24, Z
     81a:	28 1b       	sub	r18, r24
     81c:	31 09       	sbc	r19, r1
     81e:	41 09       	sbc	r20, r1
     820:	51 09       	sbc	r21, r1
     822:	c9 01       	movw	r24, r18
     824:	1f 91       	pop	r17
     826:	0f 91       	pop	r16
     828:	ff 90       	pop	r15
     82a:	ef 90       	pop	r14
     82c:	08 95       	ret

0000082e <__pack_f>:
     82e:	df 92       	push	r13
     830:	ef 92       	push	r14
     832:	ff 92       	push	r15
     834:	0f 93       	push	r16
     836:	1f 93       	push	r17
     838:	fc 01       	movw	r30, r24
     83a:	e4 80       	ldd	r14, Z+4	; 0x04
     83c:	f5 80       	ldd	r15, Z+5	; 0x05
     83e:	06 81       	ldd	r16, Z+6	; 0x06
     840:	17 81       	ldd	r17, Z+7	; 0x07
     842:	d1 80       	ldd	r13, Z+1	; 0x01
     844:	80 81       	ld	r24, Z
     846:	82 30       	cpi	r24, 0x02	; 2
     848:	48 f4       	brcc	.+18     	; 0x85c <__pack_f+0x2e>
     84a:	80 e0       	ldi	r24, 0x00	; 0
     84c:	90 e0       	ldi	r25, 0x00	; 0
     84e:	a0 e1       	ldi	r26, 0x10	; 16
     850:	b0 e0       	ldi	r27, 0x00	; 0
     852:	e8 2a       	or	r14, r24
     854:	f9 2a       	or	r15, r25
     856:	0a 2b       	or	r16, r26
     858:	1b 2b       	or	r17, r27
     85a:	a5 c0       	rjmp	.+330    	; 0x9a6 <__stack+0x147>
     85c:	84 30       	cpi	r24, 0x04	; 4
     85e:	09 f4       	brne	.+2      	; 0x862 <__stack+0x3>
     860:	9f c0       	rjmp	.+318    	; 0x9a0 <__stack+0x141>
     862:	82 30       	cpi	r24, 0x02	; 2
     864:	21 f4       	brne	.+8      	; 0x86e <__stack+0xf>
     866:	ee 24       	eor	r14, r14
     868:	ff 24       	eor	r15, r15
     86a:	87 01       	movw	r16, r14
     86c:	05 c0       	rjmp	.+10     	; 0x878 <__stack+0x19>
     86e:	e1 14       	cp	r14, r1
     870:	f1 04       	cpc	r15, r1
     872:	01 05       	cpc	r16, r1
     874:	11 05       	cpc	r17, r1
     876:	19 f4       	brne	.+6      	; 0x87e <__stack+0x1f>
     878:	e0 e0       	ldi	r30, 0x00	; 0
     87a:	f0 e0       	ldi	r31, 0x00	; 0
     87c:	96 c0       	rjmp	.+300    	; 0x9aa <__stack+0x14b>
     87e:	62 81       	ldd	r22, Z+2	; 0x02
     880:	73 81       	ldd	r23, Z+3	; 0x03
     882:	9f ef       	ldi	r25, 0xFF	; 255
     884:	62 38       	cpi	r22, 0x82	; 130
     886:	79 07       	cpc	r23, r25
     888:	0c f0       	brlt	.+2      	; 0x88c <__stack+0x2d>
     88a:	5b c0       	rjmp	.+182    	; 0x942 <__stack+0xe3>
     88c:	22 e8       	ldi	r18, 0x82	; 130
     88e:	3f ef       	ldi	r19, 0xFF	; 255
     890:	26 1b       	sub	r18, r22
     892:	37 0b       	sbc	r19, r23
     894:	2a 31       	cpi	r18, 0x1A	; 26
     896:	31 05       	cpc	r19, r1
     898:	2c f0       	brlt	.+10     	; 0x8a4 <__stack+0x45>
     89a:	20 e0       	ldi	r18, 0x00	; 0
     89c:	30 e0       	ldi	r19, 0x00	; 0
     89e:	40 e0       	ldi	r20, 0x00	; 0
     8a0:	50 e0       	ldi	r21, 0x00	; 0
     8a2:	2a c0       	rjmp	.+84     	; 0x8f8 <__stack+0x99>
     8a4:	b8 01       	movw	r22, r16
     8a6:	a7 01       	movw	r20, r14
     8a8:	02 2e       	mov	r0, r18
     8aa:	04 c0       	rjmp	.+8      	; 0x8b4 <__stack+0x55>
     8ac:	76 95       	lsr	r23
     8ae:	67 95       	ror	r22
     8b0:	57 95       	ror	r21
     8b2:	47 95       	ror	r20
     8b4:	0a 94       	dec	r0
     8b6:	d2 f7       	brpl	.-12     	; 0x8ac <__stack+0x4d>
     8b8:	81 e0       	ldi	r24, 0x01	; 1
     8ba:	90 e0       	ldi	r25, 0x00	; 0
     8bc:	a0 e0       	ldi	r26, 0x00	; 0
     8be:	b0 e0       	ldi	r27, 0x00	; 0
     8c0:	04 c0       	rjmp	.+8      	; 0x8ca <__stack+0x6b>
     8c2:	88 0f       	add	r24, r24
     8c4:	99 1f       	adc	r25, r25
     8c6:	aa 1f       	adc	r26, r26
     8c8:	bb 1f       	adc	r27, r27
     8ca:	2a 95       	dec	r18
     8cc:	d2 f7       	brpl	.-12     	; 0x8c2 <__stack+0x63>
     8ce:	01 97       	sbiw	r24, 0x01	; 1
     8d0:	a1 09       	sbc	r26, r1
     8d2:	b1 09       	sbc	r27, r1
     8d4:	8e 21       	and	r24, r14
     8d6:	9f 21       	and	r25, r15
     8d8:	a0 23       	and	r26, r16
     8da:	b1 23       	and	r27, r17
     8dc:	00 97       	sbiw	r24, 0x00	; 0
     8de:	a1 05       	cpc	r26, r1
     8e0:	b1 05       	cpc	r27, r1
     8e2:	21 f0       	breq	.+8      	; 0x8ec <__stack+0x8d>
     8e4:	81 e0       	ldi	r24, 0x01	; 1
     8e6:	90 e0       	ldi	r25, 0x00	; 0
     8e8:	a0 e0       	ldi	r26, 0x00	; 0
     8ea:	b0 e0       	ldi	r27, 0x00	; 0
     8ec:	9a 01       	movw	r18, r20
     8ee:	ab 01       	movw	r20, r22
     8f0:	28 2b       	or	r18, r24
     8f2:	39 2b       	or	r19, r25
     8f4:	4a 2b       	or	r20, r26
     8f6:	5b 2b       	or	r21, r27
     8f8:	da 01       	movw	r26, r20
     8fa:	c9 01       	movw	r24, r18
     8fc:	8f 77       	andi	r24, 0x7F	; 127
     8fe:	90 70       	andi	r25, 0x00	; 0
     900:	a0 70       	andi	r26, 0x00	; 0
     902:	b0 70       	andi	r27, 0x00	; 0
     904:	80 34       	cpi	r24, 0x40	; 64
     906:	91 05       	cpc	r25, r1
     908:	a1 05       	cpc	r26, r1
     90a:	b1 05       	cpc	r27, r1
     90c:	39 f4       	brne	.+14     	; 0x91c <__stack+0xbd>
     90e:	27 ff       	sbrs	r18, 7
     910:	09 c0       	rjmp	.+18     	; 0x924 <__stack+0xc5>
     912:	20 5c       	subi	r18, 0xC0	; 192
     914:	3f 4f       	sbci	r19, 0xFF	; 255
     916:	4f 4f       	sbci	r20, 0xFF	; 255
     918:	5f 4f       	sbci	r21, 0xFF	; 255
     91a:	04 c0       	rjmp	.+8      	; 0x924 <__stack+0xc5>
     91c:	21 5c       	subi	r18, 0xC1	; 193
     91e:	3f 4f       	sbci	r19, 0xFF	; 255
     920:	4f 4f       	sbci	r20, 0xFF	; 255
     922:	5f 4f       	sbci	r21, 0xFF	; 255
     924:	e0 e0       	ldi	r30, 0x00	; 0
     926:	f0 e0       	ldi	r31, 0x00	; 0
     928:	20 30       	cpi	r18, 0x00	; 0
     92a:	a0 e0       	ldi	r26, 0x00	; 0
     92c:	3a 07       	cpc	r19, r26
     92e:	a0 e0       	ldi	r26, 0x00	; 0
     930:	4a 07       	cpc	r20, r26
     932:	a0 e4       	ldi	r26, 0x40	; 64
     934:	5a 07       	cpc	r21, r26
     936:	10 f0       	brcs	.+4      	; 0x93c <__stack+0xdd>
     938:	e1 e0       	ldi	r30, 0x01	; 1
     93a:	f0 e0       	ldi	r31, 0x00	; 0
     93c:	79 01       	movw	r14, r18
     93e:	8a 01       	movw	r16, r20
     940:	27 c0       	rjmp	.+78     	; 0x990 <__stack+0x131>
     942:	60 38       	cpi	r22, 0x80	; 128
     944:	71 05       	cpc	r23, r1
     946:	64 f5       	brge	.+88     	; 0x9a0 <__stack+0x141>
     948:	fb 01       	movw	r30, r22
     94a:	e1 58       	subi	r30, 0x81	; 129
     94c:	ff 4f       	sbci	r31, 0xFF	; 255
     94e:	d8 01       	movw	r26, r16
     950:	c7 01       	movw	r24, r14
     952:	8f 77       	andi	r24, 0x7F	; 127
     954:	90 70       	andi	r25, 0x00	; 0
     956:	a0 70       	andi	r26, 0x00	; 0
     958:	b0 70       	andi	r27, 0x00	; 0
     95a:	80 34       	cpi	r24, 0x40	; 64
     95c:	91 05       	cpc	r25, r1
     95e:	a1 05       	cpc	r26, r1
     960:	b1 05       	cpc	r27, r1
     962:	39 f4       	brne	.+14     	; 0x972 <__stack+0x113>
     964:	e7 fe       	sbrs	r14, 7
     966:	0d c0       	rjmp	.+26     	; 0x982 <__stack+0x123>
     968:	80 e4       	ldi	r24, 0x40	; 64
     96a:	90 e0       	ldi	r25, 0x00	; 0
     96c:	a0 e0       	ldi	r26, 0x00	; 0
     96e:	b0 e0       	ldi	r27, 0x00	; 0
     970:	04 c0       	rjmp	.+8      	; 0x97a <__stack+0x11b>
     972:	8f e3       	ldi	r24, 0x3F	; 63
     974:	90 e0       	ldi	r25, 0x00	; 0
     976:	a0 e0       	ldi	r26, 0x00	; 0
     978:	b0 e0       	ldi	r27, 0x00	; 0
     97a:	e8 0e       	add	r14, r24
     97c:	f9 1e       	adc	r15, r25
     97e:	0a 1f       	adc	r16, r26
     980:	1b 1f       	adc	r17, r27
     982:	17 ff       	sbrs	r17, 7
     984:	05 c0       	rjmp	.+10     	; 0x990 <__stack+0x131>
     986:	16 95       	lsr	r17
     988:	07 95       	ror	r16
     98a:	f7 94       	ror	r15
     98c:	e7 94       	ror	r14
     98e:	31 96       	adiw	r30, 0x01	; 1
     990:	87 e0       	ldi	r24, 0x07	; 7
     992:	16 95       	lsr	r17
     994:	07 95       	ror	r16
     996:	f7 94       	ror	r15
     998:	e7 94       	ror	r14
     99a:	8a 95       	dec	r24
     99c:	d1 f7       	brne	.-12     	; 0x992 <__stack+0x133>
     99e:	05 c0       	rjmp	.+10     	; 0x9aa <__stack+0x14b>
     9a0:	ee 24       	eor	r14, r14
     9a2:	ff 24       	eor	r15, r15
     9a4:	87 01       	movw	r16, r14
     9a6:	ef ef       	ldi	r30, 0xFF	; 255
     9a8:	f0 e0       	ldi	r31, 0x00	; 0
     9aa:	6e 2f       	mov	r22, r30
     9ac:	67 95       	ror	r22
     9ae:	66 27       	eor	r22, r22
     9b0:	67 95       	ror	r22
     9b2:	90 2f       	mov	r25, r16
     9b4:	9f 77       	andi	r25, 0x7F	; 127
     9b6:	d7 94       	ror	r13
     9b8:	dd 24       	eor	r13, r13
     9ba:	d7 94       	ror	r13
     9bc:	8e 2f       	mov	r24, r30
     9be:	86 95       	lsr	r24
     9c0:	49 2f       	mov	r20, r25
     9c2:	46 2b       	or	r20, r22
     9c4:	58 2f       	mov	r21, r24
     9c6:	5d 29       	or	r21, r13
     9c8:	b7 01       	movw	r22, r14
     9ca:	ca 01       	movw	r24, r20
     9cc:	1f 91       	pop	r17
     9ce:	0f 91       	pop	r16
     9d0:	ff 90       	pop	r15
     9d2:	ef 90       	pop	r14
     9d4:	df 90       	pop	r13
     9d6:	08 95       	ret

000009d8 <__unpack_f>:
     9d8:	fc 01       	movw	r30, r24
     9da:	db 01       	movw	r26, r22
     9dc:	40 81       	ld	r20, Z
     9de:	51 81       	ldd	r21, Z+1	; 0x01
     9e0:	22 81       	ldd	r18, Z+2	; 0x02
     9e2:	62 2f       	mov	r22, r18
     9e4:	6f 77       	andi	r22, 0x7F	; 127
     9e6:	70 e0       	ldi	r23, 0x00	; 0
     9e8:	22 1f       	adc	r18, r18
     9ea:	22 27       	eor	r18, r18
     9ec:	22 1f       	adc	r18, r18
     9ee:	93 81       	ldd	r25, Z+3	; 0x03
     9f0:	89 2f       	mov	r24, r25
     9f2:	88 0f       	add	r24, r24
     9f4:	82 2b       	or	r24, r18
     9f6:	28 2f       	mov	r18, r24
     9f8:	30 e0       	ldi	r19, 0x00	; 0
     9fa:	99 1f       	adc	r25, r25
     9fc:	99 27       	eor	r25, r25
     9fe:	99 1f       	adc	r25, r25
     a00:	11 96       	adiw	r26, 0x01	; 1
     a02:	9c 93       	st	X, r25
     a04:	11 97       	sbiw	r26, 0x01	; 1
     a06:	21 15       	cp	r18, r1
     a08:	31 05       	cpc	r19, r1
     a0a:	a9 f5       	brne	.+106    	; 0xa76 <__unpack_f+0x9e>
     a0c:	41 15       	cp	r20, r1
     a0e:	51 05       	cpc	r21, r1
     a10:	61 05       	cpc	r22, r1
     a12:	71 05       	cpc	r23, r1
     a14:	11 f4       	brne	.+4      	; 0xa1a <__unpack_f+0x42>
     a16:	82 e0       	ldi	r24, 0x02	; 2
     a18:	37 c0       	rjmp	.+110    	; 0xa88 <__unpack_f+0xb0>
     a1a:	82 e8       	ldi	r24, 0x82	; 130
     a1c:	9f ef       	ldi	r25, 0xFF	; 255
     a1e:	13 96       	adiw	r26, 0x03	; 3
     a20:	9c 93       	st	X, r25
     a22:	8e 93       	st	-X, r24
     a24:	12 97       	sbiw	r26, 0x02	; 2
     a26:	9a 01       	movw	r18, r20
     a28:	ab 01       	movw	r20, r22
     a2a:	67 e0       	ldi	r22, 0x07	; 7
     a2c:	22 0f       	add	r18, r18
     a2e:	33 1f       	adc	r19, r19
     a30:	44 1f       	adc	r20, r20
     a32:	55 1f       	adc	r21, r21
     a34:	6a 95       	dec	r22
     a36:	d1 f7       	brne	.-12     	; 0xa2c <__unpack_f+0x54>
     a38:	83 e0       	ldi	r24, 0x03	; 3
     a3a:	8c 93       	st	X, r24
     a3c:	0d c0       	rjmp	.+26     	; 0xa58 <__unpack_f+0x80>
     a3e:	22 0f       	add	r18, r18
     a40:	33 1f       	adc	r19, r19
     a42:	44 1f       	adc	r20, r20
     a44:	55 1f       	adc	r21, r21
     a46:	12 96       	adiw	r26, 0x02	; 2
     a48:	8d 91       	ld	r24, X+
     a4a:	9c 91       	ld	r25, X
     a4c:	13 97       	sbiw	r26, 0x03	; 3
     a4e:	01 97       	sbiw	r24, 0x01	; 1
     a50:	13 96       	adiw	r26, 0x03	; 3
     a52:	9c 93       	st	X, r25
     a54:	8e 93       	st	-X, r24
     a56:	12 97       	sbiw	r26, 0x02	; 2
     a58:	20 30       	cpi	r18, 0x00	; 0
     a5a:	80 e0       	ldi	r24, 0x00	; 0
     a5c:	38 07       	cpc	r19, r24
     a5e:	80 e0       	ldi	r24, 0x00	; 0
     a60:	48 07       	cpc	r20, r24
     a62:	80 e4       	ldi	r24, 0x40	; 64
     a64:	58 07       	cpc	r21, r24
     a66:	58 f3       	brcs	.-42     	; 0xa3e <__unpack_f+0x66>
     a68:	14 96       	adiw	r26, 0x04	; 4
     a6a:	2d 93       	st	X+, r18
     a6c:	3d 93       	st	X+, r19
     a6e:	4d 93       	st	X+, r20
     a70:	5c 93       	st	X, r21
     a72:	17 97       	sbiw	r26, 0x07	; 7
     a74:	08 95       	ret
     a76:	2f 3f       	cpi	r18, 0xFF	; 255
     a78:	31 05       	cpc	r19, r1
     a7a:	79 f4       	brne	.+30     	; 0xa9a <__unpack_f+0xc2>
     a7c:	41 15       	cp	r20, r1
     a7e:	51 05       	cpc	r21, r1
     a80:	61 05       	cpc	r22, r1
     a82:	71 05       	cpc	r23, r1
     a84:	19 f4       	brne	.+6      	; 0xa8c <__unpack_f+0xb4>
     a86:	84 e0       	ldi	r24, 0x04	; 4
     a88:	8c 93       	st	X, r24
     a8a:	08 95       	ret
     a8c:	64 ff       	sbrs	r22, 4
     a8e:	03 c0       	rjmp	.+6      	; 0xa96 <__unpack_f+0xbe>
     a90:	81 e0       	ldi	r24, 0x01	; 1
     a92:	8c 93       	st	X, r24
     a94:	12 c0       	rjmp	.+36     	; 0xaba <__unpack_f+0xe2>
     a96:	1c 92       	st	X, r1
     a98:	10 c0       	rjmp	.+32     	; 0xaba <__unpack_f+0xe2>
     a9a:	2f 57       	subi	r18, 0x7F	; 127
     a9c:	30 40       	sbci	r19, 0x00	; 0
     a9e:	13 96       	adiw	r26, 0x03	; 3
     aa0:	3c 93       	st	X, r19
     aa2:	2e 93       	st	-X, r18
     aa4:	12 97       	sbiw	r26, 0x02	; 2
     aa6:	83 e0       	ldi	r24, 0x03	; 3
     aa8:	8c 93       	st	X, r24
     aaa:	87 e0       	ldi	r24, 0x07	; 7
     aac:	44 0f       	add	r20, r20
     aae:	55 1f       	adc	r21, r21
     ab0:	66 1f       	adc	r22, r22
     ab2:	77 1f       	adc	r23, r23
     ab4:	8a 95       	dec	r24
     ab6:	d1 f7       	brne	.-12     	; 0xaac <__unpack_f+0xd4>
     ab8:	70 64       	ori	r23, 0x40	; 64
     aba:	14 96       	adiw	r26, 0x04	; 4
     abc:	4d 93       	st	X+, r20
     abe:	5d 93       	st	X+, r21
     ac0:	6d 93       	st	X+, r22
     ac2:	7c 93       	st	X, r23
     ac4:	17 97       	sbiw	r26, 0x07	; 7
     ac6:	08 95       	ret

00000ac8 <__fpcmp_parts_f>:
     ac8:	1f 93       	push	r17
     aca:	dc 01       	movw	r26, r24
     acc:	fb 01       	movw	r30, r22
     ace:	9c 91       	ld	r25, X
     ad0:	92 30       	cpi	r25, 0x02	; 2
     ad2:	08 f4       	brcc	.+2      	; 0xad6 <__fpcmp_parts_f+0xe>
     ad4:	47 c0       	rjmp	.+142    	; 0xb64 <__fpcmp_parts_f+0x9c>
     ad6:	80 81       	ld	r24, Z
     ad8:	82 30       	cpi	r24, 0x02	; 2
     ada:	08 f4       	brcc	.+2      	; 0xade <__fpcmp_parts_f+0x16>
     adc:	43 c0       	rjmp	.+134    	; 0xb64 <__fpcmp_parts_f+0x9c>
     ade:	94 30       	cpi	r25, 0x04	; 4
     ae0:	51 f4       	brne	.+20     	; 0xaf6 <__fpcmp_parts_f+0x2e>
     ae2:	11 96       	adiw	r26, 0x01	; 1
     ae4:	1c 91       	ld	r17, X
     ae6:	84 30       	cpi	r24, 0x04	; 4
     ae8:	99 f5       	brne	.+102    	; 0xb50 <__fpcmp_parts_f+0x88>
     aea:	81 81       	ldd	r24, Z+1	; 0x01
     aec:	68 2f       	mov	r22, r24
     aee:	70 e0       	ldi	r23, 0x00	; 0
     af0:	61 1b       	sub	r22, r17
     af2:	71 09       	sbc	r23, r1
     af4:	3f c0       	rjmp	.+126    	; 0xb74 <__fpcmp_parts_f+0xac>
     af6:	84 30       	cpi	r24, 0x04	; 4
     af8:	21 f0       	breq	.+8      	; 0xb02 <__fpcmp_parts_f+0x3a>
     afa:	92 30       	cpi	r25, 0x02	; 2
     afc:	31 f4       	brne	.+12     	; 0xb0a <__fpcmp_parts_f+0x42>
     afe:	82 30       	cpi	r24, 0x02	; 2
     b00:	b9 f1       	breq	.+110    	; 0xb70 <__fpcmp_parts_f+0xa8>
     b02:	81 81       	ldd	r24, Z+1	; 0x01
     b04:	88 23       	and	r24, r24
     b06:	89 f1       	breq	.+98     	; 0xb6a <__fpcmp_parts_f+0xa2>
     b08:	2d c0       	rjmp	.+90     	; 0xb64 <__fpcmp_parts_f+0x9c>
     b0a:	11 96       	adiw	r26, 0x01	; 1
     b0c:	1c 91       	ld	r17, X
     b0e:	11 97       	sbiw	r26, 0x01	; 1
     b10:	82 30       	cpi	r24, 0x02	; 2
     b12:	f1 f0       	breq	.+60     	; 0xb50 <__fpcmp_parts_f+0x88>
     b14:	81 81       	ldd	r24, Z+1	; 0x01
     b16:	18 17       	cp	r17, r24
     b18:	d9 f4       	brne	.+54     	; 0xb50 <__fpcmp_parts_f+0x88>
     b1a:	12 96       	adiw	r26, 0x02	; 2
     b1c:	2d 91       	ld	r18, X+
     b1e:	3c 91       	ld	r19, X
     b20:	13 97       	sbiw	r26, 0x03	; 3
     b22:	82 81       	ldd	r24, Z+2	; 0x02
     b24:	93 81       	ldd	r25, Z+3	; 0x03
     b26:	82 17       	cp	r24, r18
     b28:	93 07       	cpc	r25, r19
     b2a:	94 f0       	brlt	.+36     	; 0xb50 <__fpcmp_parts_f+0x88>
     b2c:	28 17       	cp	r18, r24
     b2e:	39 07       	cpc	r19, r25
     b30:	bc f0       	brlt	.+46     	; 0xb60 <__fpcmp_parts_f+0x98>
     b32:	14 96       	adiw	r26, 0x04	; 4
     b34:	8d 91       	ld	r24, X+
     b36:	9d 91       	ld	r25, X+
     b38:	0d 90       	ld	r0, X+
     b3a:	bc 91       	ld	r27, X
     b3c:	a0 2d       	mov	r26, r0
     b3e:	24 81       	ldd	r18, Z+4	; 0x04
     b40:	35 81       	ldd	r19, Z+5	; 0x05
     b42:	46 81       	ldd	r20, Z+6	; 0x06
     b44:	57 81       	ldd	r21, Z+7	; 0x07
     b46:	28 17       	cp	r18, r24
     b48:	39 07       	cpc	r19, r25
     b4a:	4a 07       	cpc	r20, r26
     b4c:	5b 07       	cpc	r21, r27
     b4e:	18 f4       	brcc	.+6      	; 0xb56 <__fpcmp_parts_f+0x8e>
     b50:	11 23       	and	r17, r17
     b52:	41 f0       	breq	.+16     	; 0xb64 <__fpcmp_parts_f+0x9c>
     b54:	0a c0       	rjmp	.+20     	; 0xb6a <__fpcmp_parts_f+0xa2>
     b56:	82 17       	cp	r24, r18
     b58:	93 07       	cpc	r25, r19
     b5a:	a4 07       	cpc	r26, r20
     b5c:	b5 07       	cpc	r27, r21
     b5e:	40 f4       	brcc	.+16     	; 0xb70 <__fpcmp_parts_f+0xa8>
     b60:	11 23       	and	r17, r17
     b62:	19 f0       	breq	.+6      	; 0xb6a <__fpcmp_parts_f+0xa2>
     b64:	61 e0       	ldi	r22, 0x01	; 1
     b66:	70 e0       	ldi	r23, 0x00	; 0
     b68:	05 c0       	rjmp	.+10     	; 0xb74 <__fpcmp_parts_f+0xac>
     b6a:	6f ef       	ldi	r22, 0xFF	; 255
     b6c:	7f ef       	ldi	r23, 0xFF	; 255
     b6e:	02 c0       	rjmp	.+4      	; 0xb74 <__fpcmp_parts_f+0xac>
     b70:	60 e0       	ldi	r22, 0x00	; 0
     b72:	70 e0       	ldi	r23, 0x00	; 0
     b74:	cb 01       	movw	r24, r22
     b76:	1f 91       	pop	r17
     b78:	08 95       	ret

00000b7a <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
     b7a:	df 93       	push	r29
     b7c:	cf 93       	push	r28
     b7e:	00 d0       	rcall	.+0      	; 0xb80 <xEventGroupCreate+0x6>
     b80:	cd b7       	in	r28, 0x3d	; 61
     b82:	de b7       	in	r29, 0x3e	; 62
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
     b84:	8b e0       	ldi	r24, 0x0B	; 11
     b86:	90 e0       	ldi	r25, 0x00	; 0
     b88:	0e 94 02 09 	call	0x1204	; 0x1204 <pvPortMalloc>
     b8c:	9a 83       	std	Y+2, r25	; 0x02
     b8e:	89 83       	std	Y+1, r24	; 0x01

		if( pxEventBits != NULL )
     b90:	89 81       	ldd	r24, Y+1	; 0x01
     b92:	9a 81       	ldd	r25, Y+2	; 0x02
     b94:	00 97       	sbiw	r24, 0x00	; 0
     b96:	49 f0       	breq	.+18     	; 0xbaa <xEventGroupCreate+0x30>
		{
			pxEventBits->uxEventBits = 0;
     b98:	e9 81       	ldd	r30, Y+1	; 0x01
     b9a:	fa 81       	ldd	r31, Y+2	; 0x02
     b9c:	11 82       	std	Z+1, r1	; 0x01
     b9e:	10 82       	st	Z, r1
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
     ba0:	89 81       	ldd	r24, Y+1	; 0x01
     ba2:	9a 81       	ldd	r25, Y+2	; 0x02
     ba4:	02 96       	adiw	r24, 0x02	; 2
     ba6:	0e 94 7e 09 	call	0x12fc	; 0x12fc <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
     baa:	89 81       	ldd	r24, Y+1	; 0x01
     bac:	9a 81       	ldd	r25, Y+2	; 0x02
	}
     bae:	0f 90       	pop	r0
     bb0:	0f 90       	pop	r0
     bb2:	cf 91       	pop	r28
     bb4:	df 91       	pop	r29
     bb6:	08 95       	ret

00000bb8 <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
     bb8:	df 93       	push	r29
     bba:	cf 93       	push	r28
     bbc:	cd b7       	in	r28, 0x3d	; 61
     bbe:	de b7       	in	r29, 0x3e	; 62
     bc0:	60 97       	sbiw	r28, 0x10	; 16
     bc2:	0f b6       	in	r0, 0x3f	; 63
     bc4:	f8 94       	cli
     bc6:	de bf       	out	0x3e, r29	; 62
     bc8:	0f be       	out	0x3f, r0	; 63
     bca:	cd bf       	out	0x3d, r28	; 61
     bcc:	9a 87       	std	Y+10, r25	; 0x0a
     bce:	89 87       	std	Y+9, r24	; 0x09
     bd0:	7c 87       	std	Y+12, r23	; 0x0c
     bd2:	6b 87       	std	Y+11, r22	; 0x0b
     bd4:	5e 87       	std	Y+14, r21	; 0x0e
     bd6:	4d 87       	std	Y+13, r20	; 0x0d
     bd8:	38 8b       	std	Y+16, r19	; 0x10
     bda:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = xEventGroup;
     bdc:	89 85       	ldd	r24, Y+9	; 0x09
     bde:	9a 85       	ldd	r25, Y+10	; 0x0a
     be0:	9c 83       	std	Y+4, r25	; 0x04
     be2:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     be4:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     be6:	0e 94 25 27 	call	0x4e4a	; 0x4e4a <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
     bea:	eb 81       	ldd	r30, Y+3	; 0x03
     bec:	fc 81       	ldd	r31, Y+4	; 0x04
     bee:	80 81       	ld	r24, Z
     bf0:	91 81       	ldd	r25, Z+1	; 0x01
     bf2:	98 87       	std	Y+8, r25	; 0x08
     bf4:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
     bf6:	89 85       	ldd	r24, Y+9	; 0x09
     bf8:	9a 85       	ldd	r25, Y+10	; 0x0a
     bfa:	2b 85       	ldd	r18, Y+11	; 0x0b
     bfc:	3c 85       	ldd	r19, Y+12	; 0x0c
     bfe:	b9 01       	movw	r22, r18
     c00:	0e 94 b3 07 	call	0xf66	; 0xf66 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
     c04:	2f 81       	ldd	r18, Y+7	; 0x07
     c06:	38 85       	ldd	r19, Y+8	; 0x08
     c08:	8b 85       	ldd	r24, Y+11	; 0x0b
     c0a:	9c 85       	ldd	r25, Y+12	; 0x0c
     c0c:	28 2b       	or	r18, r24
     c0e:	39 2b       	or	r19, r25
     c10:	8d 85       	ldd	r24, Y+13	; 0x0d
     c12:	9e 85       	ldd	r25, Y+14	; 0x0e
     c14:	28 23       	and	r18, r24
     c16:	39 23       	and	r19, r25
     c18:	8d 85       	ldd	r24, Y+13	; 0x0d
     c1a:	9e 85       	ldd	r25, Y+14	; 0x0e
     c1c:	28 17       	cp	r18, r24
     c1e:	39 07       	cpc	r19, r25
     c20:	c9 f4       	brne	.+50     	; 0xc54 <xEventGroupSync+0x9c>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
     c22:	2f 81       	ldd	r18, Y+7	; 0x07
     c24:	38 85       	ldd	r19, Y+8	; 0x08
     c26:	8b 85       	ldd	r24, Y+11	; 0x0b
     c28:	9c 85       	ldd	r25, Y+12	; 0x0c
     c2a:	82 2b       	or	r24, r18
     c2c:	93 2b       	or	r25, r19
     c2e:	9e 83       	std	Y+6, r25	; 0x06
     c30:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     c32:	eb 81       	ldd	r30, Y+3	; 0x03
     c34:	fc 81       	ldd	r31, Y+4	; 0x04
     c36:	20 81       	ld	r18, Z
     c38:	31 81       	ldd	r19, Z+1	; 0x01
     c3a:	8d 85       	ldd	r24, Y+13	; 0x0d
     c3c:	9e 85       	ldd	r25, Y+14	; 0x0e
     c3e:	80 95       	com	r24
     c40:	90 95       	com	r25
     c42:	82 23       	and	r24, r18
     c44:	93 23       	and	r25, r19
     c46:	eb 81       	ldd	r30, Y+3	; 0x03
     c48:	fc 81       	ldd	r31, Y+4	; 0x04
     c4a:	91 83       	std	Z+1, r25	; 0x01
     c4c:	80 83       	st	Z, r24

			xTicksToWait = 0;
     c4e:	18 8a       	std	Y+16, r1	; 0x10
     c50:	1f 86       	std	Y+15, r1	; 0x0f
     c52:	1e c0       	rjmp	.+60     	; 0xc90 <xEventGroupSync+0xd8>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
     c54:	8f 85       	ldd	r24, Y+15	; 0x0f
     c56:	98 89       	ldd	r25, Y+16	; 0x10
     c58:	00 97       	sbiw	r24, 0x00	; 0
     c5a:	91 f0       	breq	.+36     	; 0xc80 <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
     c5c:	8b 81       	ldd	r24, Y+3	; 0x03
     c5e:	9c 81       	ldd	r25, Y+4	; 0x04
     c60:	bc 01       	movw	r22, r24
     c62:	6e 5f       	subi	r22, 0xFE	; 254
     c64:	7f 4f       	sbci	r23, 0xFF	; 255
     c66:	8d 85       	ldd	r24, Y+13	; 0x0d
     c68:	9e 85       	ldd	r25, Y+14	; 0x0e
     c6a:	9c 01       	movw	r18, r24
     c6c:	35 60       	ori	r19, 0x05	; 5
     c6e:	4f 85       	ldd	r20, Y+15	; 0x0f
     c70:	58 89       	ldd	r21, Y+16	; 0x10
     c72:	cb 01       	movw	r24, r22
     c74:	b9 01       	movw	r22, r18
     c76:	0e 94 95 29 	call	0x532a	; 0x532a <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
     c7a:	1e 82       	std	Y+6, r1	; 0x06
     c7c:	1d 82       	std	Y+5, r1	; 0x05
     c7e:	08 c0       	rjmp	.+16     	; 0xc90 <xEventGroupSync+0xd8>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     c80:	eb 81       	ldd	r30, Y+3	; 0x03
     c82:	fc 81       	ldd	r31, Y+4	; 0x04
     c84:	80 81       	ld	r24, Z
     c86:	91 81       	ldd	r25, Z+1	; 0x01
     c88:	9e 83       	std	Y+6, r25	; 0x06
     c8a:	8d 83       	std	Y+5, r24	; 0x05
				xTimeoutOccurred = pdTRUE;
     c8c:	81 e0       	ldi	r24, 0x01	; 1
     c8e:	89 83       	std	Y+1, r24	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     c90:	0e 94 31 27 	call	0x4e62	; 0x4e62 <xTaskResumeAll>
     c94:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
     c96:	8f 85       	ldd	r24, Y+15	; 0x0f
     c98:	98 89       	ldd	r25, Y+16	; 0x10
     c9a:	00 97       	sbiw	r24, 0x00	; 0
     c9c:	09 f4       	brne	.+2      	; 0xca0 <xEventGroupSync+0xe8>
     c9e:	3a c0       	rjmp	.+116    	; 0xd14 <xEventGroupSync+0x15c>
	{
		if( xAlreadyYielded == pdFALSE )
     ca0:	8a 81       	ldd	r24, Y+2	; 0x02
     ca2:	88 23       	and	r24, r24
     ca4:	11 f4       	brne	.+4      	; 0xcaa <xEventGroupSync+0xf2>
		{
			portYIELD_WITHIN_API();
     ca6:	0e 94 e2 11 	call	0x23c4	; 0x23c4 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     caa:	0e 94 ad 2d 	call	0x5b5a	; 0x5b5a <uxTaskResetEventItemValue>
     cae:	9e 83       	std	Y+6, r25	; 0x06
     cb0:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     cb2:	8d 81       	ldd	r24, Y+5	; 0x05
     cb4:	9e 81       	ldd	r25, Y+6	; 0x06
     cb6:	80 70       	andi	r24, 0x00	; 0
     cb8:	92 70       	andi	r25, 0x02	; 2
     cba:	00 97       	sbiw	r24, 0x00	; 0
     cbc:	31 f5       	brne	.+76     	; 0xd0a <xEventGroupSync+0x152>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
     cbe:	0f b6       	in	r0, 0x3f	; 63
     cc0:	f8 94       	cli
     cc2:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
     cc4:	eb 81       	ldd	r30, Y+3	; 0x03
     cc6:	fc 81       	ldd	r31, Y+4	; 0x04
     cc8:	80 81       	ld	r24, Z
     cca:	91 81       	ldd	r25, Z+1	; 0x01
     ccc:	9e 83       	std	Y+6, r25	; 0x06
     cce:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
     cd0:	2d 81       	ldd	r18, Y+5	; 0x05
     cd2:	3e 81       	ldd	r19, Y+6	; 0x06
     cd4:	8d 85       	ldd	r24, Y+13	; 0x0d
     cd6:	9e 85       	ldd	r25, Y+14	; 0x0e
     cd8:	28 23       	and	r18, r24
     cda:	39 23       	and	r19, r25
     cdc:	8d 85       	ldd	r24, Y+13	; 0x0d
     cde:	9e 85       	ldd	r25, Y+14	; 0x0e
     ce0:	28 17       	cp	r18, r24
     ce2:	39 07       	cpc	r19, r25
     ce4:	71 f4       	brne	.+28     	; 0xd02 <xEventGroupSync+0x14a>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     ce6:	eb 81       	ldd	r30, Y+3	; 0x03
     ce8:	fc 81       	ldd	r31, Y+4	; 0x04
     cea:	20 81       	ld	r18, Z
     cec:	31 81       	ldd	r19, Z+1	; 0x01
     cee:	8d 85       	ldd	r24, Y+13	; 0x0d
     cf0:	9e 85       	ldd	r25, Y+14	; 0x0e
     cf2:	80 95       	com	r24
     cf4:	90 95       	com	r25
     cf6:	82 23       	and	r24, r18
     cf8:	93 23       	and	r25, r19
     cfa:	eb 81       	ldd	r30, Y+3	; 0x03
     cfc:	fc 81       	ldd	r31, Y+4	; 0x04
     cfe:	91 83       	std	Z+1, r25	; 0x01
     d00:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     d02:	0f 90       	pop	r0
     d04:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
     d06:	81 e0       	ldi	r24, 0x01	; 1
     d08:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     d0a:	8d 81       	ldd	r24, Y+5	; 0x05
     d0c:	9e 81       	ldd	r25, Y+6	; 0x06
     d0e:	90 70       	andi	r25, 0x00	; 0
     d10:	9e 83       	std	Y+6, r25	; 0x06
     d12:	8d 83       	std	Y+5, r24	; 0x05
	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
     d14:	8d 81       	ldd	r24, Y+5	; 0x05
     d16:	9e 81       	ldd	r25, Y+6	; 0x06
}
     d18:	60 96       	adiw	r28, 0x10	; 16
     d1a:	0f b6       	in	r0, 0x3f	; 63
     d1c:	f8 94       	cli
     d1e:	de bf       	out	0x3e, r29	; 62
     d20:	0f be       	out	0x3f, r0	; 63
     d22:	cd bf       	out	0x3d, r28	; 61
     d24:	cf 91       	pop	r28
     d26:	df 91       	pop	r29
     d28:	08 95       	ret

00000d2a <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
     d2a:	0f 93       	push	r16
     d2c:	1f 93       	push	r17
     d2e:	df 93       	push	r29
     d30:	cf 93       	push	r28
     d32:	cd b7       	in	r28, 0x3d	; 61
     d34:	de b7       	in	r29, 0x3e	; 62
     d36:	63 97       	sbiw	r28, 0x13	; 19
     d38:	0f b6       	in	r0, 0x3f	; 63
     d3a:	f8 94       	cli
     d3c:	de bf       	out	0x3e, r29	; 62
     d3e:	0f be       	out	0x3f, r0	; 63
     d40:	cd bf       	out	0x3d, r28	; 61
     d42:	9d 87       	std	Y+13, r25	; 0x0d
     d44:	8c 87       	std	Y+12, r24	; 0x0c
     d46:	7f 87       	std	Y+15, r23	; 0x0f
     d48:	6e 87       	std	Y+14, r22	; 0x0e
     d4a:	48 8b       	std	Y+16, r20	; 0x10
     d4c:	29 8b       	std	Y+17, r18	; 0x11
     d4e:	1b 8b       	std	Y+19, r17	; 0x13
     d50:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = xEventGroup;
     d52:	8c 85       	ldd	r24, Y+12	; 0x0c
     d54:	9d 85       	ldd	r25, Y+13	; 0x0d
     d56:	9b 87       	std	Y+11, r25	; 0x0b
     d58:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
     d5a:	1f 82       	std	Y+7, r1	; 0x07
     d5c:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     d5e:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     d60:	0e 94 25 27 	call	0x4e4a	; 0x4e4a <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     d64:	ea 85       	ldd	r30, Y+10	; 0x0a
     d66:	fb 85       	ldd	r31, Y+11	; 0x0b
     d68:	80 81       	ld	r24, Z
     d6a:	91 81       	ldd	r25, Z+1	; 0x01
     d6c:	9a 83       	std	Y+2, r25	; 0x02
     d6e:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
     d70:	89 81       	ldd	r24, Y+1	; 0x01
     d72:	9a 81       	ldd	r25, Y+2	; 0x02
     d74:	2e 85       	ldd	r18, Y+14	; 0x0e
     d76:	3f 85       	ldd	r19, Y+15	; 0x0f
     d78:	b9 01       	movw	r22, r18
     d7a:	49 89       	ldd	r20, Y+17	; 0x11
     d7c:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <prvTestWaitCondition>
     d80:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
     d82:	8d 81       	ldd	r24, Y+5	; 0x05
     d84:	88 23       	and	r24, r24
     d86:	c1 f0       	breq	.+48     	; 0xdb8 <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
     d88:	89 81       	ldd	r24, Y+1	; 0x01
     d8a:	9a 81       	ldd	r25, Y+2	; 0x02
     d8c:	99 87       	std	Y+9, r25	; 0x09
     d8e:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
     d90:	1b 8a       	std	Y+19, r1	; 0x13
     d92:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
     d94:	88 89       	ldd	r24, Y+16	; 0x10
     d96:	88 23       	and	r24, r24
     d98:	e9 f1       	breq	.+122    	; 0xe14 <xEventGroupWaitBits+0xea>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     d9a:	ea 85       	ldd	r30, Y+10	; 0x0a
     d9c:	fb 85       	ldd	r31, Y+11	; 0x0b
     d9e:	20 81       	ld	r18, Z
     da0:	31 81       	ldd	r19, Z+1	; 0x01
     da2:	8e 85       	ldd	r24, Y+14	; 0x0e
     da4:	9f 85       	ldd	r25, Y+15	; 0x0f
     da6:	80 95       	com	r24
     da8:	90 95       	com	r25
     daa:	82 23       	and	r24, r18
     dac:	93 23       	and	r25, r19
     dae:	ea 85       	ldd	r30, Y+10	; 0x0a
     db0:	fb 85       	ldd	r31, Y+11	; 0x0b
     db2:	91 83       	std	Z+1, r25	; 0x01
     db4:	80 83       	st	Z, r24
     db6:	2e c0       	rjmp	.+92     	; 0xe14 <xEventGroupWaitBits+0xea>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
     db8:	8a 89       	ldd	r24, Y+18	; 0x12
     dba:	9b 89       	ldd	r25, Y+19	; 0x13
     dbc:	00 97       	sbiw	r24, 0x00	; 0
     dbe:	39 f4       	brne	.+14     	; 0xdce <xEventGroupWaitBits+0xa4>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
     dc0:	89 81       	ldd	r24, Y+1	; 0x01
     dc2:	9a 81       	ldd	r25, Y+2	; 0x02
     dc4:	99 87       	std	Y+9, r25	; 0x09
     dc6:	88 87       	std	Y+8, r24	; 0x08
			xTimeoutOccurred = pdTRUE;
     dc8:	81 e0       	ldi	r24, 0x01	; 1
     dca:	8b 83       	std	Y+3, r24	; 0x03
     dcc:	23 c0       	rjmp	.+70     	; 0xe14 <xEventGroupWaitBits+0xea>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
     dce:	88 89       	ldd	r24, Y+16	; 0x10
     dd0:	88 23       	and	r24, r24
     dd2:	29 f0       	breq	.+10     	; 0xdde <xEventGroupWaitBits+0xb4>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
     dd4:	8e 81       	ldd	r24, Y+6	; 0x06
     dd6:	9f 81       	ldd	r25, Y+7	; 0x07
     dd8:	91 60       	ori	r25, 0x01	; 1
     dda:	9f 83       	std	Y+7, r25	; 0x07
     ddc:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
     dde:	89 89       	ldd	r24, Y+17	; 0x11
     de0:	88 23       	and	r24, r24
     de2:	29 f0       	breq	.+10     	; 0xdee <xEventGroupWaitBits+0xc4>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
     de4:	8e 81       	ldd	r24, Y+6	; 0x06
     de6:	9f 81       	ldd	r25, Y+7	; 0x07
     de8:	94 60       	ori	r25, 0x04	; 4
     dea:	9f 83       	std	Y+7, r25	; 0x07
     dec:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     dee:	8a 85       	ldd	r24, Y+10	; 0x0a
     df0:	9b 85       	ldd	r25, Y+11	; 0x0b
     df2:	bc 01       	movw	r22, r24
     df4:	6e 5f       	subi	r22, 0xFE	; 254
     df6:	7f 4f       	sbci	r23, 0xFF	; 255
     df8:	2e 85       	ldd	r18, Y+14	; 0x0e
     dfa:	3f 85       	ldd	r19, Y+15	; 0x0f
     dfc:	8e 81       	ldd	r24, Y+6	; 0x06
     dfe:	9f 81       	ldd	r25, Y+7	; 0x07
     e00:	28 2b       	or	r18, r24
     e02:	39 2b       	or	r19, r25
     e04:	4a 89       	ldd	r20, Y+18	; 0x12
     e06:	5b 89       	ldd	r21, Y+19	; 0x13
     e08:	cb 01       	movw	r24, r22
     e0a:	b9 01       	movw	r22, r18
     e0c:	0e 94 95 29 	call	0x532a	; 0x532a <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
     e10:	19 86       	std	Y+9, r1	; 0x09
     e12:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     e14:	0e 94 31 27 	call	0x4e62	; 0x4e62 <xTaskResumeAll>
     e18:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
     e1a:	8a 89       	ldd	r24, Y+18	; 0x12
     e1c:	9b 89       	ldd	r25, Y+19	; 0x13
     e1e:	00 97       	sbiw	r24, 0x00	; 0
     e20:	09 f4       	brne	.+2      	; 0xe24 <xEventGroupWaitBits+0xfa>
     e22:	3c c0       	rjmp	.+120    	; 0xe9c <xEventGroupWaitBits+0x172>
	{
		if( xAlreadyYielded == pdFALSE )
     e24:	8c 81       	ldd	r24, Y+4	; 0x04
     e26:	88 23       	and	r24, r24
     e28:	11 f4       	brne	.+4      	; 0xe2e <xEventGroupWaitBits+0x104>
		{
			portYIELD_WITHIN_API();
     e2a:	0e 94 e2 11 	call	0x23c4	; 0x23c4 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     e2e:	0e 94 ad 2d 	call	0x5b5a	; 0x5b5a <uxTaskResetEventItemValue>
     e32:	99 87       	std	Y+9, r25	; 0x09
     e34:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     e36:	88 85       	ldd	r24, Y+8	; 0x08
     e38:	99 85       	ldd	r25, Y+9	; 0x09
     e3a:	80 70       	andi	r24, 0x00	; 0
     e3c:	92 70       	andi	r25, 0x02	; 2
     e3e:	00 97       	sbiw	r24, 0x00	; 0
     e40:	41 f5       	brne	.+80     	; 0xe92 <xEventGroupWaitBits+0x168>
		{
			taskENTER_CRITICAL();
     e42:	0f b6       	in	r0, 0x3f	; 63
     e44:	f8 94       	cli
     e46:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     e48:	ea 85       	ldd	r30, Y+10	; 0x0a
     e4a:	fb 85       	ldd	r31, Y+11	; 0x0b
     e4c:	80 81       	ld	r24, Z
     e4e:	91 81       	ldd	r25, Z+1	; 0x01
     e50:	99 87       	std	Y+9, r25	; 0x09
     e52:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
     e54:	88 85       	ldd	r24, Y+8	; 0x08
     e56:	99 85       	ldd	r25, Y+9	; 0x09
     e58:	2e 85       	ldd	r18, Y+14	; 0x0e
     e5a:	3f 85       	ldd	r19, Y+15	; 0x0f
     e5c:	b9 01       	movw	r22, r18
     e5e:	49 89       	ldd	r20, Y+17	; 0x11
     e60:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <prvTestWaitCondition>
     e64:	88 23       	and	r24, r24
     e66:	89 f0       	breq	.+34     	; 0xe8a <xEventGroupWaitBits+0x160>
				{
					if( xClearOnExit != pdFALSE )
     e68:	88 89       	ldd	r24, Y+16	; 0x10
     e6a:	88 23       	and	r24, r24
     e6c:	71 f0       	breq	.+28     	; 0xe8a <xEventGroupWaitBits+0x160>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     e6e:	ea 85       	ldd	r30, Y+10	; 0x0a
     e70:	fb 85       	ldd	r31, Y+11	; 0x0b
     e72:	20 81       	ld	r18, Z
     e74:	31 81       	ldd	r19, Z+1	; 0x01
     e76:	8e 85       	ldd	r24, Y+14	; 0x0e
     e78:	9f 85       	ldd	r25, Y+15	; 0x0f
     e7a:	80 95       	com	r24
     e7c:	90 95       	com	r25
     e7e:	82 23       	and	r24, r18
     e80:	93 23       	and	r25, r19
     e82:	ea 85       	ldd	r30, Y+10	; 0x0a
     e84:	fb 85       	ldd	r31, Y+11	; 0x0b
     e86:	91 83       	std	Z+1, r25	; 0x01
     e88:	80 83       	st	Z, r24
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
     e8a:	81 e0       	ldi	r24, 0x01	; 1
     e8c:	8b 83       	std	Y+3, r24	; 0x03
			}
			taskEXIT_CRITICAL();
     e8e:	0f 90       	pop	r0
     e90:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     e92:	88 85       	ldd	r24, Y+8	; 0x08
     e94:	99 85       	ldd	r25, Y+9	; 0x09
     e96:	90 70       	andi	r25, 0x00	; 0
     e98:	99 87       	std	Y+9, r25	; 0x09
     e9a:	88 87       	std	Y+8, r24	; 0x08
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
     e9c:	88 85       	ldd	r24, Y+8	; 0x08
     e9e:	99 85       	ldd	r25, Y+9	; 0x09
}
     ea0:	63 96       	adiw	r28, 0x13	; 19
     ea2:	0f b6       	in	r0, 0x3f	; 63
     ea4:	f8 94       	cli
     ea6:	de bf       	out	0x3e, r29	; 62
     ea8:	0f be       	out	0x3f, r0	; 63
     eaa:	cd bf       	out	0x3d, r28	; 61
     eac:	cf 91       	pop	r28
     eae:	df 91       	pop	r29
     eb0:	1f 91       	pop	r17
     eb2:	0f 91       	pop	r16
     eb4:	08 95       	ret

00000eb6 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
     eb6:	df 93       	push	r29
     eb8:	cf 93       	push	r28
     eba:	cd b7       	in	r28, 0x3d	; 61
     ebc:	de b7       	in	r29, 0x3e	; 62
     ebe:	28 97       	sbiw	r28, 0x08	; 8
     ec0:	0f b6       	in	r0, 0x3f	; 63
     ec2:	f8 94       	cli
     ec4:	de bf       	out	0x3e, r29	; 62
     ec6:	0f be       	out	0x3f, r0	; 63
     ec8:	cd bf       	out	0x3d, r28	; 61
     eca:	9e 83       	std	Y+6, r25	; 0x06
     ecc:	8d 83       	std	Y+5, r24	; 0x05
     ece:	78 87       	std	Y+8, r23	; 0x08
     ed0:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = xEventGroup;
     ed2:	8d 81       	ldd	r24, Y+5	; 0x05
     ed4:	9e 81       	ldd	r25, Y+6	; 0x06
     ed6:	9c 83       	std	Y+4, r25	; 0x04
     ed8:	8b 83       	std	Y+3, r24	; 0x03
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
     eda:	0f b6       	in	r0, 0x3f	; 63
     edc:	f8 94       	cli
     ede:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
     ee0:	eb 81       	ldd	r30, Y+3	; 0x03
     ee2:	fc 81       	ldd	r31, Y+4	; 0x04
     ee4:	80 81       	ld	r24, Z
     ee6:	91 81       	ldd	r25, Z+1	; 0x01
     ee8:	9a 83       	std	Y+2, r25	; 0x02
     eea:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     eec:	eb 81       	ldd	r30, Y+3	; 0x03
     eee:	fc 81       	ldd	r31, Y+4	; 0x04
     ef0:	20 81       	ld	r18, Z
     ef2:	31 81       	ldd	r19, Z+1	; 0x01
     ef4:	8f 81       	ldd	r24, Y+7	; 0x07
     ef6:	98 85       	ldd	r25, Y+8	; 0x08
     ef8:	80 95       	com	r24
     efa:	90 95       	com	r25
     efc:	82 23       	and	r24, r18
     efe:	93 23       	and	r25, r19
     f00:	eb 81       	ldd	r30, Y+3	; 0x03
     f02:	fc 81       	ldd	r31, Y+4	; 0x04
     f04:	91 83       	std	Z+1, r25	; 0x01
     f06:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
     f08:	0f 90       	pop	r0
     f0a:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
     f0c:	89 81       	ldd	r24, Y+1	; 0x01
     f0e:	9a 81       	ldd	r25, Y+2	; 0x02
}
     f10:	28 96       	adiw	r28, 0x08	; 8
     f12:	0f b6       	in	r0, 0x3f	; 63
     f14:	f8 94       	cli
     f16:	de bf       	out	0x3e, r29	; 62
     f18:	0f be       	out	0x3f, r0	; 63
     f1a:	cd bf       	out	0x3d, r28	; 61
     f1c:	cf 91       	pop	r28
     f1e:	df 91       	pop	r29
     f20:	08 95       	ret

00000f22 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
     f22:	df 93       	push	r29
     f24:	cf 93       	push	r28
     f26:	cd b7       	in	r28, 0x3d	; 61
     f28:	de b7       	in	r29, 0x3e	; 62
     f2a:	27 97       	sbiw	r28, 0x07	; 7
     f2c:	0f b6       	in	r0, 0x3f	; 63
     f2e:	f8 94       	cli
     f30:	de bf       	out	0x3e, r29	; 62
     f32:	0f be       	out	0x3f, r0	; 63
     f34:	cd bf       	out	0x3d, r28	; 61
     f36:	9f 83       	std	Y+7, r25	; 0x07
     f38:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t const * const pxEventBits = xEventGroup;
     f3a:	8e 81       	ldd	r24, Y+6	; 0x06
     f3c:	9f 81       	ldd	r25, Y+7	; 0x07
     f3e:	9c 83       	std	Y+4, r25	; 0x04
     f40:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     f42:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
     f44:	eb 81       	ldd	r30, Y+3	; 0x03
     f46:	fc 81       	ldd	r31, Y+4	; 0x04
     f48:	80 81       	ld	r24, Z
     f4a:	91 81       	ldd	r25, Z+1	; 0x01
     f4c:	9a 83       	std	Y+2, r25	; 0x02
     f4e:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
     f50:	89 81       	ldd	r24, Y+1	; 0x01
     f52:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
     f54:	27 96       	adiw	r28, 0x07	; 7
     f56:	0f b6       	in	r0, 0x3f	; 63
     f58:	f8 94       	cli
     f5a:	de bf       	out	0x3e, r29	; 62
     f5c:	0f be       	out	0x3f, r0	; 63
     f5e:	cd bf       	out	0x3d, r28	; 61
     f60:	cf 91       	pop	r28
     f62:	df 91       	pop	r29
     f64:	08 95       	ret

00000f66 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
     f66:	df 93       	push	r29
     f68:	cf 93       	push	r28
     f6a:	cd b7       	in	r28, 0x3d	; 61
     f6c:	de b7       	in	r29, 0x3e	; 62
     f6e:	65 97       	sbiw	r28, 0x15	; 21
     f70:	0f b6       	in	r0, 0x3f	; 63
     f72:	f8 94       	cli
     f74:	de bf       	out	0x3e, r29	; 62
     f76:	0f be       	out	0x3f, r0	; 63
     f78:	cd bf       	out	0x3d, r28	; 61
     f7a:	9b 8b       	std	Y+19, r25	; 0x13
     f7c:	8a 8b       	std	Y+18, r24	; 0x12
     f7e:	7d 8b       	std	Y+21, r23	; 0x15
     f80:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     f82:	19 86       	std	Y+9, r1	; 0x09
     f84:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = xEventGroup;
     f86:	8a 89       	ldd	r24, Y+18	; 0x12
     f88:	9b 89       	ldd	r25, Y+19	; 0x13
     f8a:	9b 83       	std	Y+3, r25	; 0x03
     f8c:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
     f8e:	19 82       	std	Y+1, r1	; 0x01
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
     f90:	8a 81       	ldd	r24, Y+2	; 0x02
     f92:	9b 81       	ldd	r25, Y+3	; 0x03
     f94:	02 96       	adiw	r24, 0x02	; 2
     f96:	9b 87       	std	Y+11, r25	; 0x0b
     f98:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     f9a:	8a 85       	ldd	r24, Y+10	; 0x0a
     f9c:	9b 85       	ldd	r25, Y+11	; 0x0b
     f9e:	03 96       	adiw	r24, 0x03	; 3
     fa0:	9d 87       	std	Y+13, r25	; 0x0d
     fa2:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
     fa4:	0e 94 25 27 	call	0x4e4a	; 0x4e4a <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
     fa8:	ea 85       	ldd	r30, Y+10	; 0x0a
     faa:	fb 85       	ldd	r31, Y+11	; 0x0b
     fac:	85 81       	ldd	r24, Z+5	; 0x05
     fae:	96 81       	ldd	r25, Z+6	; 0x06
     fb0:	99 8b       	std	Y+17, r25	; 0x11
     fb2:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
     fb4:	ea 81       	ldd	r30, Y+2	; 0x02
     fb6:	fb 81       	ldd	r31, Y+3	; 0x03
     fb8:	20 81       	ld	r18, Z
     fba:	31 81       	ldd	r19, Z+1	; 0x01
     fbc:	8c 89       	ldd	r24, Y+20	; 0x14
     fbe:	9d 89       	ldd	r25, Y+21	; 0x15
     fc0:	82 2b       	or	r24, r18
     fc2:	93 2b       	or	r25, r19
     fc4:	ea 81       	ldd	r30, Y+2	; 0x02
     fc6:	fb 81       	ldd	r31, Y+3	; 0x03
     fc8:	91 83       	std	Z+1, r25	; 0x01
     fca:	80 83       	st	Z, r24
     fcc:	59 c0       	rjmp	.+178    	; 0x1080 <xEventGroupSetBits+0x11a>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
     fce:	e8 89       	ldd	r30, Y+16	; 0x10
     fd0:	f9 89       	ldd	r31, Y+17	; 0x11
     fd2:	82 81       	ldd	r24, Z+2	; 0x02
     fd4:	93 81       	ldd	r25, Z+3	; 0x03
     fd6:	9f 87       	std	Y+15, r25	; 0x0f
     fd8:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     fda:	e8 89       	ldd	r30, Y+16	; 0x10
     fdc:	f9 89       	ldd	r31, Y+17	; 0x11
     fde:	80 81       	ld	r24, Z
     fe0:	91 81       	ldd	r25, Z+1	; 0x01
     fe2:	9f 83       	std	Y+7, r25	; 0x07
     fe4:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
     fe6:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
     fe8:	8e 81       	ldd	r24, Y+6	; 0x06
     fea:	9f 81       	ldd	r25, Y+7	; 0x07
     fec:	80 70       	andi	r24, 0x00	; 0
     fee:	9d 83       	std	Y+5, r25	; 0x05
     ff0:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     ff2:	8e 81       	ldd	r24, Y+6	; 0x06
     ff4:	9f 81       	ldd	r25, Y+7	; 0x07
     ff6:	90 70       	andi	r25, 0x00	; 0
     ff8:	9f 83       	std	Y+7, r25	; 0x07
     ffa:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     ffc:	8c 81       	ldd	r24, Y+4	; 0x04
     ffe:	9d 81       	ldd	r25, Y+5	; 0x05
    1000:	80 70       	andi	r24, 0x00	; 0
    1002:	94 70       	andi	r25, 0x04	; 4
    1004:	00 97       	sbiw	r24, 0x00	; 0
    1006:	69 f4       	brne	.+26     	; 0x1022 <xEventGroupSetBits+0xbc>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    1008:	ea 81       	ldd	r30, Y+2	; 0x02
    100a:	fb 81       	ldd	r31, Y+3	; 0x03
    100c:	20 81       	ld	r18, Z
    100e:	31 81       	ldd	r19, Z+1	; 0x01
    1010:	8e 81       	ldd	r24, Y+6	; 0x06
    1012:	9f 81       	ldd	r25, Y+7	; 0x07
    1014:	82 23       	and	r24, r18
    1016:	93 23       	and	r25, r19
    1018:	00 97       	sbiw	r24, 0x00	; 0
    101a:	91 f0       	breq	.+36     	; 0x1040 <xEventGroupSetBits+0xda>
				{
					xMatchFound = pdTRUE;
    101c:	81 e0       	ldi	r24, 0x01	; 1
    101e:	89 83       	std	Y+1, r24	; 0x01
    1020:	0f c0       	rjmp	.+30     	; 0x1040 <xEventGroupSetBits+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    1022:	ea 81       	ldd	r30, Y+2	; 0x02
    1024:	fb 81       	ldd	r31, Y+3	; 0x03
    1026:	20 81       	ld	r18, Z
    1028:	31 81       	ldd	r19, Z+1	; 0x01
    102a:	8e 81       	ldd	r24, Y+6	; 0x06
    102c:	9f 81       	ldd	r25, Y+7	; 0x07
    102e:	28 23       	and	r18, r24
    1030:	39 23       	and	r19, r25
    1032:	8e 81       	ldd	r24, Y+6	; 0x06
    1034:	9f 81       	ldd	r25, Y+7	; 0x07
    1036:	28 17       	cp	r18, r24
    1038:	39 07       	cpc	r19, r25
    103a:	11 f4       	brne	.+4      	; 0x1040 <xEventGroupSetBits+0xda>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
    103c:	81 e0       	ldi	r24, 0x01	; 1
    103e:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
    1040:	89 81       	ldd	r24, Y+1	; 0x01
    1042:	88 23       	and	r24, r24
    1044:	c9 f0       	breq	.+50     	; 0x1078 <xEventGroupSetBits+0x112>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    1046:	8c 81       	ldd	r24, Y+4	; 0x04
    1048:	9d 81       	ldd	r25, Y+5	; 0x05
    104a:	80 70       	andi	r24, 0x00	; 0
    104c:	91 70       	andi	r25, 0x01	; 1
    104e:	00 97       	sbiw	r24, 0x00	; 0
    1050:	41 f0       	breq	.+16     	; 0x1062 <xEventGroupSetBits+0xfc>
				{
					uxBitsToClear |= uxBitsWaitedFor;
    1052:	88 85       	ldd	r24, Y+8	; 0x08
    1054:	99 85       	ldd	r25, Y+9	; 0x09
    1056:	2e 81       	ldd	r18, Y+6	; 0x06
    1058:	3f 81       	ldd	r19, Y+7	; 0x07
    105a:	82 2b       	or	r24, r18
    105c:	93 2b       	or	r25, r19
    105e:	99 87       	std	Y+9, r25	; 0x09
    1060:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    1062:	ea 81       	ldd	r30, Y+2	; 0x02
    1064:	fb 81       	ldd	r31, Y+3	; 0x03
    1066:	80 81       	ld	r24, Z
    1068:	91 81       	ldd	r25, Z+1	; 0x01
    106a:	9c 01       	movw	r18, r24
    106c:	32 60       	ori	r19, 0x02	; 2
    106e:	88 89       	ldd	r24, Y+16	; 0x10
    1070:	99 89       	ldd	r25, Y+17	; 0x11
    1072:	b9 01       	movw	r22, r18
    1074:	0e 94 30 2a 	call	0x5460	; 0x5460 <vTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
    1078:	8e 85       	ldd	r24, Y+14	; 0x0e
    107a:	9f 85       	ldd	r25, Y+15	; 0x0f
    107c:	99 8b       	std	Y+17, r25	; 0x11
    107e:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    1080:	28 89       	ldd	r18, Y+16	; 0x10
    1082:	39 89       	ldd	r19, Y+17	; 0x11
    1084:	8c 85       	ldd	r24, Y+12	; 0x0c
    1086:	9d 85       	ldd	r25, Y+13	; 0x0d
    1088:	28 17       	cp	r18, r24
    108a:	39 07       	cpc	r19, r25
    108c:	09 f0       	breq	.+2      	; 0x1090 <xEventGroupSetBits+0x12a>
    108e:	9f cf       	rjmp	.-194    	; 0xfce <xEventGroupSetBits+0x68>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    1090:	ea 81       	ldd	r30, Y+2	; 0x02
    1092:	fb 81       	ldd	r31, Y+3	; 0x03
    1094:	20 81       	ld	r18, Z
    1096:	31 81       	ldd	r19, Z+1	; 0x01
    1098:	88 85       	ldd	r24, Y+8	; 0x08
    109a:	99 85       	ldd	r25, Y+9	; 0x09
    109c:	80 95       	com	r24
    109e:	90 95       	com	r25
    10a0:	82 23       	and	r24, r18
    10a2:	93 23       	and	r25, r19
    10a4:	ea 81       	ldd	r30, Y+2	; 0x02
    10a6:	fb 81       	ldd	r31, Y+3	; 0x03
    10a8:	91 83       	std	Z+1, r25	; 0x01
    10aa:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
    10ac:	0e 94 31 27 	call	0x4e62	; 0x4e62 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
    10b0:	ea 81       	ldd	r30, Y+2	; 0x02
    10b2:	fb 81       	ldd	r31, Y+3	; 0x03
    10b4:	80 81       	ld	r24, Z
    10b6:	91 81       	ldd	r25, Z+1	; 0x01
}
    10b8:	65 96       	adiw	r28, 0x15	; 21
    10ba:	0f b6       	in	r0, 0x3f	; 63
    10bc:	f8 94       	cli
    10be:	de bf       	out	0x3e, r29	; 62
    10c0:	0f be       	out	0x3f, r0	; 63
    10c2:	cd bf       	out	0x3d, r28	; 61
    10c4:	cf 91       	pop	r28
    10c6:	df 91       	pop	r29
    10c8:	08 95       	ret

000010ca <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    10ca:	df 93       	push	r29
    10cc:	cf 93       	push	r28
    10ce:	00 d0       	rcall	.+0      	; 0x10d0 <vEventGroupDelete+0x6>
    10d0:	00 d0       	rcall	.+0      	; 0x10d2 <vEventGroupDelete+0x8>
    10d2:	00 d0       	rcall	.+0      	; 0x10d4 <vEventGroupDelete+0xa>
    10d4:	cd b7       	in	r28, 0x3d	; 61
    10d6:	de b7       	in	r29, 0x3e	; 62
    10d8:	9e 83       	std	Y+6, r25	; 0x06
    10da:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = xEventGroup;
    10dc:	8d 81       	ldd	r24, Y+5	; 0x05
    10de:	9e 81       	ldd	r25, Y+6	; 0x06
    10e0:	9c 83       	std	Y+4, r25	; 0x04
    10e2:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    10e4:	8b 81       	ldd	r24, Y+3	; 0x03
    10e6:	9c 81       	ldd	r25, Y+4	; 0x04
    10e8:	02 96       	adiw	r24, 0x02	; 2
    10ea:	9a 83       	std	Y+2, r25	; 0x02
    10ec:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
    10ee:	0e 94 25 27 	call	0x4e4a	; 0x4e4a <vTaskSuspendAll>
    10f2:	08 c0       	rjmp	.+16     	; 0x1104 <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    10f4:	e9 81       	ldd	r30, Y+1	; 0x01
    10f6:	fa 81       	ldd	r31, Y+2	; 0x02
    10f8:	85 81       	ldd	r24, Z+5	; 0x05
    10fa:	96 81       	ldd	r25, Z+6	; 0x06
    10fc:	60 e0       	ldi	r22, 0x00	; 0
    10fe:	72 e0       	ldi	r23, 0x02	; 2
    1100:	0e 94 30 2a 	call	0x5460	; 0x5460 <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    1104:	e9 81       	ldd	r30, Y+1	; 0x01
    1106:	fa 81       	ldd	r31, Y+2	; 0x02
    1108:	80 81       	ld	r24, Z
    110a:	88 23       	and	r24, r24
    110c:	99 f7       	brne	.-26     	; 0x10f4 <vEventGroupDelete+0x2a>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
    110e:	8b 81       	ldd	r24, Y+3	; 0x03
    1110:	9c 81       	ldd	r25, Y+4	; 0x04
    1112:	0e 94 58 09 	call	0x12b0	; 0x12b0 <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
    1116:	0e 94 31 27 	call	0x4e62	; 0x4e62 <xTaskResumeAll>
}
    111a:	26 96       	adiw	r28, 0x06	; 6
    111c:	0f b6       	in	r0, 0x3f	; 63
    111e:	f8 94       	cli
    1120:	de bf       	out	0x3e, r29	; 62
    1122:	0f be       	out	0x3f, r0	; 63
    1124:	cd bf       	out	0x3d, r28	; 61
    1126:	cf 91       	pop	r28
    1128:	df 91       	pop	r29
    112a:	08 95       	ret

0000112c <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
    112c:	df 93       	push	r29
    112e:	cf 93       	push	r28
    1130:	00 d0       	rcall	.+0      	; 0x1132 <vEventGroupSetBitsCallback+0x6>
    1132:	00 d0       	rcall	.+0      	; 0x1134 <vEventGroupSetBitsCallback+0x8>
    1134:	00 d0       	rcall	.+0      	; 0x1136 <vEventGroupSetBitsCallback+0xa>
    1136:	cd b7       	in	r28, 0x3d	; 61
    1138:	de b7       	in	r29, 0x3e	; 62
    113a:	9a 83       	std	Y+2, r25	; 0x02
    113c:	89 83       	std	Y+1, r24	; 0x01
    113e:	4b 83       	std	Y+3, r20	; 0x03
    1140:	5c 83       	std	Y+4, r21	; 0x04
    1142:	6d 83       	std	Y+5, r22	; 0x05
    1144:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    1146:	89 81       	ldd	r24, Y+1	; 0x01
    1148:	9a 81       	ldd	r25, Y+2	; 0x02
    114a:	2b 81       	ldd	r18, Y+3	; 0x03
    114c:	3c 81       	ldd	r19, Y+4	; 0x04
    114e:	b9 01       	movw	r22, r18
    1150:	0e 94 b3 07 	call	0xf66	; 0xf66 <xEventGroupSetBits>
}
    1154:	26 96       	adiw	r28, 0x06	; 6
    1156:	0f b6       	in	r0, 0x3f	; 63
    1158:	f8 94       	cli
    115a:	de bf       	out	0x3e, r29	; 62
    115c:	0f be       	out	0x3f, r0	; 63
    115e:	cd bf       	out	0x3d, r28	; 61
    1160:	cf 91       	pop	r28
    1162:	df 91       	pop	r29
    1164:	08 95       	ret

00001166 <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
    1166:	df 93       	push	r29
    1168:	cf 93       	push	r28
    116a:	00 d0       	rcall	.+0      	; 0x116c <vEventGroupClearBitsCallback+0x6>
    116c:	00 d0       	rcall	.+0      	; 0x116e <vEventGroupClearBitsCallback+0x8>
    116e:	00 d0       	rcall	.+0      	; 0x1170 <vEventGroupClearBitsCallback+0xa>
    1170:	cd b7       	in	r28, 0x3d	; 61
    1172:	de b7       	in	r29, 0x3e	; 62
    1174:	9a 83       	std	Y+2, r25	; 0x02
    1176:	89 83       	std	Y+1, r24	; 0x01
    1178:	4b 83       	std	Y+3, r20	; 0x03
    117a:	5c 83       	std	Y+4, r21	; 0x04
    117c:	6d 83       	std	Y+5, r22	; 0x05
    117e:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    1180:	89 81       	ldd	r24, Y+1	; 0x01
    1182:	9a 81       	ldd	r25, Y+2	; 0x02
    1184:	2b 81       	ldd	r18, Y+3	; 0x03
    1186:	3c 81       	ldd	r19, Y+4	; 0x04
    1188:	b9 01       	movw	r22, r18
    118a:	0e 94 5b 07 	call	0xeb6	; 0xeb6 <xEventGroupClearBits>
}
    118e:	26 96       	adiw	r28, 0x06	; 6
    1190:	0f b6       	in	r0, 0x3f	; 63
    1192:	f8 94       	cli
    1194:	de bf       	out	0x3e, r29	; 62
    1196:	0f be       	out	0x3f, r0	; 63
    1198:	cd bf       	out	0x3d, r28	; 61
    119a:	cf 91       	pop	r28
    119c:	df 91       	pop	r29
    119e:	08 95       	ret

000011a0 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
    11a0:	df 93       	push	r29
    11a2:	cf 93       	push	r28
    11a4:	00 d0       	rcall	.+0      	; 0x11a6 <prvTestWaitCondition+0x6>
    11a6:	00 d0       	rcall	.+0      	; 0x11a8 <prvTestWaitCondition+0x8>
    11a8:	00 d0       	rcall	.+0      	; 0x11aa <prvTestWaitCondition+0xa>
    11aa:	cd b7       	in	r28, 0x3d	; 61
    11ac:	de b7       	in	r29, 0x3e	; 62
    11ae:	9b 83       	std	Y+3, r25	; 0x03
    11b0:	8a 83       	std	Y+2, r24	; 0x02
    11b2:	7d 83       	std	Y+5, r23	; 0x05
    11b4:	6c 83       	std	Y+4, r22	; 0x04
    11b6:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
    11b8:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
    11ba:	8e 81       	ldd	r24, Y+6	; 0x06
    11bc:	88 23       	and	r24, r24
    11be:	59 f4       	brne	.+22     	; 0x11d6 <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    11c0:	8a 81       	ldd	r24, Y+2	; 0x02
    11c2:	9b 81       	ldd	r25, Y+3	; 0x03
    11c4:	2c 81       	ldd	r18, Y+4	; 0x04
    11c6:	3d 81       	ldd	r19, Y+5	; 0x05
    11c8:	82 23       	and	r24, r18
    11ca:	93 23       	and	r25, r19
    11cc:	00 97       	sbiw	r24, 0x00	; 0
    11ce:	81 f0       	breq	.+32     	; 0x11f0 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    11d0:	81 e0       	ldi	r24, 0x01	; 1
    11d2:	89 83       	std	Y+1, r24	; 0x01
    11d4:	0d c0       	rjmp	.+26     	; 0x11f0 <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    11d6:	2a 81       	ldd	r18, Y+2	; 0x02
    11d8:	3b 81       	ldd	r19, Y+3	; 0x03
    11da:	8c 81       	ldd	r24, Y+4	; 0x04
    11dc:	9d 81       	ldd	r25, Y+5	; 0x05
    11de:	28 23       	and	r18, r24
    11e0:	39 23       	and	r19, r25
    11e2:	8c 81       	ldd	r24, Y+4	; 0x04
    11e4:	9d 81       	ldd	r25, Y+5	; 0x05
    11e6:	28 17       	cp	r18, r24
    11e8:	39 07       	cpc	r19, r25
    11ea:	11 f4       	brne	.+4      	; 0x11f0 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    11ec:	81 e0       	ldi	r24, 0x01	; 1
    11ee:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
    11f0:	89 81       	ldd	r24, Y+1	; 0x01
}
    11f2:	26 96       	adiw	r28, 0x06	; 6
    11f4:	0f b6       	in	r0, 0x3f	; 63
    11f6:	f8 94       	cli
    11f8:	de bf       	out	0x3e, r29	; 62
    11fa:	0f be       	out	0x3f, r0	; 63
    11fc:	cd bf       	out	0x3d, r28	; 61
    11fe:	cf 91       	pop	r28
    1200:	df 91       	pop	r29
    1202:	08 95       	ret

00001204 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1204:	df 93       	push	r29
    1206:	cf 93       	push	r28
    1208:	00 d0       	rcall	.+0      	; 0x120a <pvPortMalloc+0x6>
    120a:	00 d0       	rcall	.+0      	; 0x120c <pvPortMalloc+0x8>
    120c:	cd b7       	in	r28, 0x3d	; 61
    120e:	de b7       	in	r29, 0x3e	; 62
    1210:	9c 83       	std	Y+4, r25	; 0x04
    1212:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    1214:	1a 82       	std	Y+2, r1	; 0x02
    1216:	19 82       	std	Y+1, r1	; 0x01
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    1218:	0e 94 25 27 	call	0x4e4a	; 0x4e4a <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    121c:	80 91 9a 01 	lds	r24, 0x019A
    1220:	90 91 9b 01 	lds	r25, 0x019B
    1224:	00 97       	sbiw	r24, 0x00	; 0
    1226:	31 f4       	brne	.+12     	; 0x1234 <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    1228:	8d e9       	ldi	r24, 0x9D	; 157
    122a:	91 e0       	ldi	r25, 0x01	; 1
    122c:	90 93 9b 01 	sts	0x019B, r25
    1230:	80 93 9a 01 	sts	0x019A, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    1234:	80 91 98 01 	lds	r24, 0x0198
    1238:	90 91 99 01 	lds	r25, 0x0199
    123c:	2b 81       	ldd	r18, Y+3	; 0x03
    123e:	3c 81       	ldd	r19, Y+4	; 0x04
    1240:	82 0f       	add	r24, r18
    1242:	93 1f       	adc	r25, r19
    1244:	25 e0       	ldi	r18, 0x05	; 5
    1246:	8b 3d       	cpi	r24, 0xDB	; 219
    1248:	92 07       	cpc	r25, r18
    124a:	38 f5       	brcc	.+78     	; 0x129a <pvPortMalloc+0x96>
    124c:	20 91 98 01 	lds	r18, 0x0198
    1250:	30 91 99 01 	lds	r19, 0x0199
    1254:	8b 81       	ldd	r24, Y+3	; 0x03
    1256:	9c 81       	ldd	r25, Y+4	; 0x04
    1258:	28 0f       	add	r18, r24
    125a:	39 1f       	adc	r19, r25
    125c:	80 91 98 01 	lds	r24, 0x0198
    1260:	90 91 99 01 	lds	r25, 0x0199
    1264:	82 17       	cp	r24, r18
    1266:	93 07       	cpc	r25, r19
    1268:	c0 f4       	brcc	.+48     	; 0x129a <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    126a:	20 91 9a 01 	lds	r18, 0x019A
    126e:	30 91 9b 01 	lds	r19, 0x019B
    1272:	80 91 98 01 	lds	r24, 0x0198
    1276:	90 91 99 01 	lds	r25, 0x0199
    127a:	82 0f       	add	r24, r18
    127c:	93 1f       	adc	r25, r19
    127e:	9a 83       	std	Y+2, r25	; 0x02
    1280:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    1282:	20 91 98 01 	lds	r18, 0x0198
    1286:	30 91 99 01 	lds	r19, 0x0199
    128a:	8b 81       	ldd	r24, Y+3	; 0x03
    128c:	9c 81       	ldd	r25, Y+4	; 0x04
    128e:	82 0f       	add	r24, r18
    1290:	93 1f       	adc	r25, r19
    1292:	90 93 99 01 	sts	0x0199, r25
    1296:	80 93 98 01 	sts	0x0198, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    129a:	0e 94 31 27 	call	0x4e62	; 0x4e62 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    129e:	89 81       	ldd	r24, Y+1	; 0x01
    12a0:	9a 81       	ldd	r25, Y+2	; 0x02
}
    12a2:	0f 90       	pop	r0
    12a4:	0f 90       	pop	r0
    12a6:	0f 90       	pop	r0
    12a8:	0f 90       	pop	r0
    12aa:	cf 91       	pop	r28
    12ac:	df 91       	pop	r29
    12ae:	08 95       	ret

000012b0 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    12b0:	df 93       	push	r29
    12b2:	cf 93       	push	r28
    12b4:	00 d0       	rcall	.+0      	; 0x12b6 <vPortFree+0x6>
    12b6:	cd b7       	in	r28, 0x3d	; 61
    12b8:	de b7       	in	r29, 0x3e	; 62
    12ba:	9a 83       	std	Y+2, r25	; 0x02
    12bc:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    12be:	0f 90       	pop	r0
    12c0:	0f 90       	pop	r0
    12c2:	cf 91       	pop	r28
    12c4:	df 91       	pop	r29
    12c6:	08 95       	ret

000012c8 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    12c8:	df 93       	push	r29
    12ca:	cf 93       	push	r28
    12cc:	cd b7       	in	r28, 0x3d	; 61
    12ce:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    12d0:	10 92 99 01 	sts	0x0199, r1
    12d4:	10 92 98 01 	sts	0x0198, r1
}
    12d8:	cf 91       	pop	r28
    12da:	df 91       	pop	r29
    12dc:	08 95       	ret

000012de <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    12de:	df 93       	push	r29
    12e0:	cf 93       	push	r28
    12e2:	cd b7       	in	r28, 0x3d	; 61
    12e4:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    12e6:	20 91 98 01 	lds	r18, 0x0198
    12ea:	30 91 99 01 	lds	r19, 0x0199
    12ee:	8b ed       	ldi	r24, 0xDB	; 219
    12f0:	95 e0       	ldi	r25, 0x05	; 5
    12f2:	82 1b       	sub	r24, r18
    12f4:	93 0b       	sbc	r25, r19
}
    12f6:	cf 91       	pop	r28
    12f8:	df 91       	pop	r29
    12fa:	08 95       	ret

000012fc <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    12fc:	df 93       	push	r29
    12fe:	cf 93       	push	r28
    1300:	00 d0       	rcall	.+0      	; 0x1302 <vListInitialise+0x6>
    1302:	cd b7       	in	r28, 0x3d	; 61
    1304:	de b7       	in	r29, 0x3e	; 62
    1306:	9a 83       	std	Y+2, r25	; 0x02
    1308:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    130a:	89 81       	ldd	r24, Y+1	; 0x01
    130c:	9a 81       	ldd	r25, Y+2	; 0x02
    130e:	03 96       	adiw	r24, 0x03	; 3
    1310:	e9 81       	ldd	r30, Y+1	; 0x01
    1312:	fa 81       	ldd	r31, Y+2	; 0x02
    1314:	92 83       	std	Z+2, r25	; 0x02
    1316:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1318:	e9 81       	ldd	r30, Y+1	; 0x01
    131a:	fa 81       	ldd	r31, Y+2	; 0x02
    131c:	8f ef       	ldi	r24, 0xFF	; 255
    131e:	9f ef       	ldi	r25, 0xFF	; 255
    1320:	94 83       	std	Z+4, r25	; 0x04
    1322:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1324:	89 81       	ldd	r24, Y+1	; 0x01
    1326:	9a 81       	ldd	r25, Y+2	; 0x02
    1328:	03 96       	adiw	r24, 0x03	; 3
    132a:	e9 81       	ldd	r30, Y+1	; 0x01
    132c:	fa 81       	ldd	r31, Y+2	; 0x02
    132e:	96 83       	std	Z+6, r25	; 0x06
    1330:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1332:	89 81       	ldd	r24, Y+1	; 0x01
    1334:	9a 81       	ldd	r25, Y+2	; 0x02
    1336:	03 96       	adiw	r24, 0x03	; 3
    1338:	e9 81       	ldd	r30, Y+1	; 0x01
    133a:	fa 81       	ldd	r31, Y+2	; 0x02
    133c:	90 87       	std	Z+8, r25	; 0x08
    133e:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1340:	e9 81       	ldd	r30, Y+1	; 0x01
    1342:	fa 81       	ldd	r31, Y+2	; 0x02
    1344:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    1346:	0f 90       	pop	r0
    1348:	0f 90       	pop	r0
    134a:	cf 91       	pop	r28
    134c:	df 91       	pop	r29
    134e:	08 95       	ret

00001350 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    1350:	df 93       	push	r29
    1352:	cf 93       	push	r28
    1354:	00 d0       	rcall	.+0      	; 0x1356 <vListInitialiseItem+0x6>
    1356:	cd b7       	in	r28, 0x3d	; 61
    1358:	de b7       	in	r29, 0x3e	; 62
    135a:	9a 83       	std	Y+2, r25	; 0x02
    135c:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    135e:	e9 81       	ldd	r30, Y+1	; 0x01
    1360:	fa 81       	ldd	r31, Y+2	; 0x02
    1362:	11 86       	std	Z+9, r1	; 0x09
    1364:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    1366:	0f 90       	pop	r0
    1368:	0f 90       	pop	r0
    136a:	cf 91       	pop	r28
    136c:	df 91       	pop	r29
    136e:	08 95       	ret

00001370 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1370:	df 93       	push	r29
    1372:	cf 93       	push	r28
    1374:	00 d0       	rcall	.+0      	; 0x1376 <vListInsertEnd+0x6>
    1376:	00 d0       	rcall	.+0      	; 0x1378 <vListInsertEnd+0x8>
    1378:	00 d0       	rcall	.+0      	; 0x137a <vListInsertEnd+0xa>
    137a:	cd b7       	in	r28, 0x3d	; 61
    137c:	de b7       	in	r29, 0x3e	; 62
    137e:	9c 83       	std	Y+4, r25	; 0x04
    1380:	8b 83       	std	Y+3, r24	; 0x03
    1382:	7e 83       	std	Y+6, r23	; 0x06
    1384:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    1386:	eb 81       	ldd	r30, Y+3	; 0x03
    1388:	fc 81       	ldd	r31, Y+4	; 0x04
    138a:	81 81       	ldd	r24, Z+1	; 0x01
    138c:	92 81       	ldd	r25, Z+2	; 0x02
    138e:	9a 83       	std	Y+2, r25	; 0x02
    1390:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1392:	ed 81       	ldd	r30, Y+5	; 0x05
    1394:	fe 81       	ldd	r31, Y+6	; 0x06
    1396:	89 81       	ldd	r24, Y+1	; 0x01
    1398:	9a 81       	ldd	r25, Y+2	; 0x02
    139a:	93 83       	std	Z+3, r25	; 0x03
    139c:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    139e:	e9 81       	ldd	r30, Y+1	; 0x01
    13a0:	fa 81       	ldd	r31, Y+2	; 0x02
    13a2:	84 81       	ldd	r24, Z+4	; 0x04
    13a4:	95 81       	ldd	r25, Z+5	; 0x05
    13a6:	ed 81       	ldd	r30, Y+5	; 0x05
    13a8:	fe 81       	ldd	r31, Y+6	; 0x06
    13aa:	95 83       	std	Z+5, r25	; 0x05
    13ac:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    13ae:	e9 81       	ldd	r30, Y+1	; 0x01
    13b0:	fa 81       	ldd	r31, Y+2	; 0x02
    13b2:	04 80       	ldd	r0, Z+4	; 0x04
    13b4:	f5 81       	ldd	r31, Z+5	; 0x05
    13b6:	e0 2d       	mov	r30, r0
    13b8:	8d 81       	ldd	r24, Y+5	; 0x05
    13ba:	9e 81       	ldd	r25, Y+6	; 0x06
    13bc:	93 83       	std	Z+3, r25	; 0x03
    13be:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    13c0:	e9 81       	ldd	r30, Y+1	; 0x01
    13c2:	fa 81       	ldd	r31, Y+2	; 0x02
    13c4:	8d 81       	ldd	r24, Y+5	; 0x05
    13c6:	9e 81       	ldd	r25, Y+6	; 0x06
    13c8:	95 83       	std	Z+5, r25	; 0x05
    13ca:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    13cc:	ed 81       	ldd	r30, Y+5	; 0x05
    13ce:	fe 81       	ldd	r31, Y+6	; 0x06
    13d0:	8b 81       	ldd	r24, Y+3	; 0x03
    13d2:	9c 81       	ldd	r25, Y+4	; 0x04
    13d4:	91 87       	std	Z+9, r25	; 0x09
    13d6:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    13d8:	eb 81       	ldd	r30, Y+3	; 0x03
    13da:	fc 81       	ldd	r31, Y+4	; 0x04
    13dc:	80 81       	ld	r24, Z
    13de:	8f 5f       	subi	r24, 0xFF	; 255
    13e0:	eb 81       	ldd	r30, Y+3	; 0x03
    13e2:	fc 81       	ldd	r31, Y+4	; 0x04
    13e4:	80 83       	st	Z, r24
}
    13e6:	26 96       	adiw	r28, 0x06	; 6
    13e8:	0f b6       	in	r0, 0x3f	; 63
    13ea:	f8 94       	cli
    13ec:	de bf       	out	0x3e, r29	; 62
    13ee:	0f be       	out	0x3f, r0	; 63
    13f0:	cd bf       	out	0x3d, r28	; 61
    13f2:	cf 91       	pop	r28
    13f4:	df 91       	pop	r29
    13f6:	08 95       	ret

000013f8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    13f8:	df 93       	push	r29
    13fa:	cf 93       	push	r28
    13fc:	cd b7       	in	r28, 0x3d	; 61
    13fe:	de b7       	in	r29, 0x3e	; 62
    1400:	28 97       	sbiw	r28, 0x08	; 8
    1402:	0f b6       	in	r0, 0x3f	; 63
    1404:	f8 94       	cli
    1406:	de bf       	out	0x3e, r29	; 62
    1408:	0f be       	out	0x3f, r0	; 63
    140a:	cd bf       	out	0x3d, r28	; 61
    140c:	9e 83       	std	Y+6, r25	; 0x06
    140e:	8d 83       	std	Y+5, r24	; 0x05
    1410:	78 87       	std	Y+8, r23	; 0x08
    1412:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1414:	ef 81       	ldd	r30, Y+7	; 0x07
    1416:	f8 85       	ldd	r31, Y+8	; 0x08
    1418:	80 81       	ld	r24, Z
    141a:	91 81       	ldd	r25, Z+1	; 0x01
    141c:	9a 83       	std	Y+2, r25	; 0x02
    141e:	89 83       	std	Y+1, r24	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1420:	89 81       	ldd	r24, Y+1	; 0x01
    1422:	9a 81       	ldd	r25, Y+2	; 0x02
    1424:	2f ef       	ldi	r18, 0xFF	; 255
    1426:	8f 3f       	cpi	r24, 0xFF	; 255
    1428:	92 07       	cpc	r25, r18
    142a:	39 f4       	brne	.+14     	; 0x143a <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    142c:	ed 81       	ldd	r30, Y+5	; 0x05
    142e:	fe 81       	ldd	r31, Y+6	; 0x06
    1430:	87 81       	ldd	r24, Z+7	; 0x07
    1432:	90 85       	ldd	r25, Z+8	; 0x08
    1434:	9c 83       	std	Y+4, r25	; 0x04
    1436:	8b 83       	std	Y+3, r24	; 0x03
    1438:	18 c0       	rjmp	.+48     	; 0x146a <vListInsert+0x72>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    143a:	8d 81       	ldd	r24, Y+5	; 0x05
    143c:	9e 81       	ldd	r25, Y+6	; 0x06
    143e:	03 96       	adiw	r24, 0x03	; 3
    1440:	9c 83       	std	Y+4, r25	; 0x04
    1442:	8b 83       	std	Y+3, r24	; 0x03
    1444:	06 c0       	rjmp	.+12     	; 0x1452 <vListInsert+0x5a>
    1446:	eb 81       	ldd	r30, Y+3	; 0x03
    1448:	fc 81       	ldd	r31, Y+4	; 0x04
    144a:	82 81       	ldd	r24, Z+2	; 0x02
    144c:	93 81       	ldd	r25, Z+3	; 0x03
    144e:	9c 83       	std	Y+4, r25	; 0x04
    1450:	8b 83       	std	Y+3, r24	; 0x03
    1452:	eb 81       	ldd	r30, Y+3	; 0x03
    1454:	fc 81       	ldd	r31, Y+4	; 0x04
    1456:	02 80       	ldd	r0, Z+2	; 0x02
    1458:	f3 81       	ldd	r31, Z+3	; 0x03
    145a:	e0 2d       	mov	r30, r0
    145c:	20 81       	ld	r18, Z
    145e:	31 81       	ldd	r19, Z+1	; 0x01
    1460:	89 81       	ldd	r24, Y+1	; 0x01
    1462:	9a 81       	ldd	r25, Y+2	; 0x02
    1464:	82 17       	cp	r24, r18
    1466:	93 07       	cpc	r25, r19
    1468:	70 f7       	brcc	.-36     	; 0x1446 <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    146a:	eb 81       	ldd	r30, Y+3	; 0x03
    146c:	fc 81       	ldd	r31, Y+4	; 0x04
    146e:	82 81       	ldd	r24, Z+2	; 0x02
    1470:	93 81       	ldd	r25, Z+3	; 0x03
    1472:	ef 81       	ldd	r30, Y+7	; 0x07
    1474:	f8 85       	ldd	r31, Y+8	; 0x08
    1476:	93 83       	std	Z+3, r25	; 0x03
    1478:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    147a:	ef 81       	ldd	r30, Y+7	; 0x07
    147c:	f8 85       	ldd	r31, Y+8	; 0x08
    147e:	02 80       	ldd	r0, Z+2	; 0x02
    1480:	f3 81       	ldd	r31, Z+3	; 0x03
    1482:	e0 2d       	mov	r30, r0
    1484:	8f 81       	ldd	r24, Y+7	; 0x07
    1486:	98 85       	ldd	r25, Y+8	; 0x08
    1488:	95 83       	std	Z+5, r25	; 0x05
    148a:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    148c:	ef 81       	ldd	r30, Y+7	; 0x07
    148e:	f8 85       	ldd	r31, Y+8	; 0x08
    1490:	8b 81       	ldd	r24, Y+3	; 0x03
    1492:	9c 81       	ldd	r25, Y+4	; 0x04
    1494:	95 83       	std	Z+5, r25	; 0x05
    1496:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1498:	eb 81       	ldd	r30, Y+3	; 0x03
    149a:	fc 81       	ldd	r31, Y+4	; 0x04
    149c:	8f 81       	ldd	r24, Y+7	; 0x07
    149e:	98 85       	ldd	r25, Y+8	; 0x08
    14a0:	93 83       	std	Z+3, r25	; 0x03
    14a2:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    14a4:	ef 81       	ldd	r30, Y+7	; 0x07
    14a6:	f8 85       	ldd	r31, Y+8	; 0x08
    14a8:	8d 81       	ldd	r24, Y+5	; 0x05
    14aa:	9e 81       	ldd	r25, Y+6	; 0x06
    14ac:	91 87       	std	Z+9, r25	; 0x09
    14ae:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    14b0:	ed 81       	ldd	r30, Y+5	; 0x05
    14b2:	fe 81       	ldd	r31, Y+6	; 0x06
    14b4:	80 81       	ld	r24, Z
    14b6:	8f 5f       	subi	r24, 0xFF	; 255
    14b8:	ed 81       	ldd	r30, Y+5	; 0x05
    14ba:	fe 81       	ldd	r31, Y+6	; 0x06
    14bc:	80 83       	st	Z, r24
}
    14be:	28 96       	adiw	r28, 0x08	; 8
    14c0:	0f b6       	in	r0, 0x3f	; 63
    14c2:	f8 94       	cli
    14c4:	de bf       	out	0x3e, r29	; 62
    14c6:	0f be       	out	0x3f, r0	; 63
    14c8:	cd bf       	out	0x3d, r28	; 61
    14ca:	cf 91       	pop	r28
    14cc:	df 91       	pop	r29
    14ce:	08 95       	ret

000014d0 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    14d0:	df 93       	push	r29
    14d2:	cf 93       	push	r28
    14d4:	00 d0       	rcall	.+0      	; 0x14d6 <uxListRemove+0x6>
    14d6:	00 d0       	rcall	.+0      	; 0x14d8 <uxListRemove+0x8>
    14d8:	cd b7       	in	r28, 0x3d	; 61
    14da:	de b7       	in	r29, 0x3e	; 62
    14dc:	9c 83       	std	Y+4, r25	; 0x04
    14de:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    14e0:	eb 81       	ldd	r30, Y+3	; 0x03
    14e2:	fc 81       	ldd	r31, Y+4	; 0x04
    14e4:	80 85       	ldd	r24, Z+8	; 0x08
    14e6:	91 85       	ldd	r25, Z+9	; 0x09
    14e8:	9a 83       	std	Y+2, r25	; 0x02
    14ea:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    14ec:	eb 81       	ldd	r30, Y+3	; 0x03
    14ee:	fc 81       	ldd	r31, Y+4	; 0x04
    14f0:	a2 81       	ldd	r26, Z+2	; 0x02
    14f2:	b3 81       	ldd	r27, Z+3	; 0x03
    14f4:	eb 81       	ldd	r30, Y+3	; 0x03
    14f6:	fc 81       	ldd	r31, Y+4	; 0x04
    14f8:	84 81       	ldd	r24, Z+4	; 0x04
    14fa:	95 81       	ldd	r25, Z+5	; 0x05
    14fc:	15 96       	adiw	r26, 0x05	; 5
    14fe:	9c 93       	st	X, r25
    1500:	8e 93       	st	-X, r24
    1502:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1504:	eb 81       	ldd	r30, Y+3	; 0x03
    1506:	fc 81       	ldd	r31, Y+4	; 0x04
    1508:	a4 81       	ldd	r26, Z+4	; 0x04
    150a:	b5 81       	ldd	r27, Z+5	; 0x05
    150c:	eb 81       	ldd	r30, Y+3	; 0x03
    150e:	fc 81       	ldd	r31, Y+4	; 0x04
    1510:	82 81       	ldd	r24, Z+2	; 0x02
    1512:	93 81       	ldd	r25, Z+3	; 0x03
    1514:	13 96       	adiw	r26, 0x03	; 3
    1516:	9c 93       	st	X, r25
    1518:	8e 93       	st	-X, r24
    151a:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    151c:	e9 81       	ldd	r30, Y+1	; 0x01
    151e:	fa 81       	ldd	r31, Y+2	; 0x02
    1520:	21 81       	ldd	r18, Z+1	; 0x01
    1522:	32 81       	ldd	r19, Z+2	; 0x02
    1524:	8b 81       	ldd	r24, Y+3	; 0x03
    1526:	9c 81       	ldd	r25, Y+4	; 0x04
    1528:	28 17       	cp	r18, r24
    152a:	39 07       	cpc	r19, r25
    152c:	41 f4       	brne	.+16     	; 0x153e <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    152e:	eb 81       	ldd	r30, Y+3	; 0x03
    1530:	fc 81       	ldd	r31, Y+4	; 0x04
    1532:	84 81       	ldd	r24, Z+4	; 0x04
    1534:	95 81       	ldd	r25, Z+5	; 0x05
    1536:	e9 81       	ldd	r30, Y+1	; 0x01
    1538:	fa 81       	ldd	r31, Y+2	; 0x02
    153a:	92 83       	std	Z+2, r25	; 0x02
    153c:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    153e:	eb 81       	ldd	r30, Y+3	; 0x03
    1540:	fc 81       	ldd	r31, Y+4	; 0x04
    1542:	11 86       	std	Z+9, r1	; 0x09
    1544:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1546:	e9 81       	ldd	r30, Y+1	; 0x01
    1548:	fa 81       	ldd	r31, Y+2	; 0x02
    154a:	80 81       	ld	r24, Z
    154c:	81 50       	subi	r24, 0x01	; 1
    154e:	e9 81       	ldd	r30, Y+1	; 0x01
    1550:	fa 81       	ldd	r31, Y+2	; 0x02
    1552:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    1554:	e9 81       	ldd	r30, Y+1	; 0x01
    1556:	fa 81       	ldd	r31, Y+2	; 0x02
    1558:	80 81       	ld	r24, Z
}
    155a:	0f 90       	pop	r0
    155c:	0f 90       	pop	r0
    155e:	0f 90       	pop	r0
    1560:	0f 90       	pop	r0
    1562:	cf 91       	pop	r28
    1564:	df 91       	pop	r29
    1566:	08 95       	ret

00001568 <PassengerButtonHandler>:
int DriverSeatTemperature;
int PassengerSeatTemperature;


void PassengerButtonHandler(void *pvParameters)
{
    1568:	df 93       	push	r29
    156a:	cf 93       	push	r28
    156c:	cd b7       	in	r28, 0x3d	; 61
    156e:	de b7       	in	r29, 0x3e	; 62
    1570:	28 97       	sbiw	r28, 0x08	; 8
    1572:	0f b6       	in	r0, 0x3f	; 63
    1574:	f8 94       	cli
    1576:	de bf       	out	0x3e, r29	; 62
    1578:	0f be       	out	0x3f, r0	; 63
    157a:	cd bf       	out	0x3d, r28	; 61
    157c:	98 87       	std	Y+8, r25	; 0x08
    157e:	8f 83       	std	Y+7, r24	; 0x07
	TickType_t xLastWakeTime = xTaskGetTickCount();
    1580:	0e 94 c4 27 	call	0x4f88	; 0x4f88 <xTaskGetTickCount>
    1584:	9e 83       	std	Y+6, r25	; 0x06
    1586:	8d 83       	std	Y+5, r24	; 0x05
	static int cnt=0;
	static int DriverButtonState=0;
    while (1)
    {

    	state = GetPassengerButtonState();
    1588:	0e 94 49 0e 	call	0x1c92	; 0x1c92 <GetPassengerButtonState>
    158c:	9c 83       	std	Y+4, r25	; 0x04
    158e:	8b 83       	std	Y+3, r24	; 0x03
		if(state != DriverButtonState){
    1590:	20 91 7a 07 	lds	r18, 0x077A
    1594:	30 91 7b 07 	lds	r19, 0x077B
    1598:	8b 81       	ldd	r24, Y+3	; 0x03
    159a:	9c 81       	ldd	r25, Y+4	; 0x04
    159c:	82 17       	cp	r24, r18
    159e:	93 07       	cpc	r25, r19
    15a0:	09 f4       	brne	.+2      	; 0x15a4 <PassengerButtonHandler+0x3c>
    15a2:	62 c0       	rjmp	.+196    	; 0x1668 <PassengerButtonHandler+0x100>
			DriverButtonState = state;
    15a4:	8b 81       	ldd	r24, Y+3	; 0x03
    15a6:	9c 81       	ldd	r25, Y+4	; 0x04
    15a8:	90 93 7b 07 	sts	0x077B, r25
    15ac:	80 93 7a 07 	sts	0x077A, r24
			if(DriverButtonState){
    15b0:	80 91 7a 07 	lds	r24, 0x077A
    15b4:	90 91 7b 07 	lds	r25, 0x077B
    15b8:	00 97       	sbiw	r24, 0x00	; 0
    15ba:	09 f4       	brne	.+2      	; 0x15be <PassengerButtonHandler+0x56>
    15bc:	55 c0       	rjmp	.+170    	; 0x1668 <PassengerButtonHandler+0x100>
				cnt++;
    15be:	80 91 7c 07 	lds	r24, 0x077C
    15c2:	90 91 7d 07 	lds	r25, 0x077D
    15c6:	01 96       	adiw	r24, 0x01	; 1
    15c8:	90 93 7d 07 	sts	0x077D, r25
    15cc:	80 93 7c 07 	sts	0x077C, r24
				cnt %= 4;
    15d0:	80 91 7c 07 	lds	r24, 0x077C
    15d4:	90 91 7d 07 	lds	r25, 0x077D
    15d8:	24 e0       	ldi	r18, 0x04	; 4
    15da:	30 e0       	ldi	r19, 0x00	; 0
    15dc:	b9 01       	movw	r22, r18
    15de:	0e 94 2f 32 	call	0x645e	; 0x645e <__divmodhi4>
    15e2:	90 93 7d 07 	sts	0x077D, r25
    15e6:	80 93 7c 07 	sts	0x077C, r24

				EventBits_t uxBits;
				uxBits = xEventGroupClearBits(
    15ea:	80 91 78 07 	lds	r24, 0x0778
    15ee:	90 91 79 07 	lds	r25, 0x0779
    15f2:	6f ef       	ldi	r22, 0xFF	; 255
    15f4:	70 e0       	ldi	r23, 0x00	; 0
    15f6:	0e 94 5b 07 	call	0xeb6	; 0xeb6 <xEventGroupClearBits>
    15fa:	9a 83       	std	Y+2, r25	; 0x02
    15fc:	89 83       	std	Y+1, r24	; 0x01
						xEventGroup,  /* The event group being updated. */
								0xff ); /* The bits being cleared. */

				PassengerGreenLED_Off();
    15fe:	0e 94 15 10 	call	0x202a	; 0x202a <PassengerGreenLED_Off>
				PassengerYellowLED_Off();
    1602:	0e 94 dd 0f 	call	0x1fba	; 0x1fba <PassengerYellowLED_Off>
				PassengerBlueLED_Off();
    1606:	0e 94 f9 0f 	call	0x1ff2	; 0x1ff2 <PassengerBlueLED_Off>

				if(cnt==1)	xEventGroupSetBits(xEventGroup, PASSENGER_EVENT_BIT_BUTTON_PRESSED_LOW);
    160a:	80 91 7c 07 	lds	r24, 0x077C
    160e:	90 91 7d 07 	lds	r25, 0x077D
    1612:	81 30       	cpi	r24, 0x01	; 1
    1614:	91 05       	cpc	r25, r1
    1616:	49 f4       	brne	.+18     	; 0x162a <PassengerButtonHandler+0xc2>
    1618:	80 91 78 07 	lds	r24, 0x0778
    161c:	90 91 79 07 	lds	r25, 0x0779
    1620:	60 e2       	ldi	r22, 0x20	; 32
    1622:	70 e0       	ldi	r23, 0x00	; 0
    1624:	0e 94 b3 07 	call	0xf66	; 0xf66 <xEventGroupSetBits>
    1628:	1f c0       	rjmp	.+62     	; 0x1668 <PassengerButtonHandler+0x100>
				else if(cnt==2) xEventGroupSetBits(xEventGroup, PASSENGER_EVENT_BIT_BUTTON_PRESSED_MEDIUM);
    162a:	80 91 7c 07 	lds	r24, 0x077C
    162e:	90 91 7d 07 	lds	r25, 0x077D
    1632:	82 30       	cpi	r24, 0x02	; 2
    1634:	91 05       	cpc	r25, r1
    1636:	49 f4       	brne	.+18     	; 0x164a <PassengerButtonHandler+0xe2>
    1638:	80 91 78 07 	lds	r24, 0x0778
    163c:	90 91 79 07 	lds	r25, 0x0779
    1640:	60 e4       	ldi	r22, 0x40	; 64
    1642:	70 e0       	ldi	r23, 0x00	; 0
    1644:	0e 94 b3 07 	call	0xf66	; 0xf66 <xEventGroupSetBits>
    1648:	0f c0       	rjmp	.+30     	; 0x1668 <PassengerButtonHandler+0x100>
				else if(cnt==3)	xEventGroupSetBits(xEventGroup, PASSENGER_EVENT_BIT_BUTTON_PRESSED_HIGHT);
    164a:	80 91 7c 07 	lds	r24, 0x077C
    164e:	90 91 7d 07 	lds	r25, 0x077D
    1652:	83 30       	cpi	r24, 0x03	; 3
    1654:	91 05       	cpc	r25, r1
    1656:	41 f4       	brne	.+16     	; 0x1668 <PassengerButtonHandler+0x100>
    1658:	80 91 78 07 	lds	r24, 0x0778
    165c:	90 91 79 07 	lds	r25, 0x0779
    1660:	60 e8       	ldi	r22, 0x80	; 128
    1662:	70 e0       	ldi	r23, 0x00	; 0
    1664:	0e 94 b3 07 	call	0xf66	; 0xf66 <xEventGroupSetBits>
			}
		}
		vTaskDelayUntil(&xLastWakeTime, (100/portTICK_PERIOD_MS));
    1668:	ce 01       	movw	r24, r28
    166a:	05 96       	adiw	r24, 0x05	; 5
    166c:	64 e6       	ldi	r22, 0x64	; 100
    166e:	70 e0       	ldi	r23, 0x00	; 0
    1670:	0e 94 e6 24 	call	0x49cc	; 0x49cc <vTaskDelayUntil>
    1674:	89 cf       	rjmp	.-238    	; 0x1588 <PassengerButtonHandler+0x20>

00001676 <DriverButtonHandle>:
    }
}
void DriverButtonHandle(void *pvParameters){
    1676:	df 93       	push	r29
    1678:	cf 93       	push	r28
    167a:	cd b7       	in	r28, 0x3d	; 61
    167c:	de b7       	in	r29, 0x3e	; 62
    167e:	28 97       	sbiw	r28, 0x08	; 8
    1680:	0f b6       	in	r0, 0x3f	; 63
    1682:	f8 94       	cli
    1684:	de bf       	out	0x3e, r29	; 62
    1686:	0f be       	out	0x3f, r0	; 63
    1688:	cd bf       	out	0x3d, r28	; 61
    168a:	98 87       	std	Y+8, r25	; 0x08
    168c:	8f 83       	std	Y+7, r24	; 0x07
    TickType_t xLastWakeTime = xTaskGetTickCount();
    168e:	0e 94 c4 27 	call	0x4f88	; 0x4f88 <xTaskGetTickCount>
    1692:	9e 83       	std	Y+6, r25	; 0x06
    1694:	8d 83       	std	Y+5, r24	; 0x05
    int state;
    static int cnt=0;
    static int DriverButtonState=0;
    for(;;){
        state = GetDriverButtonState();
    1696:	0e 94 2e 0e 	call	0x1c5c	; 0x1c5c <GetDriverButtonState>
    169a:	9c 83       	std	Y+4, r25	; 0x04
    169c:	8b 83       	std	Y+3, r24	; 0x03
        if(state != DriverButtonState){
    169e:	20 91 7e 07 	lds	r18, 0x077E
    16a2:	30 91 7f 07 	lds	r19, 0x077F
    16a6:	8b 81       	ldd	r24, Y+3	; 0x03
    16a8:	9c 81       	ldd	r25, Y+4	; 0x04
    16aa:	82 17       	cp	r24, r18
    16ac:	93 07       	cpc	r25, r19
    16ae:	09 f4       	brne	.+2      	; 0x16b2 <DriverButtonHandle+0x3c>
    16b0:	62 c0       	rjmp	.+196    	; 0x1776 <DriverButtonHandle+0x100>
            DriverButtonState = state;
    16b2:	8b 81       	ldd	r24, Y+3	; 0x03
    16b4:	9c 81       	ldd	r25, Y+4	; 0x04
    16b6:	90 93 7f 07 	sts	0x077F, r25
    16ba:	80 93 7e 07 	sts	0x077E, r24
            if(DriverButtonState){
    16be:	80 91 7e 07 	lds	r24, 0x077E
    16c2:	90 91 7f 07 	lds	r25, 0x077F
    16c6:	00 97       	sbiw	r24, 0x00	; 0
    16c8:	09 f4       	brne	.+2      	; 0x16cc <DriverButtonHandle+0x56>
    16ca:	55 c0       	rjmp	.+170    	; 0x1776 <DriverButtonHandle+0x100>
                cnt++;
    16cc:	80 91 80 07 	lds	r24, 0x0780
    16d0:	90 91 81 07 	lds	r25, 0x0781
    16d4:	01 96       	adiw	r24, 0x01	; 1
    16d6:	90 93 81 07 	sts	0x0781, r25
    16da:	80 93 80 07 	sts	0x0780, r24
                cnt %= 4;
    16de:	80 91 80 07 	lds	r24, 0x0780
    16e2:	90 91 81 07 	lds	r25, 0x0781
    16e6:	24 e0       	ldi	r18, 0x04	; 4
    16e8:	30 e0       	ldi	r19, 0x00	; 0
    16ea:	b9 01       	movw	r22, r18
    16ec:	0e 94 2f 32 	call	0x645e	; 0x645e <__divmodhi4>
    16f0:	90 93 81 07 	sts	0x0781, r25
    16f4:	80 93 80 07 	sts	0x0780, r24
                EventBits_t uxBits;
                uxBits = xEventGroupClearBits(
    16f8:	80 91 78 07 	lds	r24, 0x0778
    16fc:	90 91 79 07 	lds	r25, 0x0779
    1700:	6f ef       	ldi	r22, 0xFF	; 255
    1702:	70 e0       	ldi	r23, 0x00	; 0
    1704:	0e 94 5b 07 	call	0xeb6	; 0xeb6 <xEventGroupClearBits>
    1708:	9a 83       	std	Y+2, r25	; 0x02
    170a:	89 83       	std	Y+1, r24	; 0x01
                		xEventGroup,  /* The event group being updated. */
                                0xff ); /* The bits being cleared. */
                DriverGreenLED_Off();
    170c:	0e 94 52 0f 	call	0x1ea4	; 0x1ea4 <DriverGreenLED_Off>
                DriverYellowLED_Off();
    1710:	0e 94 1a 0f 	call	0x1e34	; 0x1e34 <DriverYellowLED_Off>
                DriverBlueLED_Off();
    1714:	0e 94 36 0f 	call	0x1e6c	; 0x1e6c <DriverBlueLED_Off>

                if(cnt==1)	xEventGroupSetBits(xEventGroup, DRIVER_EVENT_BIT_BUTTON_PRESSED_LOW);
    1718:	80 91 80 07 	lds	r24, 0x0780
    171c:	90 91 81 07 	lds	r25, 0x0781
    1720:	81 30       	cpi	r24, 0x01	; 1
    1722:	91 05       	cpc	r25, r1
    1724:	49 f4       	brne	.+18     	; 0x1738 <DriverButtonHandle+0xc2>
    1726:	80 91 78 07 	lds	r24, 0x0778
    172a:	90 91 79 07 	lds	r25, 0x0779
    172e:	62 e0       	ldi	r22, 0x02	; 2
    1730:	70 e0       	ldi	r23, 0x00	; 0
    1732:	0e 94 b3 07 	call	0xf66	; 0xf66 <xEventGroupSetBits>
    1736:	1f c0       	rjmp	.+62     	; 0x1776 <DriverButtonHandle+0x100>
                else if(cnt==2)	xEventGroupSetBits(xEventGroup, DRIVER_EVENT_BIT_BUTTON_PRESSED_MEDIUM);
    1738:	80 91 80 07 	lds	r24, 0x0780
    173c:	90 91 81 07 	lds	r25, 0x0781
    1740:	82 30       	cpi	r24, 0x02	; 2
    1742:	91 05       	cpc	r25, r1
    1744:	49 f4       	brne	.+18     	; 0x1758 <DriverButtonHandle+0xe2>
    1746:	80 91 78 07 	lds	r24, 0x0778
    174a:	90 91 79 07 	lds	r25, 0x0779
    174e:	64 e0       	ldi	r22, 0x04	; 4
    1750:	70 e0       	ldi	r23, 0x00	; 0
    1752:	0e 94 b3 07 	call	0xf66	; 0xf66 <xEventGroupSetBits>
    1756:	0f c0       	rjmp	.+30     	; 0x1776 <DriverButtonHandle+0x100>
                else if(cnt==3)	xEventGroupSetBits(xEventGroup, DRIVER_EVENT_BIT_BUTTON_PRESSED_HIGHT);
    1758:	80 91 80 07 	lds	r24, 0x0780
    175c:	90 91 81 07 	lds	r25, 0x0781
    1760:	83 30       	cpi	r24, 0x03	; 3
    1762:	91 05       	cpc	r25, r1
    1764:	41 f4       	brne	.+16     	; 0x1776 <DriverButtonHandle+0x100>
    1766:	80 91 78 07 	lds	r24, 0x0778
    176a:	90 91 79 07 	lds	r25, 0x0779
    176e:	68 e0       	ldi	r22, 0x08	; 8
    1770:	70 e0       	ldi	r23, 0x00	; 0
    1772:	0e 94 b3 07 	call	0xf66	; 0xf66 <xEventGroupSetBits>
            }
        }
        vTaskDelayUntil(&xLastWakeTime, (100/portTICK_PERIOD_MS));
    1776:	ce 01       	movw	r24, r28
    1778:	05 96       	adiw	r24, 0x05	; 5
    177a:	64 e6       	ldi	r22, 0x64	; 100
    177c:	70 e0       	ldi	r23, 0x00	; 0
    177e:	0e 94 e6 24 	call	0x49cc	; 0x49cc <vTaskDelayUntil>
    1782:	89 cf       	rjmp	.-238    	; 0x1696 <DriverButtonHandle+0x20>

00001784 <Temperature_Task>:
    }
}
void Temperature_Task(void *pvParameters){
    1784:	df 93       	push	r29
    1786:	cf 93       	push	r28
    1788:	00 d0       	rcall	.+0      	; 0x178a <Temperature_Task+0x6>
    178a:	00 d0       	rcall	.+0      	; 0x178c <Temperature_Task+0x8>
    178c:	cd b7       	in	r28, 0x3d	; 61
    178e:	de b7       	in	r29, 0x3e	; 62
    1790:	9c 83       	std	Y+4, r25	; 0x04
    1792:	8b 83       	std	Y+3, r24	; 0x03
	TickType_t xLastWakeTime = xTaskGetTickCount();
    1794:	0e 94 c4 27 	call	0x4f88	; 0x4f88 <xTaskGetTickCount>
    1798:	9a 83       	std	Y+2, r25	; 0x02
    179a:	89 83       	std	Y+1, r24	; 0x01
	for(;;){
		DriverSeatTemperature=LM35_getTemperature(SENSOR_DRIVER_CHANNEL_ID);
    179c:	81 e0       	ldi	r24, 0x01	; 1
    179e:	0e 94 9e 0e 	call	0x1d3c	; 0x1d3c <LM35_getTemperature>
    17a2:	88 2f       	mov	r24, r24
    17a4:	90 e0       	ldi	r25, 0x00	; 0
    17a6:	90 93 21 08 	sts	0x0821, r25
    17aa:	80 93 20 08 	sts	0x0820, r24
		if(DriverSeatTemperature<5 || DriverSeatTemperature>40){
    17ae:	80 91 20 08 	lds	r24, 0x0820
    17b2:	90 91 21 08 	lds	r25, 0x0821
    17b6:	85 30       	cpi	r24, 0x05	; 5
    17b8:	91 05       	cpc	r25, r1
    17ba:	3c f0       	brlt	.+14     	; 0x17ca <Temperature_Task+0x46>
    17bc:	80 91 20 08 	lds	r24, 0x0820
    17c0:	90 91 21 08 	lds	r25, 0x0821
    17c4:	89 32       	cpi	r24, 0x29	; 41
    17c6:	91 05       	cpc	r25, r1
    17c8:	34 f0       	brlt	.+12     	; 0x17d6 <Temperature_Task+0x52>
			UART_sendChar('a');
    17ca:	81 e6       	ldi	r24, 0x61	; 97
    17cc:	0e 94 9b 0f 	call	0x1f36	; 0x1f36 <UART_sendChar>
			RedLED_On();
    17d0:	0e 94 60 0f 	call	0x1ec0	; 0x1ec0 <RedLED_On>
    17d4:	02 c0       	rjmp	.+4      	; 0x17da <Temperature_Task+0x56>
		}else {
			RedLED_Off();
    17d6:	0e 94 6e 0f 	call	0x1edc	; 0x1edc <RedLED_Off>
		}
		PassengerSeatTemperature =LM35_getTemperature(SENSOR_PASSENGER_CHANNEL_ID);
    17da:	82 e0       	ldi	r24, 0x02	; 2
    17dc:	0e 94 9e 0e 	call	0x1d3c	; 0x1d3c <LM35_getTemperature>
    17e0:	88 2f       	mov	r24, r24
    17e2:	90 e0       	ldi	r25, 0x00	; 0
    17e4:	90 93 23 08 	sts	0x0823, r25
    17e8:	80 93 22 08 	sts	0x0822, r24
		if(PassengerSeatTemperature<5 || PassengerSeatTemperature>40){
    17ec:	80 91 22 08 	lds	r24, 0x0822
    17f0:	90 91 23 08 	lds	r25, 0x0823
    17f4:	85 30       	cpi	r24, 0x05	; 5
    17f6:	91 05       	cpc	r25, r1
    17f8:	3c f0       	brlt	.+14     	; 0x1808 <Temperature_Task+0x84>
    17fa:	80 91 22 08 	lds	r24, 0x0822
    17fe:	90 91 23 08 	lds	r25, 0x0823
    1802:	89 32       	cpi	r24, 0x29	; 41
    1804:	91 05       	cpc	r25, r1
    1806:	34 f0       	brlt	.+12     	; 0x1814 <Temperature_Task+0x90>
			UART_sendChar('a');
    1808:	81 e6       	ldi	r24, 0x61	; 97
    180a:	0e 94 9b 0f 	call	0x1f36	; 0x1f36 <UART_sendChar>
			RedLED_On();
    180e:	0e 94 60 0f 	call	0x1ec0	; 0x1ec0 <RedLED_On>
    1812:	02 c0       	rjmp	.+4      	; 0x1818 <Temperature_Task+0x94>
		}else {
			RedLED_Off();
    1814:	0e 94 6e 0f 	call	0x1edc	; 0x1edc <RedLED_Off>
		}

		vTaskDelayUntil(&xLastWakeTime, (100/portTICK_PERIOD_MS));
    1818:	ce 01       	movw	r24, r28
    181a:	01 96       	adiw	r24, 0x01	; 1
    181c:	64 e6       	ldi	r22, 0x64	; 100
    181e:	70 e0       	ldi	r23, 0x00	; 0
    1820:	0e 94 e6 24 	call	0x49cc	; 0x49cc <vTaskDelayUntil>
    1824:	bb cf       	rjmp	.-138    	; 0x179c <Temperature_Task+0x18>

00001826 <Heating_level_LOW>:
	}
}

void Heating_level_LOW(void *pvParameters){
    1826:	0f 93       	push	r16
    1828:	1f 93       	push	r17
    182a:	df 93       	push	r29
    182c:	cf 93       	push	r28
    182e:	00 d0       	rcall	.+0      	; 0x1830 <Heating_level_LOW+0xa>
    1830:	00 d0       	rcall	.+0      	; 0x1832 <Heating_level_LOW+0xc>
    1832:	cd b7       	in	r28, 0x3d	; 61
    1834:	de b7       	in	r29, 0x3e	; 62
    1836:	9c 83       	std	Y+4, r25	; 0x04
    1838:	8b 83       	std	Y+3, r24	; 0x03
    EventBits_t uxBits;
	for(;;){
		uxBits = xEventGroupWaitBits(
    183a:	80 91 78 07 	lds	r24, 0x0778
    183e:	90 91 79 07 	lds	r25, 0x0779
    1842:	62 e2       	ldi	r22, 0x22	; 34
    1844:	70 e0       	ldi	r23, 0x00	; 0
    1846:	41 e0       	ldi	r20, 0x01	; 1
    1848:	20 e0       	ldi	r18, 0x00	; 0
    184a:	0f ef       	ldi	r16, 0xFF	; 255
    184c:	1f ef       	ldi	r17, 0xFF	; 255
    184e:	0e 94 95 06 	call	0xd2a	; 0xd2a <xEventGroupWaitBits>
    1852:	9a 83       	std	Y+2, r25	; 0x02
    1854:	89 83       	std	Y+1, r24	; 0x01
		                    xEventGroup,
							DRIVER_EVENT_BIT_BUTTON_PRESSED_LOW|PASSENGER_EVENT_BIT_BUTTON_PRESSED_LOW,
							pdTRUE,               // Clear the bits before returning.
		                    pdFALSE,
		                    portMAX_DELAY );
		if((uxBits & DRIVER_EVENT_BIT_BUTTON_PRESSED_LOW) && LOW_DESIRED_TEMP - DriverSeatTemperature >= 2){
    1856:	89 81       	ldd	r24, Y+1	; 0x01
    1858:	9a 81       	ldd	r25, Y+2	; 0x02
    185a:	82 70       	andi	r24, 0x02	; 2
    185c:	90 70       	andi	r25, 0x00	; 0
    185e:	00 97       	sbiw	r24, 0x00	; 0
    1860:	79 f1       	breq	.+94     	; 0x18c0 <Heating_level_LOW+0x9a>
    1862:	80 91 20 08 	lds	r24, 0x0820
    1866:	90 91 21 08 	lds	r25, 0x0821
    186a:	29 e1       	ldi	r18, 0x19	; 25
    186c:	30 e0       	ldi	r19, 0x00	; 0
    186e:	a9 01       	movw	r20, r18
    1870:	48 1b       	sub	r20, r24
    1872:	59 0b       	sbc	r21, r25
    1874:	ca 01       	movw	r24, r20
    1876:	82 30       	cpi	r24, 0x02	; 2
    1878:	91 05       	cpc	r25, r1
    187a:	14 f1       	brlt	.+68     	; 0x18c0 <Heating_level_LOW+0x9a>
			if(LOW_DESIRED_TEMP - DriverSeatTemperature<5)
    187c:	80 91 20 08 	lds	r24, 0x0820
    1880:	90 91 21 08 	lds	r25, 0x0821
    1884:	29 e1       	ldi	r18, 0x19	; 25
    1886:	30 e0       	ldi	r19, 0x00	; 0
    1888:	a9 01       	movw	r20, r18
    188a:	48 1b       	sub	r20, r24
    188c:	59 0b       	sbc	r21, r25
    188e:	ca 01       	movw	r24, r20
    1890:	85 30       	cpi	r24, 0x05	; 5
    1892:	91 05       	cpc	r25, r1
    1894:	1c f4       	brge	.+6      	; 0x189c <Heating_level_LOW+0x76>
				DriverYellowLED_On();
    1896:	0e 94 0c 0f 	call	0x1e18	; 0x1e18 <DriverYellowLED_On>
    189a:	12 c0       	rjmp	.+36     	; 0x18c0 <Heating_level_LOW+0x9a>
			else if(LOW_DESIRED_TEMP - DriverSeatTemperature<10)
    189c:	80 91 20 08 	lds	r24, 0x0820
    18a0:	90 91 21 08 	lds	r25, 0x0821
    18a4:	29 e1       	ldi	r18, 0x19	; 25
    18a6:	30 e0       	ldi	r19, 0x00	; 0
    18a8:	a9 01       	movw	r20, r18
    18aa:	48 1b       	sub	r20, r24
    18ac:	59 0b       	sbc	r21, r25
    18ae:	ca 01       	movw	r24, r20
    18b0:	8a 30       	cpi	r24, 0x0A	; 10
    18b2:	91 05       	cpc	r25, r1
    18b4:	1c f4       	brge	.+6      	; 0x18bc <Heating_level_LOW+0x96>
				DriverBlueLED_On();
    18b6:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <DriverBlueLED_On>
    18ba:	02 c0       	rjmp	.+4      	; 0x18c0 <Heating_level_LOW+0x9a>
			else
				DriverGreenLED_On();
    18bc:	0e 94 44 0f 	call	0x1e88	; 0x1e88 <DriverGreenLED_On>
		}
		if((uxBits & PASSENGER_EVENT_BIT_BUTTON_PRESSED_LOW) && LOW_DESIRED_TEMP - PassengerSeatTemperature >= 2){
    18c0:	89 81       	ldd	r24, Y+1	; 0x01
    18c2:	9a 81       	ldd	r25, Y+2	; 0x02
    18c4:	80 72       	andi	r24, 0x20	; 32
    18c6:	90 70       	andi	r25, 0x00	; 0
    18c8:	00 97       	sbiw	r24, 0x00	; 0
    18ca:	09 f4       	brne	.+2      	; 0x18ce <Heating_level_LOW+0xa8>
    18cc:	b6 cf       	rjmp	.-148    	; 0x183a <Heating_level_LOW+0x14>
    18ce:	80 91 22 08 	lds	r24, 0x0822
    18d2:	90 91 23 08 	lds	r25, 0x0823
    18d6:	29 e1       	ldi	r18, 0x19	; 25
    18d8:	30 e0       	ldi	r19, 0x00	; 0
    18da:	a9 01       	movw	r20, r18
    18dc:	48 1b       	sub	r20, r24
    18de:	59 0b       	sbc	r21, r25
    18e0:	ca 01       	movw	r24, r20
    18e2:	82 30       	cpi	r24, 0x02	; 2
    18e4:	91 05       	cpc	r25, r1
    18e6:	0c f4       	brge	.+2      	; 0x18ea <Heating_level_LOW+0xc4>
    18e8:	a8 cf       	rjmp	.-176    	; 0x183a <Heating_level_LOW+0x14>
			if(LOW_DESIRED_TEMP - PassengerSeatTemperature<5)
    18ea:	80 91 22 08 	lds	r24, 0x0822
    18ee:	90 91 23 08 	lds	r25, 0x0823
    18f2:	29 e1       	ldi	r18, 0x19	; 25
    18f4:	30 e0       	ldi	r19, 0x00	; 0
    18f6:	a9 01       	movw	r20, r18
    18f8:	48 1b       	sub	r20, r24
    18fa:	59 0b       	sbc	r21, r25
    18fc:	ca 01       	movw	r24, r20
    18fe:	85 30       	cpi	r24, 0x05	; 5
    1900:	91 05       	cpc	r25, r1
    1902:	1c f4       	brge	.+6      	; 0x190a <Heating_level_LOW+0xe4>
				PassengerYellowLED_On();
    1904:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <PassengerYellowLED_On>
    1908:	98 cf       	rjmp	.-208    	; 0x183a <Heating_level_LOW+0x14>
			else if(LOW_DESIRED_TEMP - PassengerSeatTemperature<10)
    190a:	80 91 22 08 	lds	r24, 0x0822
    190e:	90 91 23 08 	lds	r25, 0x0823
    1912:	29 e1       	ldi	r18, 0x19	; 25
    1914:	30 e0       	ldi	r19, 0x00	; 0
    1916:	a9 01       	movw	r20, r18
    1918:	48 1b       	sub	r20, r24
    191a:	59 0b       	sbc	r21, r25
    191c:	ca 01       	movw	r24, r20
    191e:	8a 30       	cpi	r24, 0x0A	; 10
    1920:	91 05       	cpc	r25, r1
    1922:	1c f4       	brge	.+6      	; 0x192a <Heating_level_LOW+0x104>
				PassengerBlueLED_On();
    1924:	0e 94 eb 0f 	call	0x1fd6	; 0x1fd6 <PassengerBlueLED_On>
    1928:	88 cf       	rjmp	.-240    	; 0x183a <Heating_level_LOW+0x14>
			else
				PassengerGreenLED_On();
    192a:	0e 94 07 10 	call	0x200e	; 0x200e <PassengerGreenLED_On>
    192e:	85 cf       	rjmp	.-246    	; 0x183a <Heating_level_LOW+0x14>

00001930 <Heating_level_MEDUIM>:

		}
	}
}
void Heating_level_MEDUIM(void *pvParameters){
    1930:	0f 93       	push	r16
    1932:	1f 93       	push	r17
    1934:	df 93       	push	r29
    1936:	cf 93       	push	r28
    1938:	00 d0       	rcall	.+0      	; 0x193a <Heating_level_MEDUIM+0xa>
    193a:	00 d0       	rcall	.+0      	; 0x193c <Heating_level_MEDUIM+0xc>
    193c:	cd b7       	in	r28, 0x3d	; 61
    193e:	de b7       	in	r29, 0x3e	; 62
    1940:	9c 83       	std	Y+4, r25	; 0x04
    1942:	8b 83       	std	Y+3, r24	; 0x03
    EventBits_t uxBits;
	for(;;){
		uxBits = xEventGroupWaitBits(
    1944:	80 91 78 07 	lds	r24, 0x0778
    1948:	90 91 79 07 	lds	r25, 0x0779
    194c:	64 e4       	ldi	r22, 0x44	; 68
    194e:	70 e0       	ldi	r23, 0x00	; 0
    1950:	41 e0       	ldi	r20, 0x01	; 1
    1952:	20 e0       	ldi	r18, 0x00	; 0
    1954:	0f ef       	ldi	r16, 0xFF	; 255
    1956:	1f ef       	ldi	r17, 0xFF	; 255
    1958:	0e 94 95 06 	call	0xd2a	; 0xd2a <xEventGroupWaitBits>
    195c:	9a 83       	std	Y+2, r25	; 0x02
    195e:	89 83       	std	Y+1, r24	; 0x01
		                    xEventGroup,
							DRIVER_EVENT_BIT_BUTTON_PRESSED_MEDIUM | PASSENGER_EVENT_BIT_BUTTON_PRESSED_MEDIUM,
							pdTRUE,               // Clear the bits before returning.
		                    pdFALSE,
		                    portMAX_DELAY );
		if((uxBits & DRIVER_EVENT_BIT_BUTTON_PRESSED_MEDIUM) && MEDIUM_DESIRED_TEMP - DriverSeatTemperature >= 2){
    1960:	89 81       	ldd	r24, Y+1	; 0x01
    1962:	9a 81       	ldd	r25, Y+2	; 0x02
    1964:	84 70       	andi	r24, 0x04	; 4
    1966:	90 70       	andi	r25, 0x00	; 0
    1968:	00 97       	sbiw	r24, 0x00	; 0
    196a:	79 f1       	breq	.+94     	; 0x19ca <Heating_level_MEDUIM+0x9a>
    196c:	80 91 20 08 	lds	r24, 0x0820
    1970:	90 91 21 08 	lds	r25, 0x0821
    1974:	2e e1       	ldi	r18, 0x1E	; 30
    1976:	30 e0       	ldi	r19, 0x00	; 0
    1978:	a9 01       	movw	r20, r18
    197a:	48 1b       	sub	r20, r24
    197c:	59 0b       	sbc	r21, r25
    197e:	ca 01       	movw	r24, r20
    1980:	82 30       	cpi	r24, 0x02	; 2
    1982:	91 05       	cpc	r25, r1
    1984:	14 f1       	brlt	.+68     	; 0x19ca <Heating_level_MEDUIM+0x9a>
			if(MEDIUM_DESIRED_TEMP - DriverSeatTemperature<5)
    1986:	80 91 20 08 	lds	r24, 0x0820
    198a:	90 91 21 08 	lds	r25, 0x0821
    198e:	2e e1       	ldi	r18, 0x1E	; 30
    1990:	30 e0       	ldi	r19, 0x00	; 0
    1992:	a9 01       	movw	r20, r18
    1994:	48 1b       	sub	r20, r24
    1996:	59 0b       	sbc	r21, r25
    1998:	ca 01       	movw	r24, r20
    199a:	85 30       	cpi	r24, 0x05	; 5
    199c:	91 05       	cpc	r25, r1
    199e:	1c f4       	brge	.+6      	; 0x19a6 <Heating_level_MEDUIM+0x76>
				DriverYellowLED_On();
    19a0:	0e 94 0c 0f 	call	0x1e18	; 0x1e18 <DriverYellowLED_On>
    19a4:	12 c0       	rjmp	.+36     	; 0x19ca <Heating_level_MEDUIM+0x9a>
			else if(MEDIUM_DESIRED_TEMP - DriverSeatTemperature<10)
    19a6:	80 91 20 08 	lds	r24, 0x0820
    19aa:	90 91 21 08 	lds	r25, 0x0821
    19ae:	2e e1       	ldi	r18, 0x1E	; 30
    19b0:	30 e0       	ldi	r19, 0x00	; 0
    19b2:	a9 01       	movw	r20, r18
    19b4:	48 1b       	sub	r20, r24
    19b6:	59 0b       	sbc	r21, r25
    19b8:	ca 01       	movw	r24, r20
    19ba:	8a 30       	cpi	r24, 0x0A	; 10
    19bc:	91 05       	cpc	r25, r1
    19be:	1c f4       	brge	.+6      	; 0x19c6 <Heating_level_MEDUIM+0x96>
				DriverBlueLED_On();
    19c0:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <DriverBlueLED_On>
    19c4:	02 c0       	rjmp	.+4      	; 0x19ca <Heating_level_MEDUIM+0x9a>
			else
				DriverGreenLED_On();
    19c6:	0e 94 44 0f 	call	0x1e88	; 0x1e88 <DriverGreenLED_On>
		}

		if((uxBits & PASSENGER_EVENT_BIT_BUTTON_PRESSED_MEDIUM) && MEDIUM_DESIRED_TEMP - PassengerSeatTemperature >= 2){
    19ca:	89 81       	ldd	r24, Y+1	; 0x01
    19cc:	9a 81       	ldd	r25, Y+2	; 0x02
    19ce:	80 74       	andi	r24, 0x40	; 64
    19d0:	90 70       	andi	r25, 0x00	; 0
    19d2:	00 97       	sbiw	r24, 0x00	; 0
    19d4:	09 f4       	brne	.+2      	; 0x19d8 <Heating_level_MEDUIM+0xa8>
    19d6:	b6 cf       	rjmp	.-148    	; 0x1944 <Heating_level_MEDUIM+0x14>
    19d8:	80 91 22 08 	lds	r24, 0x0822
    19dc:	90 91 23 08 	lds	r25, 0x0823
    19e0:	2e e1       	ldi	r18, 0x1E	; 30
    19e2:	30 e0       	ldi	r19, 0x00	; 0
    19e4:	a9 01       	movw	r20, r18
    19e6:	48 1b       	sub	r20, r24
    19e8:	59 0b       	sbc	r21, r25
    19ea:	ca 01       	movw	r24, r20
    19ec:	82 30       	cpi	r24, 0x02	; 2
    19ee:	91 05       	cpc	r25, r1
    19f0:	0c f4       	brge	.+2      	; 0x19f4 <Heating_level_MEDUIM+0xc4>
    19f2:	a8 cf       	rjmp	.-176    	; 0x1944 <Heating_level_MEDUIM+0x14>
			if(MEDIUM_DESIRED_TEMP - PassengerSeatTemperature<5)
    19f4:	80 91 22 08 	lds	r24, 0x0822
    19f8:	90 91 23 08 	lds	r25, 0x0823
    19fc:	2e e1       	ldi	r18, 0x1E	; 30
    19fe:	30 e0       	ldi	r19, 0x00	; 0
    1a00:	a9 01       	movw	r20, r18
    1a02:	48 1b       	sub	r20, r24
    1a04:	59 0b       	sbc	r21, r25
    1a06:	ca 01       	movw	r24, r20
    1a08:	85 30       	cpi	r24, 0x05	; 5
    1a0a:	91 05       	cpc	r25, r1
    1a0c:	1c f4       	brge	.+6      	; 0x1a14 <Heating_level_MEDUIM+0xe4>
				PassengerYellowLED_On();
    1a0e:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <PassengerYellowLED_On>
    1a12:	98 cf       	rjmp	.-208    	; 0x1944 <Heating_level_MEDUIM+0x14>
			else if(MEDIUM_DESIRED_TEMP - PassengerSeatTemperature<10)
    1a14:	80 91 22 08 	lds	r24, 0x0822
    1a18:	90 91 23 08 	lds	r25, 0x0823
    1a1c:	2e e1       	ldi	r18, 0x1E	; 30
    1a1e:	30 e0       	ldi	r19, 0x00	; 0
    1a20:	a9 01       	movw	r20, r18
    1a22:	48 1b       	sub	r20, r24
    1a24:	59 0b       	sbc	r21, r25
    1a26:	ca 01       	movw	r24, r20
    1a28:	8a 30       	cpi	r24, 0x0A	; 10
    1a2a:	91 05       	cpc	r25, r1
    1a2c:	1c f4       	brge	.+6      	; 0x1a34 <Heating_level_MEDUIM+0x104>
				PassengerBlueLED_On();
    1a2e:	0e 94 eb 0f 	call	0x1fd6	; 0x1fd6 <PassengerBlueLED_On>
    1a32:	88 cf       	rjmp	.-240    	; 0x1944 <Heating_level_MEDUIM+0x14>
			else
				PassengerGreenLED_On();
    1a34:	0e 94 07 10 	call	0x200e	; 0x200e <PassengerGreenLED_On>
    1a38:	85 cf       	rjmp	.-246    	; 0x1944 <Heating_level_MEDUIM+0x14>

00001a3a <Heating_level_HIGH>:
		}
	}
}
void Heating_level_HIGH(void *pvParameters){
    1a3a:	0f 93       	push	r16
    1a3c:	1f 93       	push	r17
    1a3e:	df 93       	push	r29
    1a40:	cf 93       	push	r28
    1a42:	00 d0       	rcall	.+0      	; 0x1a44 <Heating_level_HIGH+0xa>
    1a44:	00 d0       	rcall	.+0      	; 0x1a46 <Heating_level_HIGH+0xc>
    1a46:	cd b7       	in	r28, 0x3d	; 61
    1a48:	de b7       	in	r29, 0x3e	; 62
    1a4a:	9c 83       	std	Y+4, r25	; 0x04
    1a4c:	8b 83       	std	Y+3, r24	; 0x03
    EventBits_t uxBits;
	for(;;){
		uxBits = xEventGroupWaitBits(
    1a4e:	80 91 78 07 	lds	r24, 0x0778
    1a52:	90 91 79 07 	lds	r25, 0x0779
    1a56:	68 e8       	ldi	r22, 0x88	; 136
    1a58:	70 e0       	ldi	r23, 0x00	; 0
    1a5a:	41 e0       	ldi	r20, 0x01	; 1
    1a5c:	20 e0       	ldi	r18, 0x00	; 0
    1a5e:	0f ef       	ldi	r16, 0xFF	; 255
    1a60:	1f ef       	ldi	r17, 0xFF	; 255
    1a62:	0e 94 95 06 	call	0xd2a	; 0xd2a <xEventGroupWaitBits>
    1a66:	9a 83       	std	Y+2, r25	; 0x02
    1a68:	89 83       	std	Y+1, r24	; 0x01
		                    xEventGroup,
							DRIVER_EVENT_BIT_BUTTON_PRESSED_HIGHT | PASSENGER_EVENT_BIT_BUTTON_PRESSED_HIGHT,
							pdTRUE,               // Clear the bits before returning.
		                    pdFALSE,
		                    portMAX_DELAY );
		if((uxBits & DRIVER_EVENT_BIT_BUTTON_PRESSED_HIGHT) && HIGHT_DESIRED_TEMP - DriverSeatTemperature >= 2){
    1a6a:	89 81       	ldd	r24, Y+1	; 0x01
    1a6c:	9a 81       	ldd	r25, Y+2	; 0x02
    1a6e:	88 70       	andi	r24, 0x08	; 8
    1a70:	90 70       	andi	r25, 0x00	; 0
    1a72:	00 97       	sbiw	r24, 0x00	; 0
    1a74:	79 f1       	breq	.+94     	; 0x1ad4 <Heating_level_HIGH+0x9a>
    1a76:	80 91 20 08 	lds	r24, 0x0820
    1a7a:	90 91 21 08 	lds	r25, 0x0821
    1a7e:	23 e2       	ldi	r18, 0x23	; 35
    1a80:	30 e0       	ldi	r19, 0x00	; 0
    1a82:	a9 01       	movw	r20, r18
    1a84:	48 1b       	sub	r20, r24
    1a86:	59 0b       	sbc	r21, r25
    1a88:	ca 01       	movw	r24, r20
    1a8a:	82 30       	cpi	r24, 0x02	; 2
    1a8c:	91 05       	cpc	r25, r1
    1a8e:	14 f1       	brlt	.+68     	; 0x1ad4 <Heating_level_HIGH+0x9a>
			if(HIGHT_DESIRED_TEMP - DriverSeatTemperature<5)
    1a90:	80 91 20 08 	lds	r24, 0x0820
    1a94:	90 91 21 08 	lds	r25, 0x0821
    1a98:	23 e2       	ldi	r18, 0x23	; 35
    1a9a:	30 e0       	ldi	r19, 0x00	; 0
    1a9c:	a9 01       	movw	r20, r18
    1a9e:	48 1b       	sub	r20, r24
    1aa0:	59 0b       	sbc	r21, r25
    1aa2:	ca 01       	movw	r24, r20
    1aa4:	85 30       	cpi	r24, 0x05	; 5
    1aa6:	91 05       	cpc	r25, r1
    1aa8:	1c f4       	brge	.+6      	; 0x1ab0 <Heating_level_HIGH+0x76>
				DriverYellowLED_On();
    1aaa:	0e 94 0c 0f 	call	0x1e18	; 0x1e18 <DriverYellowLED_On>
    1aae:	12 c0       	rjmp	.+36     	; 0x1ad4 <Heating_level_HIGH+0x9a>
			else if(HIGHT_DESIRED_TEMP - DriverSeatTemperature<10)
    1ab0:	80 91 20 08 	lds	r24, 0x0820
    1ab4:	90 91 21 08 	lds	r25, 0x0821
    1ab8:	23 e2       	ldi	r18, 0x23	; 35
    1aba:	30 e0       	ldi	r19, 0x00	; 0
    1abc:	a9 01       	movw	r20, r18
    1abe:	48 1b       	sub	r20, r24
    1ac0:	59 0b       	sbc	r21, r25
    1ac2:	ca 01       	movw	r24, r20
    1ac4:	8a 30       	cpi	r24, 0x0A	; 10
    1ac6:	91 05       	cpc	r25, r1
    1ac8:	1c f4       	brge	.+6      	; 0x1ad0 <Heating_level_HIGH+0x96>
				DriverBlueLED_On();
    1aca:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <DriverBlueLED_On>
    1ace:	02 c0       	rjmp	.+4      	; 0x1ad4 <Heating_level_HIGH+0x9a>
			else
				DriverGreenLED_On();
    1ad0:	0e 94 44 0f 	call	0x1e88	; 0x1e88 <DriverGreenLED_On>
		}
		if((uxBits & PASSENGER_EVENT_BIT_BUTTON_PRESSED_HIGHT) && HIGHT_DESIRED_TEMP - PassengerSeatTemperature >= 2){
    1ad4:	89 81       	ldd	r24, Y+1	; 0x01
    1ad6:	9a 81       	ldd	r25, Y+2	; 0x02
    1ad8:	80 78       	andi	r24, 0x80	; 128
    1ada:	90 70       	andi	r25, 0x00	; 0
    1adc:	00 97       	sbiw	r24, 0x00	; 0
    1ade:	09 f4       	brne	.+2      	; 0x1ae2 <Heating_level_HIGH+0xa8>
    1ae0:	b6 cf       	rjmp	.-148    	; 0x1a4e <Heating_level_HIGH+0x14>
    1ae2:	80 91 22 08 	lds	r24, 0x0822
    1ae6:	90 91 23 08 	lds	r25, 0x0823
    1aea:	23 e2       	ldi	r18, 0x23	; 35
    1aec:	30 e0       	ldi	r19, 0x00	; 0
    1aee:	a9 01       	movw	r20, r18
    1af0:	48 1b       	sub	r20, r24
    1af2:	59 0b       	sbc	r21, r25
    1af4:	ca 01       	movw	r24, r20
    1af6:	82 30       	cpi	r24, 0x02	; 2
    1af8:	91 05       	cpc	r25, r1
    1afa:	0c f4       	brge	.+2      	; 0x1afe <Heating_level_HIGH+0xc4>
    1afc:	a8 cf       	rjmp	.-176    	; 0x1a4e <Heating_level_HIGH+0x14>
			if(HIGHT_DESIRED_TEMP - PassengerSeatTemperature<5)
    1afe:	80 91 22 08 	lds	r24, 0x0822
    1b02:	90 91 23 08 	lds	r25, 0x0823
    1b06:	23 e2       	ldi	r18, 0x23	; 35
    1b08:	30 e0       	ldi	r19, 0x00	; 0
    1b0a:	a9 01       	movw	r20, r18
    1b0c:	48 1b       	sub	r20, r24
    1b0e:	59 0b       	sbc	r21, r25
    1b10:	ca 01       	movw	r24, r20
    1b12:	85 30       	cpi	r24, 0x05	; 5
    1b14:	91 05       	cpc	r25, r1
    1b16:	1c f4       	brge	.+6      	; 0x1b1e <Heating_level_HIGH+0xe4>
				PassengerYellowLED_On();
    1b18:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <PassengerYellowLED_On>
    1b1c:	98 cf       	rjmp	.-208    	; 0x1a4e <Heating_level_HIGH+0x14>
			else if(HIGHT_DESIRED_TEMP - PassengerSeatTemperature<10)
    1b1e:	80 91 22 08 	lds	r24, 0x0822
    1b22:	90 91 23 08 	lds	r25, 0x0823
    1b26:	23 e2       	ldi	r18, 0x23	; 35
    1b28:	30 e0       	ldi	r19, 0x00	; 0
    1b2a:	a9 01       	movw	r20, r18
    1b2c:	48 1b       	sub	r20, r24
    1b2e:	59 0b       	sbc	r21, r25
    1b30:	ca 01       	movw	r24, r20
    1b32:	8a 30       	cpi	r24, 0x0A	; 10
    1b34:	91 05       	cpc	r25, r1
    1b36:	1c f4       	brge	.+6      	; 0x1b3e <Heating_level_HIGH+0x104>
				PassengerBlueLED_On();
    1b38:	0e 94 eb 0f 	call	0x1fd6	; 0x1fd6 <PassengerBlueLED_On>
    1b3c:	88 cf       	rjmp	.-240    	; 0x1a4e <Heating_level_HIGH+0x14>
			else
				PassengerGreenLED_On();
    1b3e:	0e 94 07 10 	call	0x200e	; 0x200e <PassengerGreenLED_On>
    1b42:	85 cf       	rjmp	.-246    	; 0x1a4e <Heating_level_HIGH+0x14>

00001b44 <main>:
}



int main(void)
{
    1b44:	ef 92       	push	r14
    1b46:	ff 92       	push	r15
    1b48:	0f 93       	push	r16
    1b4a:	df 93       	push	r29
    1b4c:	cf 93       	push	r28
    1b4e:	cd b7       	in	r28, 0x3d	; 61
    1b50:	de b7       	in	r29, 0x3e	; 62
    Hardware_init();
    1b52:	0e 94 1d 0e 	call	0x1c3a	; 0x1c3a <Hardware_init>

    Mutes = xSemaphoreCreateMutex();
    1b56:	81 e0       	ldi	r24, 0x01	; 1
    1b58:	0e 94 2d 14 	call	0x285a	; 0x285a <xQueueCreateMutex>
    1b5c:	90 93 1f 08 	sts	0x081F, r25
    1b60:	80 93 1e 08 	sts	0x081E, r24
    xEventGroup = xEventGroupCreate();
    1b64:	0e 94 bd 05 	call	0xb7a	; 0xb7a <xEventGroupCreate>
    1b68:	90 93 79 07 	sts	0x0779, r25
    1b6c:	80 93 78 07 	sts	0x0778, r24

    if(xEventGroup != NULL&&Mutes!=NULL) {
    1b70:	80 91 78 07 	lds	r24, 0x0778
    1b74:	90 91 79 07 	lds	r25, 0x0779
    1b78:	00 97       	sbiw	r24, 0x00	; 0
    1b7a:	09 f4       	brne	.+2      	; 0x1b7e <main+0x3a>
    1b7c:	5d c0       	rjmp	.+186    	; 0x1c38 <main+0xf4>
    1b7e:	80 91 1e 08 	lds	r24, 0x081E
    1b82:	90 91 1f 08 	lds	r25, 0x081F
    1b86:	00 97       	sbiw	r24, 0x00	; 0
    1b88:	09 f4       	brne	.+2      	; 0x1b8c <main+0x48>
    1b8a:	56 c0       	rjmp	.+172    	; 0x1c38 <main+0xf4>

        xTaskCreate(PassengerButtonHandler, "LED Task", configMINIMAL_STACK_SIZE, NULL, 2, NULL);
    1b8c:	84 eb       	ldi	r24, 0xB4	; 180
    1b8e:	9a e0       	ldi	r25, 0x0A	; 10
    1b90:	20 e6       	ldi	r18, 0x60	; 96
    1b92:	30 e0       	ldi	r19, 0x00	; 0
    1b94:	b9 01       	movw	r22, r18
    1b96:	40 e5       	ldi	r20, 0x50	; 80
    1b98:	50 e0       	ldi	r21, 0x00	; 0
    1b9a:	20 e0       	ldi	r18, 0x00	; 0
    1b9c:	30 e0       	ldi	r19, 0x00	; 0
    1b9e:	02 e0       	ldi	r16, 0x02	; 2
    1ba0:	ee 24       	eor	r14, r14
    1ba2:	ff 24       	eor	r15, r15
    1ba4:	0e 94 c1 22 	call	0x4582	; 0x4582 <xTaskCreate>
        xTaskCreate(Heating_level_LOW, "vLED Task", configMINIMAL_STACK_SIZE, NULL, 2, NULL);
    1ba8:	83 e1       	ldi	r24, 0x13	; 19
    1baa:	9c e0       	ldi	r25, 0x0C	; 12
    1bac:	29 e6       	ldi	r18, 0x69	; 105
    1bae:	30 e0       	ldi	r19, 0x00	; 0
    1bb0:	b9 01       	movw	r22, r18
    1bb2:	40 e5       	ldi	r20, 0x50	; 80
    1bb4:	50 e0       	ldi	r21, 0x00	; 0
    1bb6:	20 e0       	ldi	r18, 0x00	; 0
    1bb8:	30 e0       	ldi	r19, 0x00	; 0
    1bba:	02 e0       	ldi	r16, 0x02	; 2
    1bbc:	ee 24       	eor	r14, r14
    1bbe:	ff 24       	eor	r15, r15
    1bc0:	0e 94 c1 22 	call	0x4582	; 0x4582 <xTaskCreate>
        xTaskCreate(DriverButtonHandle, "DriverButtonHandle Task", configMINIMAL_STACK_SIZE, NULL, 2, NULL);
    1bc4:	8b e3       	ldi	r24, 0x3B	; 59
    1bc6:	9b e0       	ldi	r25, 0x0B	; 11
    1bc8:	23 e7       	ldi	r18, 0x73	; 115
    1bca:	30 e0       	ldi	r19, 0x00	; 0
    1bcc:	b9 01       	movw	r22, r18
    1bce:	40 e5       	ldi	r20, 0x50	; 80
    1bd0:	50 e0       	ldi	r21, 0x00	; 0
    1bd2:	20 e0       	ldi	r18, 0x00	; 0
    1bd4:	30 e0       	ldi	r19, 0x00	; 0
    1bd6:	02 e0       	ldi	r16, 0x02	; 2
    1bd8:	ee 24       	eor	r14, r14
    1bda:	ff 24       	eor	r15, r15
    1bdc:	0e 94 c1 22 	call	0x4582	; 0x4582 <xTaskCreate>
        xTaskCreate(Heating_level_MEDUIM, "DriverButtonHandle Task", configMINIMAL_STACK_SIZE, NULL, 2, NULL);
    1be0:	88 e9       	ldi	r24, 0x98	; 152
    1be2:	9c e0       	ldi	r25, 0x0C	; 12
    1be4:	23 e7       	ldi	r18, 0x73	; 115
    1be6:	30 e0       	ldi	r19, 0x00	; 0
    1be8:	b9 01       	movw	r22, r18
    1bea:	40 e5       	ldi	r20, 0x50	; 80
    1bec:	50 e0       	ldi	r21, 0x00	; 0
    1bee:	20 e0       	ldi	r18, 0x00	; 0
    1bf0:	30 e0       	ldi	r19, 0x00	; 0
    1bf2:	02 e0       	ldi	r16, 0x02	; 2
    1bf4:	ee 24       	eor	r14, r14
    1bf6:	ff 24       	eor	r15, r15
    1bf8:	0e 94 c1 22 	call	0x4582	; 0x4582 <xTaskCreate>
        xTaskCreate(Heating_level_HIGH, "DriverButtonHandle Task", configMINIMAL_STACK_SIZE, NULL, 2	, NULL);
    1bfc:	8d e1       	ldi	r24, 0x1D	; 29
    1bfe:	9d e0       	ldi	r25, 0x0D	; 13
    1c00:	23 e7       	ldi	r18, 0x73	; 115
    1c02:	30 e0       	ldi	r19, 0x00	; 0
    1c04:	b9 01       	movw	r22, r18
    1c06:	40 e5       	ldi	r20, 0x50	; 80
    1c08:	50 e0       	ldi	r21, 0x00	; 0
    1c0a:	20 e0       	ldi	r18, 0x00	; 0
    1c0c:	30 e0       	ldi	r19, 0x00	; 0
    1c0e:	02 e0       	ldi	r16, 0x02	; 2
    1c10:	ee 24       	eor	r14, r14
    1c12:	ff 24       	eor	r15, r15
    1c14:	0e 94 c1 22 	call	0x4582	; 0x4582 <xTaskCreate>
        xTaskCreate(Temperature_Task, "DriverButtonHandle Task", configMINIMAL_STACK_SIZE, NULL, 3, NULL);
    1c18:	82 ec       	ldi	r24, 0xC2	; 194
    1c1a:	9b e0       	ldi	r25, 0x0B	; 11
    1c1c:	23 e7       	ldi	r18, 0x73	; 115
    1c1e:	30 e0       	ldi	r19, 0x00	; 0
    1c20:	b9 01       	movw	r22, r18
    1c22:	40 e5       	ldi	r20, 0x50	; 80
    1c24:	50 e0       	ldi	r21, 0x00	; 0
    1c26:	20 e0       	ldi	r18, 0x00	; 0
    1c28:	30 e0       	ldi	r19, 0x00	; 0
    1c2a:	03 e0       	ldi	r16, 0x03	; 3
    1c2c:	ee 24       	eor	r14, r14
    1c2e:	ff 24       	eor	r15, r15
    1c30:	0e 94 c1 22 	call	0x4582	; 0x4582 <xTaskCreate>

        vTaskStartScheduler();
    1c34:	0e 94 e7 26 	call	0x4dce	; 0x4dce <vTaskStartScheduler>
    1c38:	ff cf       	rjmp	.-2      	; 0x1c38 <main+0xf4>

00001c3a <Hardware_init>:
    while (1) {}

    return 0;
}

void Hardware_init(){
    1c3a:	df 93       	push	r29
    1c3c:	cf 93       	push	r28
    1c3e:	cd b7       	in	r28, 0x3d	; 61
    1c40:	de b7       	in	r29, 0x3e	; 62
    ADC_Init();
    1c42:	0e 94 64 0e 	call	0x1cc8	; 0x1cc8 <ADC_Init>
    Buttons_init();
    1c46:	0e 94 db 0e 	call	0x1db6	; 0x1db6 <Buttons_init>
    Leds_init();
    1c4a:	0e 94 f0 0e 	call	0x1de0	; 0x1de0 <Leds_init>
    UART_init(MYUBRR);
    1c4e:	87 e6       	ldi	r24, 0x67	; 103
    1c50:	90 e0       	ldi	r25, 0x00	; 0
    1c52:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <UART_init>
}
    1c56:	cf 91       	pop	r28
    1c58:	df 91       	pop	r29
    1c5a:	08 95       	ret

00001c5c <GetDriverButtonState>:
int GetDriverButtonState(){
    1c5c:	df 93       	push	r29
    1c5e:	cf 93       	push	r28
    1c60:	00 d0       	rcall	.+0      	; 0x1c62 <GetDriverButtonState+0x6>
    1c62:	cd b7       	in	r28, 0x3d	; 61
    1c64:	de b7       	in	r29, 0x3e	; 62
	return !!!(PINB&(1<<DRIVER_PUSH_BUTTON));
    1c66:	e6 e3       	ldi	r30, 0x36	; 54
    1c68:	f0 e0       	ldi	r31, 0x00	; 0
    1c6a:	80 81       	ld	r24, Z
    1c6c:	88 2f       	mov	r24, r24
    1c6e:	90 e0       	ldi	r25, 0x00	; 0
    1c70:	88 70       	andi	r24, 0x08	; 8
    1c72:	90 70       	andi	r25, 0x00	; 0
    1c74:	1a 82       	std	Y+2, r1	; 0x02
    1c76:	19 82       	std	Y+1, r1	; 0x01
    1c78:	00 97       	sbiw	r24, 0x00	; 0
    1c7a:	21 f4       	brne	.+8      	; 0x1c84 <GetDriverButtonState+0x28>
    1c7c:	81 e0       	ldi	r24, 0x01	; 1
    1c7e:	90 e0       	ldi	r25, 0x00	; 0
    1c80:	9a 83       	std	Y+2, r25	; 0x02
    1c82:	89 83       	std	Y+1, r24	; 0x01
    1c84:	89 81       	ldd	r24, Y+1	; 0x01
    1c86:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1c88:	0f 90       	pop	r0
    1c8a:	0f 90       	pop	r0
    1c8c:	cf 91       	pop	r28
    1c8e:	df 91       	pop	r29
    1c90:	08 95       	ret

00001c92 <GetPassengerButtonState>:
int GetPassengerButtonState(){
    1c92:	df 93       	push	r29
    1c94:	cf 93       	push	r28
    1c96:	00 d0       	rcall	.+0      	; 0x1c98 <GetPassengerButtonState+0x6>
    1c98:	cd b7       	in	r28, 0x3d	; 61
    1c9a:	de b7       	in	r29, 0x3e	; 62
	return !!!(PINB&(1<<PASSENGER_PUSH_BUTTON));
    1c9c:	e6 e3       	ldi	r30, 0x36	; 54
    1c9e:	f0 e0       	ldi	r31, 0x00	; 0
    1ca0:	80 81       	ld	r24, Z
    1ca2:	88 2f       	mov	r24, r24
    1ca4:	90 e0       	ldi	r25, 0x00	; 0
    1ca6:	80 71       	andi	r24, 0x10	; 16
    1ca8:	90 70       	andi	r25, 0x00	; 0
    1caa:	1a 82       	std	Y+2, r1	; 0x02
    1cac:	19 82       	std	Y+1, r1	; 0x01
    1cae:	00 97       	sbiw	r24, 0x00	; 0
    1cb0:	21 f4       	brne	.+8      	; 0x1cba <GetPassengerButtonState+0x28>
    1cb2:	81 e0       	ldi	r24, 0x01	; 1
    1cb4:	90 e0       	ldi	r25, 0x00	; 0
    1cb6:	9a 83       	std	Y+2, r25	; 0x02
    1cb8:	89 83       	std	Y+1, r24	; 0x01
    1cba:	89 81       	ldd	r24, Y+1	; 0x01
    1cbc:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1cbe:	0f 90       	pop	r0
    1cc0:	0f 90       	pop	r0
    1cc2:	cf 91       	pop	r28
    1cc4:	df 91       	pop	r29
    1cc6:	08 95       	ret

00001cc8 <ADC_Init>:
void ADC_Init()
{
    1cc8:	df 93       	push	r29
    1cca:	cf 93       	push	r28
    1ccc:	cd b7       	in	r28, 0x3d	; 61
    1cce:	de b7       	in	r29, 0x3e	; 62
    ADMUX = (1 << REFS0);
    1cd0:	e7 e2       	ldi	r30, 0x27	; 39
    1cd2:	f0 e0       	ldi	r31, 0x00	; 0
    1cd4:	80 e4       	ldi	r24, 0x40	; 64
    1cd6:	80 83       	st	Z, r24
    ADCSRA = (1 << ADEN) | (1 << ADPS2) | (1 << ADPS1);
    1cd8:	e6 e2       	ldi	r30, 0x26	; 38
    1cda:	f0 e0       	ldi	r31, 0x00	; 0
    1cdc:	86 e8       	ldi	r24, 0x86	; 134
    1cde:	80 83       	st	Z, r24
}
    1ce0:	cf 91       	pop	r28
    1ce2:	df 91       	pop	r29
    1ce4:	08 95       	ret

00001ce6 <ADC_Read>:

uint16_t ADC_Read(uint8_t channel)
{
    1ce6:	df 93       	push	r29
    1ce8:	cf 93       	push	r28
    1cea:	0f 92       	push	r0
    1cec:	cd b7       	in	r28, 0x3d	; 61
    1cee:	de b7       	in	r29, 0x3e	; 62
    1cf0:	89 83       	std	Y+1, r24	; 0x01
    channel &= 0x07;
    1cf2:	89 81       	ldd	r24, Y+1	; 0x01
    1cf4:	87 70       	andi	r24, 0x07	; 7
    1cf6:	89 83       	std	Y+1, r24	; 0x01
    ADMUX = (ADMUX & 0xF8) | channel;
    1cf8:	a7 e2       	ldi	r26, 0x27	; 39
    1cfa:	b0 e0       	ldi	r27, 0x00	; 0
    1cfc:	e7 e2       	ldi	r30, 0x27	; 39
    1cfe:	f0 e0       	ldi	r31, 0x00	; 0
    1d00:	80 81       	ld	r24, Z
    1d02:	98 2f       	mov	r25, r24
    1d04:	98 7f       	andi	r25, 0xF8	; 248
    1d06:	89 81       	ldd	r24, Y+1	; 0x01
    1d08:	89 2b       	or	r24, r25
    1d0a:	8c 93       	st	X, r24
    ADCSRA |= (1 << ADSC);
    1d0c:	a6 e2       	ldi	r26, 0x26	; 38
    1d0e:	b0 e0       	ldi	r27, 0x00	; 0
    1d10:	e6 e2       	ldi	r30, 0x26	; 38
    1d12:	f0 e0       	ldi	r31, 0x00	; 0
    1d14:	80 81       	ld	r24, Z
    1d16:	80 64       	ori	r24, 0x40	; 64
    1d18:	8c 93       	st	X, r24
    while (ADCSRA & (1 << ADSC));
    1d1a:	e6 e2       	ldi	r30, 0x26	; 38
    1d1c:	f0 e0       	ldi	r31, 0x00	; 0
    1d1e:	80 81       	ld	r24, Z
    1d20:	88 2f       	mov	r24, r24
    1d22:	90 e0       	ldi	r25, 0x00	; 0
    1d24:	80 74       	andi	r24, 0x40	; 64
    1d26:	90 70       	andi	r25, 0x00	; 0
    1d28:	00 97       	sbiw	r24, 0x00	; 0
    1d2a:	b9 f7       	brne	.-18     	; 0x1d1a <ADC_Read+0x34>
    return ADC;
    1d2c:	e4 e2       	ldi	r30, 0x24	; 36
    1d2e:	f0 e0       	ldi	r31, 0x00	; 0
    1d30:	80 81       	ld	r24, Z
    1d32:	91 81       	ldd	r25, Z+1	; 0x01
}
    1d34:	0f 90       	pop	r0
    1d36:	cf 91       	pop	r28
    1d38:	df 91       	pop	r29
    1d3a:	08 95       	ret

00001d3c <LM35_getTemperature>:

uint8 LM35_getTemperature(uint8 channel)
{
    1d3c:	df 93       	push	r29
    1d3e:	cf 93       	push	r28
    1d40:	00 d0       	rcall	.+0      	; 0x1d42 <LM35_getTemperature+0x6>
    1d42:	00 d0       	rcall	.+0      	; 0x1d44 <LM35_getTemperature+0x8>
    1d44:	cd b7       	in	r28, 0x3d	; 61
    1d46:	de b7       	in	r29, 0x3e	; 62
    1d48:	8c 83       	std	Y+4, r24	; 0x04
    uint8 temp_value = 0;
    1d4a:	1b 82       	std	Y+3, r1	; 0x03
    uint16 adc_value = 0;
    1d4c:	1a 82       	std	Y+2, r1	; 0x02
    1d4e:	19 82       	std	Y+1, r1	; 0x01
    adc_value = ADC_Read(channel);
    1d50:	8c 81       	ldd	r24, Y+4	; 0x04
    1d52:	0e 94 73 0e 	call	0x1ce6	; 0x1ce6 <ADC_Read>
    1d56:	9a 83       	std	Y+2, r25	; 0x02
    1d58:	89 83       	std	Y+1, r24	; 0x01
    temp_value = (uint8)(((uint32)adc_value*SENSOR_MAX_TEMPERATURE*ADC_REF_VOLT_VALUE)/(ADC_MAXIMUM_VALUE*SENSOR_MAX_VOLT_VALUE));
    1d5a:	89 81       	ldd	r24, Y+1	; 0x01
    1d5c:	9a 81       	ldd	r25, Y+2	; 0x02
    1d5e:	cc 01       	movw	r24, r24
    1d60:	a0 e0       	ldi	r26, 0x00	; 0
    1d62:	b0 e0       	ldi	r27, 0x00	; 0
    1d64:	2e ee       	ldi	r18, 0xEE	; 238
    1d66:	32 e0       	ldi	r19, 0x02	; 2
    1d68:	40 e0       	ldi	r20, 0x00	; 0
    1d6a:	50 e0       	ldi	r21, 0x00	; 0
    1d6c:	bc 01       	movw	r22, r24
    1d6e:	cd 01       	movw	r24, r26
    1d70:	0e 94 10 32 	call	0x6420	; 0x6420 <__mulsi3>
    1d74:	dc 01       	movw	r26, r24
    1d76:	cb 01       	movw	r24, r22
    1d78:	bc 01       	movw	r22, r24
    1d7a:	cd 01       	movw	r24, r26
    1d7c:	0e 94 4f 03 	call	0x69e	; 0x69e <__floatunsisf>
    1d80:	dc 01       	movw	r26, r24
    1d82:	cb 01       	movw	r24, r22
    1d84:	bc 01       	movw	r22, r24
    1d86:	cd 01       	movw	r24, r26
    1d88:	20 e0       	ldi	r18, 0x00	; 0
    1d8a:	30 ed       	ldi	r19, 0xD0	; 208
    1d8c:	4f eb       	ldi	r20, 0xBF	; 191
    1d8e:	54 e4       	ldi	r21, 0x44	; 68
    1d90:	0e 94 1f 02 	call	0x43e	; 0x43e <__divsf3>
    1d94:	dc 01       	movw	r26, r24
    1d96:	cb 01       	movw	r24, r22
    1d98:	bc 01       	movw	r22, r24
    1d9a:	cd 01       	movw	r24, r26
    1d9c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1da0:	dc 01       	movw	r26, r24
    1da2:	cb 01       	movw	r24, r22
    1da4:	8b 83       	std	Y+3, r24	; 0x03
    return temp_value;
    1da6:	8b 81       	ldd	r24, Y+3	; 0x03
}
    1da8:	0f 90       	pop	r0
    1daa:	0f 90       	pop	r0
    1dac:	0f 90       	pop	r0
    1dae:	0f 90       	pop	r0
    1db0:	cf 91       	pop	r28
    1db2:	df 91       	pop	r29
    1db4:	08 95       	ret

00001db6 <Buttons_init>:

void Buttons_init(void){
    1db6:	df 93       	push	r29
    1db8:	cf 93       	push	r28
    1dba:	cd b7       	in	r28, 0x3d	; 61
    1dbc:	de b7       	in	r29, 0x3e	; 62
    DDRB &=~((1<<DRIVER_PUSH_BUTTON)|(1<<PASSENGER_PUSH_BUTTON));
    1dbe:	a7 e3       	ldi	r26, 0x37	; 55
    1dc0:	b0 e0       	ldi	r27, 0x00	; 0
    1dc2:	e7 e3       	ldi	r30, 0x37	; 55
    1dc4:	f0 e0       	ldi	r31, 0x00	; 0
    1dc6:	80 81       	ld	r24, Z
    1dc8:	87 7e       	andi	r24, 0xE7	; 231
    1dca:	8c 93       	st	X, r24
    PORTB |=(1<<DRIVER_PUSH_BUTTON)|(1<<PASSENGER_PUSH_BUTTON);
    1dcc:	a8 e3       	ldi	r26, 0x38	; 56
    1dce:	b0 e0       	ldi	r27, 0x00	; 0
    1dd0:	e8 e3       	ldi	r30, 0x38	; 56
    1dd2:	f0 e0       	ldi	r31, 0x00	; 0
    1dd4:	80 81       	ld	r24, Z
    1dd6:	88 61       	ori	r24, 0x18	; 24
    1dd8:	8c 93       	st	X, r24
}
    1dda:	cf 91       	pop	r28
    1ddc:	df 91       	pop	r29
    1dde:	08 95       	ret

00001de0 <Leds_init>:

void Leds_init(void){
    1de0:	df 93       	push	r29
    1de2:	cf 93       	push	r28
    1de4:	cd b7       	in	r28, 0x3d	; 61
    1de6:	de b7       	in	r29, 0x3e	; 62
    DDRD|=(1<<DRIVER_YELLOW_LED)|(1<<DRIVER_BLUE_LED)|(1<<DRIVER_GREEN_LED)|(1<<RED_LED);
    1de8:	a1 e3       	ldi	r26, 0x31	; 49
    1dea:	b0 e0       	ldi	r27, 0x00	; 0
    1dec:	e1 e3       	ldi	r30, 0x31	; 49
    1dee:	f0 e0       	ldi	r31, 0x00	; 0
    1df0:	80 81       	ld	r24, Z
    1df2:	80 6f       	ori	r24, 0xF0	; 240
    1df4:	8c 93       	st	X, r24
    DDRC |= (1 << PC0) | (1 << PC1) | (1 << PC2);
    1df6:	a4 e3       	ldi	r26, 0x34	; 52
    1df8:	b0 e0       	ldi	r27, 0x00	; 0
    1dfa:	e4 e3       	ldi	r30, 0x34	; 52
    1dfc:	f0 e0       	ldi	r31, 0x00	; 0
    1dfe:	80 81       	ld	r24, Z
    1e00:	87 60       	ori	r24, 0x07	; 7
    1e02:	8c 93       	st	X, r24

    PORTC &= ~((1 << PC0) | (1 << PC1) | (1 << PC2));
    1e04:	a5 e3       	ldi	r26, 0x35	; 53
    1e06:	b0 e0       	ldi	r27, 0x00	; 0
    1e08:	e5 e3       	ldi	r30, 0x35	; 53
    1e0a:	f0 e0       	ldi	r31, 0x00	; 0
    1e0c:	80 81       	ld	r24, Z
    1e0e:	88 7f       	andi	r24, 0xF8	; 248
    1e10:	8c 93       	st	X, r24
}
    1e12:	cf 91       	pop	r28
    1e14:	df 91       	pop	r29
    1e16:	08 95       	ret

00001e18 <DriverYellowLED_On>:

void DriverYellowLED_On()
{
    1e18:	df 93       	push	r29
    1e1a:	cf 93       	push	r28
    1e1c:	cd b7       	in	r28, 0x3d	; 61
    1e1e:	de b7       	in	r29, 0x3e	; 62
    PORTD |= (1 << DRIVER_YELLOW_LED);
    1e20:	a2 e3       	ldi	r26, 0x32	; 50
    1e22:	b0 e0       	ldi	r27, 0x00	; 0
    1e24:	e2 e3       	ldi	r30, 0x32	; 50
    1e26:	f0 e0       	ldi	r31, 0x00	; 0
    1e28:	80 81       	ld	r24, Z
    1e2a:	80 68       	ori	r24, 0x80	; 128
    1e2c:	8c 93       	st	X, r24
}
    1e2e:	cf 91       	pop	r28
    1e30:	df 91       	pop	r29
    1e32:	08 95       	ret

00001e34 <DriverYellowLED_Off>:

void DriverYellowLED_Off()
{
    1e34:	df 93       	push	r29
    1e36:	cf 93       	push	r28
    1e38:	cd b7       	in	r28, 0x3d	; 61
    1e3a:	de b7       	in	r29, 0x3e	; 62
    PORTD &= ~(1 << DRIVER_YELLOW_LED);
    1e3c:	a2 e3       	ldi	r26, 0x32	; 50
    1e3e:	b0 e0       	ldi	r27, 0x00	; 0
    1e40:	e2 e3       	ldi	r30, 0x32	; 50
    1e42:	f0 e0       	ldi	r31, 0x00	; 0
    1e44:	80 81       	ld	r24, Z
    1e46:	8f 77       	andi	r24, 0x7F	; 127
    1e48:	8c 93       	st	X, r24
}
    1e4a:	cf 91       	pop	r28
    1e4c:	df 91       	pop	r29
    1e4e:	08 95       	ret

00001e50 <DriverBlueLED_On>:

void DriverBlueLED_On()
{
    1e50:	df 93       	push	r29
    1e52:	cf 93       	push	r28
    1e54:	cd b7       	in	r28, 0x3d	; 61
    1e56:	de b7       	in	r29, 0x3e	; 62
    PORTD |= (1 << DRIVER_BLUE_LED);
    1e58:	a2 e3       	ldi	r26, 0x32	; 50
    1e5a:	b0 e0       	ldi	r27, 0x00	; 0
    1e5c:	e2 e3       	ldi	r30, 0x32	; 50
    1e5e:	f0 e0       	ldi	r31, 0x00	; 0
    1e60:	80 81       	ld	r24, Z
    1e62:	80 64       	ori	r24, 0x40	; 64
    1e64:	8c 93       	st	X, r24
}
    1e66:	cf 91       	pop	r28
    1e68:	df 91       	pop	r29
    1e6a:	08 95       	ret

00001e6c <DriverBlueLED_Off>:

void DriverBlueLED_Off()
{
    1e6c:	df 93       	push	r29
    1e6e:	cf 93       	push	r28
    1e70:	cd b7       	in	r28, 0x3d	; 61
    1e72:	de b7       	in	r29, 0x3e	; 62
    PORTD &= ~(1 << DRIVER_BLUE_LED);
    1e74:	a2 e3       	ldi	r26, 0x32	; 50
    1e76:	b0 e0       	ldi	r27, 0x00	; 0
    1e78:	e2 e3       	ldi	r30, 0x32	; 50
    1e7a:	f0 e0       	ldi	r31, 0x00	; 0
    1e7c:	80 81       	ld	r24, Z
    1e7e:	8f 7b       	andi	r24, 0xBF	; 191
    1e80:	8c 93       	st	X, r24
}
    1e82:	cf 91       	pop	r28
    1e84:	df 91       	pop	r29
    1e86:	08 95       	ret

00001e88 <DriverGreenLED_On>:

void DriverGreenLED_On()
{
    1e88:	df 93       	push	r29
    1e8a:	cf 93       	push	r28
    1e8c:	cd b7       	in	r28, 0x3d	; 61
    1e8e:	de b7       	in	r29, 0x3e	; 62
    PORTD |= (1 << DRIVER_GREEN_LED);
    1e90:	a2 e3       	ldi	r26, 0x32	; 50
    1e92:	b0 e0       	ldi	r27, 0x00	; 0
    1e94:	e2 e3       	ldi	r30, 0x32	; 50
    1e96:	f0 e0       	ldi	r31, 0x00	; 0
    1e98:	80 81       	ld	r24, Z
    1e9a:	80 62       	ori	r24, 0x20	; 32
    1e9c:	8c 93       	st	X, r24
}
    1e9e:	cf 91       	pop	r28
    1ea0:	df 91       	pop	r29
    1ea2:	08 95       	ret

00001ea4 <DriverGreenLED_Off>:

void DriverGreenLED_Off()
{
    1ea4:	df 93       	push	r29
    1ea6:	cf 93       	push	r28
    1ea8:	cd b7       	in	r28, 0x3d	; 61
    1eaa:	de b7       	in	r29, 0x3e	; 62
    PORTD &= ~(1 << DRIVER_GREEN_LED);
    1eac:	a2 e3       	ldi	r26, 0x32	; 50
    1eae:	b0 e0       	ldi	r27, 0x00	; 0
    1eb0:	e2 e3       	ldi	r30, 0x32	; 50
    1eb2:	f0 e0       	ldi	r31, 0x00	; 0
    1eb4:	80 81       	ld	r24, Z
    1eb6:	8f 7d       	andi	r24, 0xDF	; 223
    1eb8:	8c 93       	st	X, r24
}
    1eba:	cf 91       	pop	r28
    1ebc:	df 91       	pop	r29
    1ebe:	08 95       	ret

00001ec0 <RedLED_On>:
void RedLED_On(){
    1ec0:	df 93       	push	r29
    1ec2:	cf 93       	push	r28
    1ec4:	cd b7       	in	r28, 0x3d	; 61
    1ec6:	de b7       	in	r29, 0x3e	; 62
	PORTD |= (1 << RED_LED);
    1ec8:	a2 e3       	ldi	r26, 0x32	; 50
    1eca:	b0 e0       	ldi	r27, 0x00	; 0
    1ecc:	e2 e3       	ldi	r30, 0x32	; 50
    1ece:	f0 e0       	ldi	r31, 0x00	; 0
    1ed0:	80 81       	ld	r24, Z
    1ed2:	80 61       	ori	r24, 0x10	; 16
    1ed4:	8c 93       	st	X, r24
}
    1ed6:	cf 91       	pop	r28
    1ed8:	df 91       	pop	r29
    1eda:	08 95       	ret

00001edc <RedLED_Off>:
void RedLED_Off(){
    1edc:	df 93       	push	r29
    1ede:	cf 93       	push	r28
    1ee0:	cd b7       	in	r28, 0x3d	; 61
    1ee2:	de b7       	in	r29, 0x3e	; 62
	PORTD &= ~(1 << RED_LED);
    1ee4:	a2 e3       	ldi	r26, 0x32	; 50
    1ee6:	b0 e0       	ldi	r27, 0x00	; 0
    1ee8:	e2 e3       	ldi	r30, 0x32	; 50
    1eea:	f0 e0       	ldi	r31, 0x00	; 0
    1eec:	80 81       	ld	r24, Z
    1eee:	8f 7e       	andi	r24, 0xEF	; 239
    1ef0:	8c 93       	st	X, r24
}
    1ef2:	cf 91       	pop	r28
    1ef4:	df 91       	pop	r29
    1ef6:	08 95       	ret

00001ef8 <UART_init>:

void UART_init(unsigned int ubrr) {
    1ef8:	df 93       	push	r29
    1efa:	cf 93       	push	r28
    1efc:	00 d0       	rcall	.+0      	; 0x1efe <UART_init+0x6>
    1efe:	cd b7       	in	r28, 0x3d	; 61
    1f00:	de b7       	in	r29, 0x3e	; 62
    1f02:	9a 83       	std	Y+2, r25	; 0x02
    1f04:	89 83       	std	Y+1, r24	; 0x01
    UBRRH = (unsigned char)(ubrr>>8);
    1f06:	e0 e4       	ldi	r30, 0x40	; 64
    1f08:	f0 e0       	ldi	r31, 0x00	; 0
    1f0a:	89 81       	ldd	r24, Y+1	; 0x01
    1f0c:	9a 81       	ldd	r25, Y+2	; 0x02
    1f0e:	89 2f       	mov	r24, r25
    1f10:	99 27       	eor	r25, r25
    1f12:	80 83       	st	Z, r24
    UBRRL = (unsigned char)ubrr;
    1f14:	e9 e2       	ldi	r30, 0x29	; 41
    1f16:	f0 e0       	ldi	r31, 0x00	; 0
    1f18:	89 81       	ldd	r24, Y+1	; 0x01
    1f1a:	80 83       	st	Z, r24

    UCSRB = (1<<TXEN);
    1f1c:	ea e2       	ldi	r30, 0x2A	; 42
    1f1e:	f0 e0       	ldi	r31, 0x00	; 0
    1f20:	88 e0       	ldi	r24, 0x08	; 8
    1f22:	80 83       	st	Z, r24

    UCSRC = (1<<URSEL) | (1<<UCSZ1) | (1<<UCSZ0);
    1f24:	e0 e4       	ldi	r30, 0x40	; 64
    1f26:	f0 e0       	ldi	r31, 0x00	; 0
    1f28:	86 e8       	ldi	r24, 0x86	; 134
    1f2a:	80 83       	st	Z, r24
}
    1f2c:	0f 90       	pop	r0
    1f2e:	0f 90       	pop	r0
    1f30:	cf 91       	pop	r28
    1f32:	df 91       	pop	r29
    1f34:	08 95       	ret

00001f36 <UART_sendChar>:
void UART_sendChar(char data) {
    1f36:	df 93       	push	r29
    1f38:	cf 93       	push	r28
    1f3a:	0f 92       	push	r0
    1f3c:	cd b7       	in	r28, 0x3d	; 61
    1f3e:	de b7       	in	r29, 0x3e	; 62
    1f40:	89 83       	std	Y+1, r24	; 0x01
    while (!( UCSRA & (1<<UDRE)));
    1f42:	eb e2       	ldi	r30, 0x2B	; 43
    1f44:	f0 e0       	ldi	r31, 0x00	; 0
    1f46:	80 81       	ld	r24, Z
    1f48:	88 2f       	mov	r24, r24
    1f4a:	90 e0       	ldi	r25, 0x00	; 0
    1f4c:	80 72       	andi	r24, 0x20	; 32
    1f4e:	90 70       	andi	r25, 0x00	; 0
    1f50:	00 97       	sbiw	r24, 0x00	; 0
    1f52:	b9 f3       	breq	.-18     	; 0x1f42 <UART_sendChar+0xc>

    UDR = data;
    1f54:	ec e2       	ldi	r30, 0x2C	; 44
    1f56:	f0 e0       	ldi	r31, 0x00	; 0
    1f58:	89 81       	ldd	r24, Y+1	; 0x01
    1f5a:	80 83       	st	Z, r24
}
    1f5c:	0f 90       	pop	r0
    1f5e:	cf 91       	pop	r28
    1f60:	df 91       	pop	r29
    1f62:	08 95       	ret

00001f64 <UART_sendString>:
void UART_sendString(const char *str) {
    1f64:	df 93       	push	r29
    1f66:	cf 93       	push	r28
    1f68:	00 d0       	rcall	.+0      	; 0x1f6a <UART_sendString+0x6>
    1f6a:	cd b7       	in	r28, 0x3d	; 61
    1f6c:	de b7       	in	r29, 0x3e	; 62
    1f6e:	9a 83       	std	Y+2, r25	; 0x02
    1f70:	89 83       	std	Y+1, r24	; 0x01
    1f72:	0b c0       	rjmp	.+22     	; 0x1f8a <UART_sendString+0x26>
    while (*str) {
        UART_sendChar(*str++);
    1f74:	e9 81       	ldd	r30, Y+1	; 0x01
    1f76:	fa 81       	ldd	r31, Y+2	; 0x02
    1f78:	20 81       	ld	r18, Z
    1f7a:	89 81       	ldd	r24, Y+1	; 0x01
    1f7c:	9a 81       	ldd	r25, Y+2	; 0x02
    1f7e:	01 96       	adiw	r24, 0x01	; 1
    1f80:	9a 83       	std	Y+2, r25	; 0x02
    1f82:	89 83       	std	Y+1, r24	; 0x01
    1f84:	82 2f       	mov	r24, r18
    1f86:	0e 94 9b 0f 	call	0x1f36	; 0x1f36 <UART_sendChar>
    while (!( UCSRA & (1<<UDRE)));

    UDR = data;
}
void UART_sendString(const char *str) {
    while (*str) {
    1f8a:	e9 81       	ldd	r30, Y+1	; 0x01
    1f8c:	fa 81       	ldd	r31, Y+2	; 0x02
    1f8e:	80 81       	ld	r24, Z
    1f90:	88 23       	and	r24, r24
    1f92:	81 f7       	brne	.-32     	; 0x1f74 <UART_sendString+0x10>
        UART_sendChar(*str++);
    }
}
    1f94:	0f 90       	pop	r0
    1f96:	0f 90       	pop	r0
    1f98:	cf 91       	pop	r28
    1f9a:	df 91       	pop	r29
    1f9c:	08 95       	ret

00001f9e <PassengerYellowLED_On>:
void PassengerYellowLED_On(void) {
    1f9e:	df 93       	push	r29
    1fa0:	cf 93       	push	r28
    1fa2:	cd b7       	in	r28, 0x3d	; 61
    1fa4:	de b7       	in	r29, 0x3e	; 62
    PORTC |= (1 << PC0);  // Set PC0 high to turn on the Yellow LED
    1fa6:	a5 e3       	ldi	r26, 0x35	; 53
    1fa8:	b0 e0       	ldi	r27, 0x00	; 0
    1faa:	e5 e3       	ldi	r30, 0x35	; 53
    1fac:	f0 e0       	ldi	r31, 0x00	; 0
    1fae:	80 81       	ld	r24, Z
    1fb0:	81 60       	ori	r24, 0x01	; 1
    1fb2:	8c 93       	st	X, r24
}
    1fb4:	cf 91       	pop	r28
    1fb6:	df 91       	pop	r29
    1fb8:	08 95       	ret

00001fba <PassengerYellowLED_Off>:

void PassengerYellowLED_Off(void) {
    1fba:	df 93       	push	r29
    1fbc:	cf 93       	push	r28
    1fbe:	cd b7       	in	r28, 0x3d	; 61
    1fc0:	de b7       	in	r29, 0x3e	; 62
    PORTC &= ~(1 << PC0);  // Set PC0 low to turn off the Yellow LED
    1fc2:	a5 e3       	ldi	r26, 0x35	; 53
    1fc4:	b0 e0       	ldi	r27, 0x00	; 0
    1fc6:	e5 e3       	ldi	r30, 0x35	; 53
    1fc8:	f0 e0       	ldi	r31, 0x00	; 0
    1fca:	80 81       	ld	r24, Z
    1fcc:	8e 7f       	andi	r24, 0xFE	; 254
    1fce:	8c 93       	st	X, r24
}
    1fd0:	cf 91       	pop	r28
    1fd2:	df 91       	pop	r29
    1fd4:	08 95       	ret

00001fd6 <PassengerBlueLED_On>:

// Passenger Blue LED (connected to PC1)
void PassengerBlueLED_On(void) {
    1fd6:	df 93       	push	r29
    1fd8:	cf 93       	push	r28
    1fda:	cd b7       	in	r28, 0x3d	; 61
    1fdc:	de b7       	in	r29, 0x3e	; 62
    PORTC |= (1 << PC1);  // Set PC1 high to turn on the Blue LED
    1fde:	a5 e3       	ldi	r26, 0x35	; 53
    1fe0:	b0 e0       	ldi	r27, 0x00	; 0
    1fe2:	e5 e3       	ldi	r30, 0x35	; 53
    1fe4:	f0 e0       	ldi	r31, 0x00	; 0
    1fe6:	80 81       	ld	r24, Z
    1fe8:	82 60       	ori	r24, 0x02	; 2
    1fea:	8c 93       	st	X, r24
}
    1fec:	cf 91       	pop	r28
    1fee:	df 91       	pop	r29
    1ff0:	08 95       	ret

00001ff2 <PassengerBlueLED_Off>:

void PassengerBlueLED_Off(void) {
    1ff2:	df 93       	push	r29
    1ff4:	cf 93       	push	r28
    1ff6:	cd b7       	in	r28, 0x3d	; 61
    1ff8:	de b7       	in	r29, 0x3e	; 62
    PORTC &= ~(1 << PC1);  // Set PC1 low to turn off the Blue LED
    1ffa:	a5 e3       	ldi	r26, 0x35	; 53
    1ffc:	b0 e0       	ldi	r27, 0x00	; 0
    1ffe:	e5 e3       	ldi	r30, 0x35	; 53
    2000:	f0 e0       	ldi	r31, 0x00	; 0
    2002:	80 81       	ld	r24, Z
    2004:	8d 7f       	andi	r24, 0xFD	; 253
    2006:	8c 93       	st	X, r24
}
    2008:	cf 91       	pop	r28
    200a:	df 91       	pop	r29
    200c:	08 95       	ret

0000200e <PassengerGreenLED_On>:

// Passenger Green LED (connected to PC2)
void PassengerGreenLED_On(void) {
    200e:	df 93       	push	r29
    2010:	cf 93       	push	r28
    2012:	cd b7       	in	r28, 0x3d	; 61
    2014:	de b7       	in	r29, 0x3e	; 62
    PORTC |= (1 << PC2);  // Set PC2 high to turn on the Green LED
    2016:	a5 e3       	ldi	r26, 0x35	; 53
    2018:	b0 e0       	ldi	r27, 0x00	; 0
    201a:	e5 e3       	ldi	r30, 0x35	; 53
    201c:	f0 e0       	ldi	r31, 0x00	; 0
    201e:	80 81       	ld	r24, Z
    2020:	84 60       	ori	r24, 0x04	; 4
    2022:	8c 93       	st	X, r24
}
    2024:	cf 91       	pop	r28
    2026:	df 91       	pop	r29
    2028:	08 95       	ret

0000202a <PassengerGreenLED_Off>:

void PassengerGreenLED_Off(void) {
    202a:	df 93       	push	r29
    202c:	cf 93       	push	r28
    202e:	cd b7       	in	r28, 0x3d	; 61
    2030:	de b7       	in	r29, 0x3e	; 62
    PORTC &= ~(1 << PC2);  // Set PC2 low to turn off the Green LED
    2032:	a5 e3       	ldi	r26, 0x35	; 53
    2034:	b0 e0       	ldi	r27, 0x00	; 0
    2036:	e5 e3       	ldi	r30, 0x35	; 53
    2038:	f0 e0       	ldi	r31, 0x00	; 0
    203a:	80 81       	ld	r24, Z
    203c:	8b 7f       	andi	r24, 0xFB	; 251
    203e:	8c 93       	st	X, r24
}
    2040:	cf 91       	pop	r28
    2042:	df 91       	pop	r29
    2044:	08 95       	ret

00002046 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    2046:	df 93       	push	r29
    2048:	cf 93       	push	r28
    204a:	cd b7       	in	r28, 0x3d	; 61
    204c:	de b7       	in	r29, 0x3e	; 62
    204e:	28 97       	sbiw	r28, 0x08	; 8
    2050:	0f b6       	in	r0, 0x3f	; 63
    2052:	f8 94       	cli
    2054:	de bf       	out	0x3e, r29	; 62
    2056:	0f be       	out	0x3f, r0	; 63
    2058:	cd bf       	out	0x3d, r28	; 61
    205a:	9c 83       	std	Y+4, r25	; 0x04
    205c:	8b 83       	std	Y+3, r24	; 0x03
    205e:	7e 83       	std	Y+6, r23	; 0x06
    2060:	6d 83       	std	Y+5, r22	; 0x05
    2062:	58 87       	std	Y+8, r21	; 0x08
    2064:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    2066:	eb 81       	ldd	r30, Y+3	; 0x03
    2068:	fc 81       	ldd	r31, Y+4	; 0x04
    206a:	81 e1       	ldi	r24, 0x11	; 17
    206c:	80 83       	st	Z, r24
	pxTopOfStack--;
    206e:	8b 81       	ldd	r24, Y+3	; 0x03
    2070:	9c 81       	ldd	r25, Y+4	; 0x04
    2072:	01 97       	sbiw	r24, 0x01	; 1
    2074:	9c 83       	std	Y+4, r25	; 0x04
    2076:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    2078:	eb 81       	ldd	r30, Y+3	; 0x03
    207a:	fc 81       	ldd	r31, Y+4	; 0x04
    207c:	82 e2       	ldi	r24, 0x22	; 34
    207e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2080:	8b 81       	ldd	r24, Y+3	; 0x03
    2082:	9c 81       	ldd	r25, Y+4	; 0x04
    2084:	01 97       	sbiw	r24, 0x01	; 1
    2086:	9c 83       	std	Y+4, r25	; 0x04
    2088:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    208a:	eb 81       	ldd	r30, Y+3	; 0x03
    208c:	fc 81       	ldd	r31, Y+4	; 0x04
    208e:	83 e3       	ldi	r24, 0x33	; 51
    2090:	80 83       	st	Z, r24
	pxTopOfStack--;
    2092:	8b 81       	ldd	r24, Y+3	; 0x03
    2094:	9c 81       	ldd	r25, Y+4	; 0x04
    2096:	01 97       	sbiw	r24, 0x01	; 1
    2098:	9c 83       	std	Y+4, r25	; 0x04
    209a:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    209c:	8d 81       	ldd	r24, Y+5	; 0x05
    209e:	9e 81       	ldd	r25, Y+6	; 0x06
    20a0:	9a 83       	std	Y+2, r25	; 0x02
    20a2:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    20a4:	89 81       	ldd	r24, Y+1	; 0x01
    20a6:	eb 81       	ldd	r30, Y+3	; 0x03
    20a8:	fc 81       	ldd	r31, Y+4	; 0x04
    20aa:	80 83       	st	Z, r24
	pxTopOfStack--;
    20ac:	8b 81       	ldd	r24, Y+3	; 0x03
    20ae:	9c 81       	ldd	r25, Y+4	; 0x04
    20b0:	01 97       	sbiw	r24, 0x01	; 1
    20b2:	9c 83       	std	Y+4, r25	; 0x04
    20b4:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    20b6:	89 81       	ldd	r24, Y+1	; 0x01
    20b8:	9a 81       	ldd	r25, Y+2	; 0x02
    20ba:	89 2f       	mov	r24, r25
    20bc:	99 27       	eor	r25, r25
    20be:	9a 83       	std	Y+2, r25	; 0x02
    20c0:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    20c2:	89 81       	ldd	r24, Y+1	; 0x01
    20c4:	eb 81       	ldd	r30, Y+3	; 0x03
    20c6:	fc 81       	ldd	r31, Y+4	; 0x04
    20c8:	80 83       	st	Z, r24
	pxTopOfStack--;
    20ca:	8b 81       	ldd	r24, Y+3	; 0x03
    20cc:	9c 81       	ldd	r25, Y+4	; 0x04
    20ce:	01 97       	sbiw	r24, 0x01	; 1
    20d0:	9c 83       	std	Y+4, r25	; 0x04
    20d2:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    20d4:	eb 81       	ldd	r30, Y+3	; 0x03
    20d6:	fc 81       	ldd	r31, Y+4	; 0x04
    20d8:	10 82       	st	Z, r1
	pxTopOfStack--;
    20da:	8b 81       	ldd	r24, Y+3	; 0x03
    20dc:	9c 81       	ldd	r25, Y+4	; 0x04
    20de:	01 97       	sbiw	r24, 0x01	; 1
    20e0:	9c 83       	std	Y+4, r25	; 0x04
    20e2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    20e4:	eb 81       	ldd	r30, Y+3	; 0x03
    20e6:	fc 81       	ldd	r31, Y+4	; 0x04
    20e8:	80 e8       	ldi	r24, 0x80	; 128
    20ea:	80 83       	st	Z, r24
	pxTopOfStack--;
    20ec:	8b 81       	ldd	r24, Y+3	; 0x03
    20ee:	9c 81       	ldd	r25, Y+4	; 0x04
    20f0:	01 97       	sbiw	r24, 0x01	; 1
    20f2:	9c 83       	std	Y+4, r25	; 0x04
    20f4:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    20f6:	eb 81       	ldd	r30, Y+3	; 0x03
    20f8:	fc 81       	ldd	r31, Y+4	; 0x04
    20fa:	10 82       	st	Z, r1
	pxTopOfStack--;
    20fc:	8b 81       	ldd	r24, Y+3	; 0x03
    20fe:	9c 81       	ldd	r25, Y+4	; 0x04
    2100:	01 97       	sbiw	r24, 0x01	; 1
    2102:	9c 83       	std	Y+4, r25	; 0x04
    2104:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    2106:	eb 81       	ldd	r30, Y+3	; 0x03
    2108:	fc 81       	ldd	r31, Y+4	; 0x04
    210a:	82 e0       	ldi	r24, 0x02	; 2
    210c:	80 83       	st	Z, r24
	pxTopOfStack--;
    210e:	8b 81       	ldd	r24, Y+3	; 0x03
    2110:	9c 81       	ldd	r25, Y+4	; 0x04
    2112:	01 97       	sbiw	r24, 0x01	; 1
    2114:	9c 83       	std	Y+4, r25	; 0x04
    2116:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    2118:	eb 81       	ldd	r30, Y+3	; 0x03
    211a:	fc 81       	ldd	r31, Y+4	; 0x04
    211c:	83 e0       	ldi	r24, 0x03	; 3
    211e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2120:	8b 81       	ldd	r24, Y+3	; 0x03
    2122:	9c 81       	ldd	r25, Y+4	; 0x04
    2124:	01 97       	sbiw	r24, 0x01	; 1
    2126:	9c 83       	std	Y+4, r25	; 0x04
    2128:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    212a:	eb 81       	ldd	r30, Y+3	; 0x03
    212c:	fc 81       	ldd	r31, Y+4	; 0x04
    212e:	84 e0       	ldi	r24, 0x04	; 4
    2130:	80 83       	st	Z, r24
	pxTopOfStack--;
    2132:	8b 81       	ldd	r24, Y+3	; 0x03
    2134:	9c 81       	ldd	r25, Y+4	; 0x04
    2136:	01 97       	sbiw	r24, 0x01	; 1
    2138:	9c 83       	std	Y+4, r25	; 0x04
    213a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    213c:	eb 81       	ldd	r30, Y+3	; 0x03
    213e:	fc 81       	ldd	r31, Y+4	; 0x04
    2140:	85 e0       	ldi	r24, 0x05	; 5
    2142:	80 83       	st	Z, r24
	pxTopOfStack--;
    2144:	8b 81       	ldd	r24, Y+3	; 0x03
    2146:	9c 81       	ldd	r25, Y+4	; 0x04
    2148:	01 97       	sbiw	r24, 0x01	; 1
    214a:	9c 83       	std	Y+4, r25	; 0x04
    214c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    214e:	eb 81       	ldd	r30, Y+3	; 0x03
    2150:	fc 81       	ldd	r31, Y+4	; 0x04
    2152:	86 e0       	ldi	r24, 0x06	; 6
    2154:	80 83       	st	Z, r24
	pxTopOfStack--;
    2156:	8b 81       	ldd	r24, Y+3	; 0x03
    2158:	9c 81       	ldd	r25, Y+4	; 0x04
    215a:	01 97       	sbiw	r24, 0x01	; 1
    215c:	9c 83       	std	Y+4, r25	; 0x04
    215e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    2160:	eb 81       	ldd	r30, Y+3	; 0x03
    2162:	fc 81       	ldd	r31, Y+4	; 0x04
    2164:	87 e0       	ldi	r24, 0x07	; 7
    2166:	80 83       	st	Z, r24
	pxTopOfStack--;
    2168:	8b 81       	ldd	r24, Y+3	; 0x03
    216a:	9c 81       	ldd	r25, Y+4	; 0x04
    216c:	01 97       	sbiw	r24, 0x01	; 1
    216e:	9c 83       	std	Y+4, r25	; 0x04
    2170:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    2172:	eb 81       	ldd	r30, Y+3	; 0x03
    2174:	fc 81       	ldd	r31, Y+4	; 0x04
    2176:	88 e0       	ldi	r24, 0x08	; 8
    2178:	80 83       	st	Z, r24
	pxTopOfStack--;
    217a:	8b 81       	ldd	r24, Y+3	; 0x03
    217c:	9c 81       	ldd	r25, Y+4	; 0x04
    217e:	01 97       	sbiw	r24, 0x01	; 1
    2180:	9c 83       	std	Y+4, r25	; 0x04
    2182:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    2184:	eb 81       	ldd	r30, Y+3	; 0x03
    2186:	fc 81       	ldd	r31, Y+4	; 0x04
    2188:	89 e0       	ldi	r24, 0x09	; 9
    218a:	80 83       	st	Z, r24
	pxTopOfStack--;
    218c:	8b 81       	ldd	r24, Y+3	; 0x03
    218e:	9c 81       	ldd	r25, Y+4	; 0x04
    2190:	01 97       	sbiw	r24, 0x01	; 1
    2192:	9c 83       	std	Y+4, r25	; 0x04
    2194:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    2196:	eb 81       	ldd	r30, Y+3	; 0x03
    2198:	fc 81       	ldd	r31, Y+4	; 0x04
    219a:	80 e1       	ldi	r24, 0x10	; 16
    219c:	80 83       	st	Z, r24
	pxTopOfStack--;
    219e:	8b 81       	ldd	r24, Y+3	; 0x03
    21a0:	9c 81       	ldd	r25, Y+4	; 0x04
    21a2:	01 97       	sbiw	r24, 0x01	; 1
    21a4:	9c 83       	std	Y+4, r25	; 0x04
    21a6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    21a8:	eb 81       	ldd	r30, Y+3	; 0x03
    21aa:	fc 81       	ldd	r31, Y+4	; 0x04
    21ac:	81 e1       	ldi	r24, 0x11	; 17
    21ae:	80 83       	st	Z, r24
	pxTopOfStack--;
    21b0:	8b 81       	ldd	r24, Y+3	; 0x03
    21b2:	9c 81       	ldd	r25, Y+4	; 0x04
    21b4:	01 97       	sbiw	r24, 0x01	; 1
    21b6:	9c 83       	std	Y+4, r25	; 0x04
    21b8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    21ba:	eb 81       	ldd	r30, Y+3	; 0x03
    21bc:	fc 81       	ldd	r31, Y+4	; 0x04
    21be:	82 e1       	ldi	r24, 0x12	; 18
    21c0:	80 83       	st	Z, r24
	pxTopOfStack--;
    21c2:	8b 81       	ldd	r24, Y+3	; 0x03
    21c4:	9c 81       	ldd	r25, Y+4	; 0x04
    21c6:	01 97       	sbiw	r24, 0x01	; 1
    21c8:	9c 83       	std	Y+4, r25	; 0x04
    21ca:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    21cc:	eb 81       	ldd	r30, Y+3	; 0x03
    21ce:	fc 81       	ldd	r31, Y+4	; 0x04
    21d0:	83 e1       	ldi	r24, 0x13	; 19
    21d2:	80 83       	st	Z, r24
	pxTopOfStack--;
    21d4:	8b 81       	ldd	r24, Y+3	; 0x03
    21d6:	9c 81       	ldd	r25, Y+4	; 0x04
    21d8:	01 97       	sbiw	r24, 0x01	; 1
    21da:	9c 83       	std	Y+4, r25	; 0x04
    21dc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    21de:	eb 81       	ldd	r30, Y+3	; 0x03
    21e0:	fc 81       	ldd	r31, Y+4	; 0x04
    21e2:	84 e1       	ldi	r24, 0x14	; 20
    21e4:	80 83       	st	Z, r24
	pxTopOfStack--;
    21e6:	8b 81       	ldd	r24, Y+3	; 0x03
    21e8:	9c 81       	ldd	r25, Y+4	; 0x04
    21ea:	01 97       	sbiw	r24, 0x01	; 1
    21ec:	9c 83       	std	Y+4, r25	; 0x04
    21ee:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    21f0:	eb 81       	ldd	r30, Y+3	; 0x03
    21f2:	fc 81       	ldd	r31, Y+4	; 0x04
    21f4:	85 e1       	ldi	r24, 0x15	; 21
    21f6:	80 83       	st	Z, r24
	pxTopOfStack--;
    21f8:	8b 81       	ldd	r24, Y+3	; 0x03
    21fa:	9c 81       	ldd	r25, Y+4	; 0x04
    21fc:	01 97       	sbiw	r24, 0x01	; 1
    21fe:	9c 83       	std	Y+4, r25	; 0x04
    2200:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    2202:	eb 81       	ldd	r30, Y+3	; 0x03
    2204:	fc 81       	ldd	r31, Y+4	; 0x04
    2206:	86 e1       	ldi	r24, 0x16	; 22
    2208:	80 83       	st	Z, r24
	pxTopOfStack--;
    220a:	8b 81       	ldd	r24, Y+3	; 0x03
    220c:	9c 81       	ldd	r25, Y+4	; 0x04
    220e:	01 97       	sbiw	r24, 0x01	; 1
    2210:	9c 83       	std	Y+4, r25	; 0x04
    2212:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    2214:	eb 81       	ldd	r30, Y+3	; 0x03
    2216:	fc 81       	ldd	r31, Y+4	; 0x04
    2218:	87 e1       	ldi	r24, 0x17	; 23
    221a:	80 83       	st	Z, r24
	pxTopOfStack--;
    221c:	8b 81       	ldd	r24, Y+3	; 0x03
    221e:	9c 81       	ldd	r25, Y+4	; 0x04
    2220:	01 97       	sbiw	r24, 0x01	; 1
    2222:	9c 83       	std	Y+4, r25	; 0x04
    2224:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    2226:	eb 81       	ldd	r30, Y+3	; 0x03
    2228:	fc 81       	ldd	r31, Y+4	; 0x04
    222a:	88 e1       	ldi	r24, 0x18	; 24
    222c:	80 83       	st	Z, r24
	pxTopOfStack--;
    222e:	8b 81       	ldd	r24, Y+3	; 0x03
    2230:	9c 81       	ldd	r25, Y+4	; 0x04
    2232:	01 97       	sbiw	r24, 0x01	; 1
    2234:	9c 83       	std	Y+4, r25	; 0x04
    2236:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    2238:	eb 81       	ldd	r30, Y+3	; 0x03
    223a:	fc 81       	ldd	r31, Y+4	; 0x04
    223c:	89 e1       	ldi	r24, 0x19	; 25
    223e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2240:	8b 81       	ldd	r24, Y+3	; 0x03
    2242:	9c 81       	ldd	r25, Y+4	; 0x04
    2244:	01 97       	sbiw	r24, 0x01	; 1
    2246:	9c 83       	std	Y+4, r25	; 0x04
    2248:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    224a:	eb 81       	ldd	r30, Y+3	; 0x03
    224c:	fc 81       	ldd	r31, Y+4	; 0x04
    224e:	80 e2       	ldi	r24, 0x20	; 32
    2250:	80 83       	st	Z, r24
	pxTopOfStack--;
    2252:	8b 81       	ldd	r24, Y+3	; 0x03
    2254:	9c 81       	ldd	r25, Y+4	; 0x04
    2256:	01 97       	sbiw	r24, 0x01	; 1
    2258:	9c 83       	std	Y+4, r25	; 0x04
    225a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    225c:	eb 81       	ldd	r30, Y+3	; 0x03
    225e:	fc 81       	ldd	r31, Y+4	; 0x04
    2260:	81 e2       	ldi	r24, 0x21	; 33
    2262:	80 83       	st	Z, r24
	pxTopOfStack--;
    2264:	8b 81       	ldd	r24, Y+3	; 0x03
    2266:	9c 81       	ldd	r25, Y+4	; 0x04
    2268:	01 97       	sbiw	r24, 0x01	; 1
    226a:	9c 83       	std	Y+4, r25	; 0x04
    226c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    226e:	eb 81       	ldd	r30, Y+3	; 0x03
    2270:	fc 81       	ldd	r31, Y+4	; 0x04
    2272:	82 e2       	ldi	r24, 0x22	; 34
    2274:	80 83       	st	Z, r24
	pxTopOfStack--;
    2276:	8b 81       	ldd	r24, Y+3	; 0x03
    2278:	9c 81       	ldd	r25, Y+4	; 0x04
    227a:	01 97       	sbiw	r24, 0x01	; 1
    227c:	9c 83       	std	Y+4, r25	; 0x04
    227e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    2280:	eb 81       	ldd	r30, Y+3	; 0x03
    2282:	fc 81       	ldd	r31, Y+4	; 0x04
    2284:	83 e2       	ldi	r24, 0x23	; 35
    2286:	80 83       	st	Z, r24
	pxTopOfStack--;
    2288:	8b 81       	ldd	r24, Y+3	; 0x03
    228a:	9c 81       	ldd	r25, Y+4	; 0x04
    228c:	01 97       	sbiw	r24, 0x01	; 1
    228e:	9c 83       	std	Y+4, r25	; 0x04
    2290:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    2292:	8f 81       	ldd	r24, Y+7	; 0x07
    2294:	98 85       	ldd	r25, Y+8	; 0x08
    2296:	9a 83       	std	Y+2, r25	; 0x02
    2298:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    229a:	89 81       	ldd	r24, Y+1	; 0x01
    229c:	eb 81       	ldd	r30, Y+3	; 0x03
    229e:	fc 81       	ldd	r31, Y+4	; 0x04
    22a0:	80 83       	st	Z, r24
	pxTopOfStack--;
    22a2:	8b 81       	ldd	r24, Y+3	; 0x03
    22a4:	9c 81       	ldd	r25, Y+4	; 0x04
    22a6:	01 97       	sbiw	r24, 0x01	; 1
    22a8:	9c 83       	std	Y+4, r25	; 0x04
    22aa:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    22ac:	89 81       	ldd	r24, Y+1	; 0x01
    22ae:	9a 81       	ldd	r25, Y+2	; 0x02
    22b0:	89 2f       	mov	r24, r25
    22b2:	99 27       	eor	r25, r25
    22b4:	9a 83       	std	Y+2, r25	; 0x02
    22b6:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    22b8:	89 81       	ldd	r24, Y+1	; 0x01
    22ba:	eb 81       	ldd	r30, Y+3	; 0x03
    22bc:	fc 81       	ldd	r31, Y+4	; 0x04
    22be:	80 83       	st	Z, r24
	pxTopOfStack--;
    22c0:	8b 81       	ldd	r24, Y+3	; 0x03
    22c2:	9c 81       	ldd	r25, Y+4	; 0x04
    22c4:	01 97       	sbiw	r24, 0x01	; 1
    22c6:	9c 83       	std	Y+4, r25	; 0x04
    22c8:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    22ca:	eb 81       	ldd	r30, Y+3	; 0x03
    22cc:	fc 81       	ldd	r31, Y+4	; 0x04
    22ce:	86 e2       	ldi	r24, 0x26	; 38
    22d0:	80 83       	st	Z, r24
	pxTopOfStack--;
    22d2:	8b 81       	ldd	r24, Y+3	; 0x03
    22d4:	9c 81       	ldd	r25, Y+4	; 0x04
    22d6:	01 97       	sbiw	r24, 0x01	; 1
    22d8:	9c 83       	std	Y+4, r25	; 0x04
    22da:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    22dc:	eb 81       	ldd	r30, Y+3	; 0x03
    22de:	fc 81       	ldd	r31, Y+4	; 0x04
    22e0:	87 e2       	ldi	r24, 0x27	; 39
    22e2:	80 83       	st	Z, r24
	pxTopOfStack--;
    22e4:	8b 81       	ldd	r24, Y+3	; 0x03
    22e6:	9c 81       	ldd	r25, Y+4	; 0x04
    22e8:	01 97       	sbiw	r24, 0x01	; 1
    22ea:	9c 83       	std	Y+4, r25	; 0x04
    22ec:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    22ee:	eb 81       	ldd	r30, Y+3	; 0x03
    22f0:	fc 81       	ldd	r31, Y+4	; 0x04
    22f2:	88 e2       	ldi	r24, 0x28	; 40
    22f4:	80 83       	st	Z, r24
	pxTopOfStack--;
    22f6:	8b 81       	ldd	r24, Y+3	; 0x03
    22f8:	9c 81       	ldd	r25, Y+4	; 0x04
    22fa:	01 97       	sbiw	r24, 0x01	; 1
    22fc:	9c 83       	std	Y+4, r25	; 0x04
    22fe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    2300:	eb 81       	ldd	r30, Y+3	; 0x03
    2302:	fc 81       	ldd	r31, Y+4	; 0x04
    2304:	89 e2       	ldi	r24, 0x29	; 41
    2306:	80 83       	st	Z, r24
	pxTopOfStack--;
    2308:	8b 81       	ldd	r24, Y+3	; 0x03
    230a:	9c 81       	ldd	r25, Y+4	; 0x04
    230c:	01 97       	sbiw	r24, 0x01	; 1
    230e:	9c 83       	std	Y+4, r25	; 0x04
    2310:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    2312:	eb 81       	ldd	r30, Y+3	; 0x03
    2314:	fc 81       	ldd	r31, Y+4	; 0x04
    2316:	80 e3       	ldi	r24, 0x30	; 48
    2318:	80 83       	st	Z, r24
	pxTopOfStack--;
    231a:	8b 81       	ldd	r24, Y+3	; 0x03
    231c:	9c 81       	ldd	r25, Y+4	; 0x04
    231e:	01 97       	sbiw	r24, 0x01	; 1
    2320:	9c 83       	std	Y+4, r25	; 0x04
    2322:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    2324:	eb 81       	ldd	r30, Y+3	; 0x03
    2326:	fc 81       	ldd	r31, Y+4	; 0x04
    2328:	81 e3       	ldi	r24, 0x31	; 49
    232a:	80 83       	st	Z, r24
	pxTopOfStack--;
    232c:	8b 81       	ldd	r24, Y+3	; 0x03
    232e:	9c 81       	ldd	r25, Y+4	; 0x04
    2330:	01 97       	sbiw	r24, 0x01	; 1
    2332:	9c 83       	std	Y+4, r25	; 0x04
    2334:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    2336:	8b 81       	ldd	r24, Y+3	; 0x03
    2338:	9c 81       	ldd	r25, Y+4	; 0x04
}
    233a:	28 96       	adiw	r28, 0x08	; 8
    233c:	0f b6       	in	r0, 0x3f	; 63
    233e:	f8 94       	cli
    2340:	de bf       	out	0x3e, r29	; 62
    2342:	0f be       	out	0x3f, r0	; 63
    2344:	cd bf       	out	0x3d, r28	; 61
    2346:	cf 91       	pop	r28
    2348:	df 91       	pop	r29
    234a:	08 95       	ret

0000234c <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    234c:	df 93       	push	r29
    234e:	cf 93       	push	r28
    2350:	cd b7       	in	r28, 0x3d	; 61
    2352:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    2354:	0e 94 98 12 	call	0x2530	; 0x2530 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    2358:	a0 91 82 07 	lds	r26, 0x0782
    235c:	b0 91 83 07 	lds	r27, 0x0783
    2360:	cd 91       	ld	r28, X+
    2362:	cd bf       	out	0x3d, r28	; 61
    2364:	dd 91       	ld	r29, X+
    2366:	de bf       	out	0x3e, r29	; 62
    2368:	ff 91       	pop	r31
    236a:	ef 91       	pop	r30
    236c:	df 91       	pop	r29
    236e:	cf 91       	pop	r28
    2370:	bf 91       	pop	r27
    2372:	af 91       	pop	r26
    2374:	9f 91       	pop	r25
    2376:	8f 91       	pop	r24
    2378:	7f 91       	pop	r23
    237a:	6f 91       	pop	r22
    237c:	5f 91       	pop	r21
    237e:	4f 91       	pop	r20
    2380:	3f 91       	pop	r19
    2382:	2f 91       	pop	r18
    2384:	1f 91       	pop	r17
    2386:	0f 91       	pop	r16
    2388:	ff 90       	pop	r15
    238a:	ef 90       	pop	r14
    238c:	df 90       	pop	r13
    238e:	cf 90       	pop	r12
    2390:	bf 90       	pop	r11
    2392:	af 90       	pop	r10
    2394:	9f 90       	pop	r9
    2396:	8f 90       	pop	r8
    2398:	7f 90       	pop	r7
    239a:	6f 90       	pop	r6
    239c:	5f 90       	pop	r5
    239e:	4f 90       	pop	r4
    23a0:	3f 90       	pop	r3
    23a2:	2f 90       	pop	r2
    23a4:	1f 90       	pop	r1
    23a6:	0f 90       	pop	r0
    23a8:	0f be       	out	0x3f, r0	; 63
    23aa:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    23ac:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    23ae:	81 e0       	ldi	r24, 0x01	; 1
}
    23b0:	cf 91       	pop	r28
    23b2:	df 91       	pop	r29
    23b4:	08 95       	ret

000023b6 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    23b6:	df 93       	push	r29
    23b8:	cf 93       	push	r28
    23ba:	cd b7       	in	r28, 0x3d	; 61
    23bc:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    23be:	cf 91       	pop	r28
    23c0:	df 91       	pop	r29
    23c2:	08 95       	ret

000023c4 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    23c4:	0f 92       	push	r0
    23c6:	0f b6       	in	r0, 0x3f	; 63
    23c8:	f8 94       	cli
    23ca:	0f 92       	push	r0
    23cc:	1f 92       	push	r1
    23ce:	11 24       	eor	r1, r1
    23d0:	2f 92       	push	r2
    23d2:	3f 92       	push	r3
    23d4:	4f 92       	push	r4
    23d6:	5f 92       	push	r5
    23d8:	6f 92       	push	r6
    23da:	7f 92       	push	r7
    23dc:	8f 92       	push	r8
    23de:	9f 92       	push	r9
    23e0:	af 92       	push	r10
    23e2:	bf 92       	push	r11
    23e4:	cf 92       	push	r12
    23e6:	df 92       	push	r13
    23e8:	ef 92       	push	r14
    23ea:	ff 92       	push	r15
    23ec:	0f 93       	push	r16
    23ee:	1f 93       	push	r17
    23f0:	2f 93       	push	r18
    23f2:	3f 93       	push	r19
    23f4:	4f 93       	push	r20
    23f6:	5f 93       	push	r21
    23f8:	6f 93       	push	r22
    23fa:	7f 93       	push	r23
    23fc:	8f 93       	push	r24
    23fe:	9f 93       	push	r25
    2400:	af 93       	push	r26
    2402:	bf 93       	push	r27
    2404:	cf 93       	push	r28
    2406:	df 93       	push	r29
    2408:	ef 93       	push	r30
    240a:	ff 93       	push	r31
    240c:	a0 91 82 07 	lds	r26, 0x0782
    2410:	b0 91 83 07 	lds	r27, 0x0783
    2414:	0d b6       	in	r0, 0x3d	; 61
    2416:	0d 92       	st	X+, r0
    2418:	0e b6       	in	r0, 0x3e	; 62
    241a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    241c:	0e 94 06 29 	call	0x520c	; 0x520c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2420:	a0 91 82 07 	lds	r26, 0x0782
    2424:	b0 91 83 07 	lds	r27, 0x0783
    2428:	cd 91       	ld	r28, X+
    242a:	cd bf       	out	0x3d, r28	; 61
    242c:	dd 91       	ld	r29, X+
    242e:	de bf       	out	0x3e, r29	; 62
    2430:	ff 91       	pop	r31
    2432:	ef 91       	pop	r30
    2434:	df 91       	pop	r29
    2436:	cf 91       	pop	r28
    2438:	bf 91       	pop	r27
    243a:	af 91       	pop	r26
    243c:	9f 91       	pop	r25
    243e:	8f 91       	pop	r24
    2440:	7f 91       	pop	r23
    2442:	6f 91       	pop	r22
    2444:	5f 91       	pop	r21
    2446:	4f 91       	pop	r20
    2448:	3f 91       	pop	r19
    244a:	2f 91       	pop	r18
    244c:	1f 91       	pop	r17
    244e:	0f 91       	pop	r16
    2450:	ff 90       	pop	r15
    2452:	ef 90       	pop	r14
    2454:	df 90       	pop	r13
    2456:	cf 90       	pop	r12
    2458:	bf 90       	pop	r11
    245a:	af 90       	pop	r10
    245c:	9f 90       	pop	r9
    245e:	8f 90       	pop	r8
    2460:	7f 90       	pop	r7
    2462:	6f 90       	pop	r6
    2464:	5f 90       	pop	r5
    2466:	4f 90       	pop	r4
    2468:	3f 90       	pop	r3
    246a:	2f 90       	pop	r2
    246c:	1f 90       	pop	r1
    246e:	0f 90       	pop	r0
    2470:	0f be       	out	0x3f, r0	; 63
    2472:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2474:	08 95       	ret

00002476 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2476:	0f 92       	push	r0
    2478:	0f b6       	in	r0, 0x3f	; 63
    247a:	f8 94       	cli
    247c:	0f 92       	push	r0
    247e:	1f 92       	push	r1
    2480:	11 24       	eor	r1, r1
    2482:	2f 92       	push	r2
    2484:	3f 92       	push	r3
    2486:	4f 92       	push	r4
    2488:	5f 92       	push	r5
    248a:	6f 92       	push	r6
    248c:	7f 92       	push	r7
    248e:	8f 92       	push	r8
    2490:	9f 92       	push	r9
    2492:	af 92       	push	r10
    2494:	bf 92       	push	r11
    2496:	cf 92       	push	r12
    2498:	df 92       	push	r13
    249a:	ef 92       	push	r14
    249c:	ff 92       	push	r15
    249e:	0f 93       	push	r16
    24a0:	1f 93       	push	r17
    24a2:	2f 93       	push	r18
    24a4:	3f 93       	push	r19
    24a6:	4f 93       	push	r20
    24a8:	5f 93       	push	r21
    24aa:	6f 93       	push	r22
    24ac:	7f 93       	push	r23
    24ae:	8f 93       	push	r24
    24b0:	9f 93       	push	r25
    24b2:	af 93       	push	r26
    24b4:	bf 93       	push	r27
    24b6:	cf 93       	push	r28
    24b8:	df 93       	push	r29
    24ba:	ef 93       	push	r30
    24bc:	ff 93       	push	r31
    24be:	a0 91 82 07 	lds	r26, 0x0782
    24c2:	b0 91 83 07 	lds	r27, 0x0783
    24c6:	0d b6       	in	r0, 0x3d	; 61
    24c8:	0d 92       	st	X+, r0
    24ca:	0e b6       	in	r0, 0x3e	; 62
    24cc:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    24ce:	0e 94 21 28 	call	0x5042	; 0x5042 <xTaskIncrementTick>
    24d2:	88 23       	and	r24, r24
    24d4:	11 f0       	breq	.+4      	; 0x24da <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    24d6:	0e 94 06 29 	call	0x520c	; 0x520c <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    24da:	a0 91 82 07 	lds	r26, 0x0782
    24de:	b0 91 83 07 	lds	r27, 0x0783
    24e2:	cd 91       	ld	r28, X+
    24e4:	cd bf       	out	0x3d, r28	; 61
    24e6:	dd 91       	ld	r29, X+
    24e8:	de bf       	out	0x3e, r29	; 62
    24ea:	ff 91       	pop	r31
    24ec:	ef 91       	pop	r30
    24ee:	df 91       	pop	r29
    24f0:	cf 91       	pop	r28
    24f2:	bf 91       	pop	r27
    24f4:	af 91       	pop	r26
    24f6:	9f 91       	pop	r25
    24f8:	8f 91       	pop	r24
    24fa:	7f 91       	pop	r23
    24fc:	6f 91       	pop	r22
    24fe:	5f 91       	pop	r21
    2500:	4f 91       	pop	r20
    2502:	3f 91       	pop	r19
    2504:	2f 91       	pop	r18
    2506:	1f 91       	pop	r17
    2508:	0f 91       	pop	r16
    250a:	ff 90       	pop	r15
    250c:	ef 90       	pop	r14
    250e:	df 90       	pop	r13
    2510:	cf 90       	pop	r12
    2512:	bf 90       	pop	r11
    2514:	af 90       	pop	r10
    2516:	9f 90       	pop	r9
    2518:	8f 90       	pop	r8
    251a:	7f 90       	pop	r7
    251c:	6f 90       	pop	r6
    251e:	5f 90       	pop	r5
    2520:	4f 90       	pop	r4
    2522:	3f 90       	pop	r3
    2524:	2f 90       	pop	r2
    2526:	1f 90       	pop	r1
    2528:	0f 90       	pop	r0
    252a:	0f be       	out	0x3f, r0	; 63
    252c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    252e:	08 95       	ret

00002530 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    2530:	df 93       	push	r29
    2532:	cf 93       	push	r28
    2534:	00 d0       	rcall	.+0      	; 0x2536 <prvSetupTimerInterrupt+0x6>
    2536:	00 d0       	rcall	.+0      	; 0x2538 <prvSetupTimerInterrupt+0x8>
    2538:	00 d0       	rcall	.+0      	; 0x253a <prvSetupTimerInterrupt+0xa>
    253a:	cd b7       	in	r28, 0x3d	; 61
    253c:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    253e:	80 e8       	ldi	r24, 0x80	; 128
    2540:	9e e3       	ldi	r25, 0x3E	; 62
    2542:	a0 e0       	ldi	r26, 0x00	; 0
    2544:	b0 e0       	ldi	r27, 0x00	; 0
    2546:	8b 83       	std	Y+3, r24	; 0x03
    2548:	9c 83       	std	Y+4, r25	; 0x04
    254a:	ad 83       	std	Y+5, r26	; 0x05
    254c:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    254e:	8b 81       	ldd	r24, Y+3	; 0x03
    2550:	9c 81       	ldd	r25, Y+4	; 0x04
    2552:	ad 81       	ldd	r26, Y+5	; 0x05
    2554:	be 81       	ldd	r27, Y+6	; 0x06
    2556:	68 94       	set
    2558:	15 f8       	bld	r1, 5
    255a:	b6 95       	lsr	r27
    255c:	a7 95       	ror	r26
    255e:	97 95       	ror	r25
    2560:	87 95       	ror	r24
    2562:	16 94       	lsr	r1
    2564:	d1 f7       	brne	.-12     	; 0x255a <prvSetupTimerInterrupt+0x2a>
    2566:	8b 83       	std	Y+3, r24	; 0x03
    2568:	9c 83       	std	Y+4, r25	; 0x04
    256a:	ad 83       	std	Y+5, r26	; 0x05
    256c:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    256e:	8b 81       	ldd	r24, Y+3	; 0x03
    2570:	9c 81       	ldd	r25, Y+4	; 0x04
    2572:	ad 81       	ldd	r26, Y+5	; 0x05
    2574:	be 81       	ldd	r27, Y+6	; 0x06
    2576:	01 97       	sbiw	r24, 0x01	; 1
    2578:	a1 09       	sbc	r26, r1
    257a:	b1 09       	sbc	r27, r1
    257c:	8b 83       	std	Y+3, r24	; 0x03
    257e:	9c 83       	std	Y+4, r25	; 0x04
    2580:	ad 83       	std	Y+5, r26	; 0x05
    2582:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    2584:	8b 81       	ldd	r24, Y+3	; 0x03
    2586:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    2588:	8b 81       	ldd	r24, Y+3	; 0x03
    258a:	9c 81       	ldd	r25, Y+4	; 0x04
    258c:	ad 81       	ldd	r26, Y+5	; 0x05
    258e:	be 81       	ldd	r27, Y+6	; 0x06
    2590:	89 2f       	mov	r24, r25
    2592:	9a 2f       	mov	r25, r26
    2594:	ab 2f       	mov	r26, r27
    2596:	bb 27       	eor	r27, r27
    2598:	8b 83       	std	Y+3, r24	; 0x03
    259a:	9c 83       	std	Y+4, r25	; 0x04
    259c:	ad 83       	std	Y+5, r26	; 0x05
    259e:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    25a0:	8b 81       	ldd	r24, Y+3	; 0x03
    25a2:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    25a4:	eb e4       	ldi	r30, 0x4B	; 75
    25a6:	f0 e0       	ldi	r31, 0x00	; 0
    25a8:	8a 81       	ldd	r24, Y+2	; 0x02
    25aa:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    25ac:	ea e4       	ldi	r30, 0x4A	; 74
    25ae:	f0 e0       	ldi	r31, 0x00	; 0
    25b0:	89 81       	ldd	r24, Y+1	; 0x01
    25b2:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    25b4:	8b e0       	ldi	r24, 0x0B	; 11
    25b6:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    25b8:	ee e4       	ldi	r30, 0x4E	; 78
    25ba:	f0 e0       	ldi	r31, 0x00	; 0
    25bc:	89 81       	ldd	r24, Y+1	; 0x01
    25be:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    25c0:	e9 e5       	ldi	r30, 0x59	; 89
    25c2:	f0 e0       	ldi	r31, 0x00	; 0
    25c4:	80 81       	ld	r24, Z
    25c6:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    25c8:	89 81       	ldd	r24, Y+1	; 0x01
    25ca:	80 61       	ori	r24, 0x10	; 16
    25cc:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    25ce:	e9 e5       	ldi	r30, 0x59	; 89
    25d0:	f0 e0       	ldi	r31, 0x00	; 0
    25d2:	89 81       	ldd	r24, Y+1	; 0x01
    25d4:	80 83       	st	Z, r24
}
    25d6:	26 96       	adiw	r28, 0x06	; 6
    25d8:	0f b6       	in	r0, 0x3f	; 63
    25da:	f8 94       	cli
    25dc:	de bf       	out	0x3e, r29	; 62
    25de:	0f be       	out	0x3f, r0	; 63
    25e0:	cd bf       	out	0x3d, r28	; 61
    25e2:	cf 91       	pop	r28
    25e4:	df 91       	pop	r29
    25e6:	08 95       	ret

000025e8 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    25e8:	0e 94 3b 12 	call	0x2476	; 0x2476 <vPortYieldFromTick>
		asm volatile ( "reti" );
    25ec:	18 95       	reti

000025ee <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    25ee:	df 93       	push	r29
    25f0:	cf 93       	push	r28
    25f2:	00 d0       	rcall	.+0      	; 0x25f4 <xQueueGenericReset+0x6>
    25f4:	00 d0       	rcall	.+0      	; 0x25f6 <xQueueGenericReset+0x8>
    25f6:	0f 92       	push	r0
    25f8:	cd b7       	in	r28, 0x3d	; 61
    25fa:	de b7       	in	r29, 0x3e	; 62
    25fc:	9c 83       	std	Y+4, r25	; 0x04
    25fe:	8b 83       	std	Y+3, r24	; 0x03
    2600:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = xQueue;
    2602:	8b 81       	ldd	r24, Y+3	; 0x03
    2604:	9c 81       	ldd	r25, Y+4	; 0x04
    2606:	9a 83       	std	Y+2, r25	; 0x02
    2608:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    260a:	0f b6       	in	r0, 0x3f	; 63
    260c:	f8 94       	cli
    260e:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    2610:	e9 81       	ldd	r30, Y+1	; 0x01
    2612:	fa 81       	ldd	r31, Y+2	; 0x02
    2614:	40 81       	ld	r20, Z
    2616:	51 81       	ldd	r21, Z+1	; 0x01
    2618:	e9 81       	ldd	r30, Y+1	; 0x01
    261a:	fa 81       	ldd	r31, Y+2	; 0x02
    261c:	83 8d       	ldd	r24, Z+27	; 0x1b
    261e:	28 2f       	mov	r18, r24
    2620:	30 e0       	ldi	r19, 0x00	; 0
    2622:	e9 81       	ldd	r30, Y+1	; 0x01
    2624:	fa 81       	ldd	r31, Y+2	; 0x02
    2626:	84 8d       	ldd	r24, Z+28	; 0x1c
    2628:	88 2f       	mov	r24, r24
    262a:	90 e0       	ldi	r25, 0x00	; 0
    262c:	bc 01       	movw	r22, r24
    262e:	26 9f       	mul	r18, r22
    2630:	c0 01       	movw	r24, r0
    2632:	27 9f       	mul	r18, r23
    2634:	90 0d       	add	r25, r0
    2636:	36 9f       	mul	r19, r22
    2638:	90 0d       	add	r25, r0
    263a:	11 24       	eor	r1, r1
    263c:	84 0f       	add	r24, r20
    263e:	95 1f       	adc	r25, r21
    2640:	e9 81       	ldd	r30, Y+1	; 0x01
    2642:	fa 81       	ldd	r31, Y+2	; 0x02
    2644:	95 83       	std	Z+5, r25	; 0x05
    2646:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    2648:	e9 81       	ldd	r30, Y+1	; 0x01
    264a:	fa 81       	ldd	r31, Y+2	; 0x02
    264c:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    264e:	e9 81       	ldd	r30, Y+1	; 0x01
    2650:	fa 81       	ldd	r31, Y+2	; 0x02
    2652:	80 81       	ld	r24, Z
    2654:	91 81       	ldd	r25, Z+1	; 0x01
    2656:	e9 81       	ldd	r30, Y+1	; 0x01
    2658:	fa 81       	ldd	r31, Y+2	; 0x02
    265a:	93 83       	std	Z+3, r25	; 0x03
    265c:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    265e:	e9 81       	ldd	r30, Y+1	; 0x01
    2660:	fa 81       	ldd	r31, Y+2	; 0x02
    2662:	40 81       	ld	r20, Z
    2664:	51 81       	ldd	r21, Z+1	; 0x01
    2666:	e9 81       	ldd	r30, Y+1	; 0x01
    2668:	fa 81       	ldd	r31, Y+2	; 0x02
    266a:	83 8d       	ldd	r24, Z+27	; 0x1b
    266c:	88 2f       	mov	r24, r24
    266e:	90 e0       	ldi	r25, 0x00	; 0
    2670:	9c 01       	movw	r18, r24
    2672:	21 50       	subi	r18, 0x01	; 1
    2674:	30 40       	sbci	r19, 0x00	; 0
    2676:	e9 81       	ldd	r30, Y+1	; 0x01
    2678:	fa 81       	ldd	r31, Y+2	; 0x02
    267a:	84 8d       	ldd	r24, Z+28	; 0x1c
    267c:	88 2f       	mov	r24, r24
    267e:	90 e0       	ldi	r25, 0x00	; 0
    2680:	bc 01       	movw	r22, r24
    2682:	26 9f       	mul	r18, r22
    2684:	c0 01       	movw	r24, r0
    2686:	27 9f       	mul	r18, r23
    2688:	90 0d       	add	r25, r0
    268a:	36 9f       	mul	r19, r22
    268c:	90 0d       	add	r25, r0
    268e:	11 24       	eor	r1, r1
    2690:	84 0f       	add	r24, r20
    2692:	95 1f       	adc	r25, r21
    2694:	e9 81       	ldd	r30, Y+1	; 0x01
    2696:	fa 81       	ldd	r31, Y+2	; 0x02
    2698:	97 83       	std	Z+7, r25	; 0x07
    269a:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    269c:	e9 81       	ldd	r30, Y+1	; 0x01
    269e:	fa 81       	ldd	r31, Y+2	; 0x02
    26a0:	8f ef       	ldi	r24, 0xFF	; 255
    26a2:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    26a4:	e9 81       	ldd	r30, Y+1	; 0x01
    26a6:	fa 81       	ldd	r31, Y+2	; 0x02
    26a8:	8f ef       	ldi	r24, 0xFF	; 255
    26aa:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    26ac:	8d 81       	ldd	r24, Y+5	; 0x05
    26ae:	88 23       	and	r24, r24
    26b0:	79 f4       	brne	.+30     	; 0x26d0 <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    26b2:	e9 81       	ldd	r30, Y+1	; 0x01
    26b4:	fa 81       	ldd	r31, Y+2	; 0x02
    26b6:	80 85       	ldd	r24, Z+8	; 0x08
    26b8:	88 23       	and	r24, r24
    26ba:	a1 f0       	breq	.+40     	; 0x26e4 <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    26bc:	89 81       	ldd	r24, Y+1	; 0x01
    26be:	9a 81       	ldd	r25, Y+2	; 0x02
    26c0:	08 96       	adiw	r24, 0x08	; 8
    26c2:	0e 94 c5 29 	call	0x538a	; 0x538a <xTaskRemoveFromEventList>
    26c6:	88 23       	and	r24, r24
    26c8:	69 f0       	breq	.+26     	; 0x26e4 <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    26ca:	0e 94 e2 11 	call	0x23c4	; 0x23c4 <vPortYield>
    26ce:	0a c0       	rjmp	.+20     	; 0x26e4 <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    26d0:	89 81       	ldd	r24, Y+1	; 0x01
    26d2:	9a 81       	ldd	r25, Y+2	; 0x02
    26d4:	08 96       	adiw	r24, 0x08	; 8
    26d6:	0e 94 7e 09 	call	0x12fc	; 0x12fc <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    26da:	89 81       	ldd	r24, Y+1	; 0x01
    26dc:	9a 81       	ldd	r25, Y+2	; 0x02
    26de:	41 96       	adiw	r24, 0x11	; 17
    26e0:	0e 94 7e 09 	call	0x12fc	; 0x12fc <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    26e4:	0f 90       	pop	r0
    26e6:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    26e8:	81 e0       	ldi	r24, 0x01	; 1
}
    26ea:	0f 90       	pop	r0
    26ec:	0f 90       	pop	r0
    26ee:	0f 90       	pop	r0
    26f0:	0f 90       	pop	r0
    26f2:	0f 90       	pop	r0
    26f4:	cf 91       	pop	r28
    26f6:	df 91       	pop	r29
    26f8:	08 95       	ret

000026fa <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    26fa:	0f 93       	push	r16
    26fc:	1f 93       	push	r17
    26fe:	df 93       	push	r29
    2700:	cf 93       	push	r28
    2702:	cd b7       	in	r28, 0x3d	; 61
    2704:	de b7       	in	r29, 0x3e	; 62
    2706:	29 97       	sbiw	r28, 0x09	; 9
    2708:	0f b6       	in	r0, 0x3f	; 63
    270a:	f8 94       	cli
    270c:	de bf       	out	0x3e, r29	; 62
    270e:	0f be       	out	0x3f, r0	; 63
    2710:	cd bf       	out	0x3d, r28	; 61
    2712:	8f 83       	std	Y+7, r24	; 0x07
    2714:	68 87       	std	Y+8, r22	; 0x08
    2716:	49 87       	std	Y+9, r20	; 0x09
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    2718:	88 85       	ldd	r24, Y+8	; 0x08
    271a:	88 23       	and	r24, r24
    271c:	19 f4       	brne	.+6      	; 0x2724 <xQueueGenericCreate+0x2a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    271e:	1c 82       	std	Y+4, r1	; 0x04
    2720:	1b 82       	std	Y+3, r1	; 0x03
    2722:	10 c0       	rjmp	.+32     	; 0x2744 <xQueueGenericCreate+0x4a>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2724:	8f 81       	ldd	r24, Y+7	; 0x07
    2726:	28 2f       	mov	r18, r24
    2728:	30 e0       	ldi	r19, 0x00	; 0
    272a:	88 85       	ldd	r24, Y+8	; 0x08
    272c:	88 2f       	mov	r24, r24
    272e:	90 e0       	ldi	r25, 0x00	; 0
    2730:	ac 01       	movw	r20, r24
    2732:	24 9f       	mul	r18, r20
    2734:	c0 01       	movw	r24, r0
    2736:	25 9f       	mul	r18, r21
    2738:	90 0d       	add	r25, r0
    273a:	34 9f       	mul	r19, r20
    273c:	90 0d       	add	r25, r0
    273e:	11 24       	eor	r1, r1
    2740:	9c 83       	std	Y+4, r25	; 0x04
    2742:	8b 83       	std	Y+3, r24	; 0x03
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    2744:	8b 81       	ldd	r24, Y+3	; 0x03
    2746:	9c 81       	ldd	r25, Y+4	; 0x04
    2748:	4f 96       	adiw	r24, 0x1f	; 31
    274a:	0e 94 02 09 	call	0x1204	; 0x1204 <pvPortMalloc>
    274e:	9e 83       	std	Y+6, r25	; 0x06
    2750:	8d 83       	std	Y+5, r24	; 0x05

		if( pxNewQueue != NULL )
    2752:	8d 81       	ldd	r24, Y+5	; 0x05
    2754:	9e 81       	ldd	r25, Y+6	; 0x06
    2756:	00 97       	sbiw	r24, 0x00	; 0
    2758:	a1 f0       	breq	.+40     	; 0x2782 <xQueueGenericCreate+0x88>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
    275a:	8d 81       	ldd	r24, Y+5	; 0x05
    275c:	9e 81       	ldd	r25, Y+6	; 0x06
    275e:	9a 83       	std	Y+2, r25	; 0x02
    2760:	89 83       	std	Y+1, r24	; 0x01
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    2762:	89 81       	ldd	r24, Y+1	; 0x01
    2764:	9a 81       	ldd	r25, Y+2	; 0x02
    2766:	4f 96       	adiw	r24, 0x1f	; 31
    2768:	9a 83       	std	Y+2, r25	; 0x02
    276a:	89 83       	std	Y+1, r24	; 0x01
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    276c:	29 81       	ldd	r18, Y+1	; 0x01
    276e:	3a 81       	ldd	r19, Y+2	; 0x02
    2770:	ed 81       	ldd	r30, Y+5	; 0x05
    2772:	fe 81       	ldd	r31, Y+6	; 0x06
    2774:	8f 81       	ldd	r24, Y+7	; 0x07
    2776:	68 85       	ldd	r22, Y+8	; 0x08
    2778:	a9 01       	movw	r20, r18
    277a:	29 85       	ldd	r18, Y+9	; 0x09
    277c:	8f 01       	movw	r16, r30
    277e:	0e 94 ce 13 	call	0x279c	; 0x279c <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
    2782:	8d 81       	ldd	r24, Y+5	; 0x05
    2784:	9e 81       	ldd	r25, Y+6	; 0x06
	}
    2786:	29 96       	adiw	r28, 0x09	; 9
    2788:	0f b6       	in	r0, 0x3f	; 63
    278a:	f8 94       	cli
    278c:	de bf       	out	0x3e, r29	; 62
    278e:	0f be       	out	0x3f, r0	; 63
    2790:	cd bf       	out	0x3d, r28	; 61
    2792:	cf 91       	pop	r28
    2794:	df 91       	pop	r29
    2796:	1f 91       	pop	r17
    2798:	0f 91       	pop	r16
    279a:	08 95       	ret

0000279c <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    279c:	0f 93       	push	r16
    279e:	1f 93       	push	r17
    27a0:	df 93       	push	r29
    27a2:	cf 93       	push	r28
    27a4:	cd b7       	in	r28, 0x3d	; 61
    27a6:	de b7       	in	r29, 0x3e	; 62
    27a8:	27 97       	sbiw	r28, 0x07	; 7
    27aa:	0f b6       	in	r0, 0x3f	; 63
    27ac:	f8 94       	cli
    27ae:	de bf       	out	0x3e, r29	; 62
    27b0:	0f be       	out	0x3f, r0	; 63
    27b2:	cd bf       	out	0x3d, r28	; 61
    27b4:	89 83       	std	Y+1, r24	; 0x01
    27b6:	6a 83       	std	Y+2, r22	; 0x02
    27b8:	5c 83       	std	Y+4, r21	; 0x04
    27ba:	4b 83       	std	Y+3, r20	; 0x03
    27bc:	2d 83       	std	Y+5, r18	; 0x05
    27be:	1f 83       	std	Y+7, r17	; 0x07
    27c0:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    27c2:	8a 81       	ldd	r24, Y+2	; 0x02
    27c4:	88 23       	and	r24, r24
    27c6:	39 f4       	brne	.+14     	; 0x27d6 <prvInitialiseNewQueue+0x3a>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    27c8:	8e 81       	ldd	r24, Y+6	; 0x06
    27ca:	9f 81       	ldd	r25, Y+7	; 0x07
    27cc:	ee 81       	ldd	r30, Y+6	; 0x06
    27ce:	ff 81       	ldd	r31, Y+7	; 0x07
    27d0:	91 83       	std	Z+1, r25	; 0x01
    27d2:	80 83       	st	Z, r24
    27d4:	06 c0       	rjmp	.+12     	; 0x27e2 <prvInitialiseNewQueue+0x46>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    27d6:	8b 81       	ldd	r24, Y+3	; 0x03
    27d8:	9c 81       	ldd	r25, Y+4	; 0x04
    27da:	ee 81       	ldd	r30, Y+6	; 0x06
    27dc:	ff 81       	ldd	r31, Y+7	; 0x07
    27de:	91 83       	std	Z+1, r25	; 0x01
    27e0:	80 83       	st	Z, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    27e2:	ee 81       	ldd	r30, Y+6	; 0x06
    27e4:	ff 81       	ldd	r31, Y+7	; 0x07
    27e6:	89 81       	ldd	r24, Y+1	; 0x01
    27e8:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    27ea:	ee 81       	ldd	r30, Y+6	; 0x06
    27ec:	ff 81       	ldd	r31, Y+7	; 0x07
    27ee:	8a 81       	ldd	r24, Y+2	; 0x02
    27f0:	84 8f       	std	Z+28, r24	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    27f2:	8e 81       	ldd	r24, Y+6	; 0x06
    27f4:	9f 81       	ldd	r25, Y+7	; 0x07
    27f6:	61 e0       	ldi	r22, 0x01	; 1
    27f8:	0e 94 f7 12 	call	0x25ee	; 0x25ee <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    27fc:	27 96       	adiw	r28, 0x07	; 7
    27fe:	0f b6       	in	r0, 0x3f	; 63
    2800:	f8 94       	cli
    2802:	de bf       	out	0x3e, r29	; 62
    2804:	0f be       	out	0x3f, r0	; 63
    2806:	cd bf       	out	0x3d, r28	; 61
    2808:	cf 91       	pop	r28
    280a:	df 91       	pop	r29
    280c:	1f 91       	pop	r17
    280e:	0f 91       	pop	r16
    2810:	08 95       	ret

00002812 <prvInitialiseMutex>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
    2812:	df 93       	push	r29
    2814:	cf 93       	push	r28
    2816:	00 d0       	rcall	.+0      	; 0x2818 <prvInitialiseMutex+0x6>
    2818:	cd b7       	in	r28, 0x3d	; 61
    281a:	de b7       	in	r29, 0x3e	; 62
    281c:	9a 83       	std	Y+2, r25	; 0x02
    281e:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewQueue != NULL )
    2820:	89 81       	ldd	r24, Y+1	; 0x01
    2822:	9a 81       	ldd	r25, Y+2	; 0x02
    2824:	00 97       	sbiw	r24, 0x00	; 0
    2826:	a1 f0       	breq	.+40     	; 0x2850 <prvInitialiseMutex+0x3e>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
    2828:	e9 81       	ldd	r30, Y+1	; 0x01
    282a:	fa 81       	ldd	r31, Y+2	; 0x02
    282c:	15 82       	std	Z+5, r1	; 0x05
    282e:	14 82       	std	Z+4, r1	; 0x04
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    2830:	e9 81       	ldd	r30, Y+1	; 0x01
    2832:	fa 81       	ldd	r31, Y+2	; 0x02
    2834:	11 82       	std	Z+1, r1	; 0x01
    2836:	10 82       	st	Z, r1

			/* In case this is a recursive mutex. */
			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
    2838:	e9 81       	ldd	r30, Y+1	; 0x01
    283a:	fa 81       	ldd	r31, Y+2	; 0x02
    283c:	16 82       	std	Z+6, r1	; 0x06

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    283e:	89 81       	ldd	r24, Y+1	; 0x01
    2840:	9a 81       	ldd	r25, Y+2	; 0x02
    2842:	60 e0       	ldi	r22, 0x00	; 0
    2844:	70 e0       	ldi	r23, 0x00	; 0
    2846:	40 e0       	ldi	r20, 0x00	; 0
    2848:	50 e0       	ldi	r21, 0x00	; 0
    284a:	20 e0       	ldi	r18, 0x00	; 0
    284c:	0e 94 4d 14 	call	0x289a	; 0x289a <xQueueGenericSend>
		}
		else
		{
			traceCREATE_MUTEX_FAILED();
		}
	}
    2850:	0f 90       	pop	r0
    2852:	0f 90       	pop	r0
    2854:	cf 91       	pop	r28
    2856:	df 91       	pop	r29
    2858:	08 95       	ret

0000285a <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    285a:	df 93       	push	r29
    285c:	cf 93       	push	r28
    285e:	00 d0       	rcall	.+0      	; 0x2860 <xQueueCreateMutex+0x6>
    2860:	00 d0       	rcall	.+0      	; 0x2862 <xQueueCreateMutex+0x8>
    2862:	0f 92       	push	r0
    2864:	cd b7       	in	r28, 0x3d	; 61
    2866:	de b7       	in	r29, 0x3e	; 62
    2868:	8d 83       	std	Y+5, r24	; 0x05
	QueueHandle_t xNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
    286a:	81 e0       	ldi	r24, 0x01	; 1
    286c:	8a 83       	std	Y+2, r24	; 0x02
    286e:	19 82       	std	Y+1, r1	; 0x01

		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
    2870:	8a 81       	ldd	r24, Y+2	; 0x02
    2872:	69 81       	ldd	r22, Y+1	; 0x01
    2874:	4d 81       	ldd	r20, Y+5	; 0x05
    2876:	0e 94 7d 13 	call	0x26fa	; 0x26fa <xQueueGenericCreate>
    287a:	9c 83       	std	Y+4, r25	; 0x04
    287c:	8b 83       	std	Y+3, r24	; 0x03
		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
    287e:	8b 81       	ldd	r24, Y+3	; 0x03
    2880:	9c 81       	ldd	r25, Y+4	; 0x04
    2882:	0e 94 09 14 	call	0x2812	; 0x2812 <prvInitialiseMutex>

		return xNewQueue;
    2886:	8b 81       	ldd	r24, Y+3	; 0x03
    2888:	9c 81       	ldd	r25, Y+4	; 0x04
	}
    288a:	0f 90       	pop	r0
    288c:	0f 90       	pop	r0
    288e:	0f 90       	pop	r0
    2890:	0f 90       	pop	r0
    2892:	0f 90       	pop	r0
    2894:	cf 91       	pop	r28
    2896:	df 91       	pop	r29
    2898:	08 95       	ret

0000289a <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    289a:	df 93       	push	r29
    289c:	cf 93       	push	r28
    289e:	cd b7       	in	r28, 0x3d	; 61
    28a0:	de b7       	in	r29, 0x3e	; 62
    28a2:	2f 97       	sbiw	r28, 0x0f	; 15
    28a4:	0f b6       	in	r0, 0x3f	; 63
    28a6:	f8 94       	cli
    28a8:	de bf       	out	0x3e, r29	; 62
    28aa:	0f be       	out	0x3f, r0	; 63
    28ac:	cd bf       	out	0x3d, r28	; 61
    28ae:	99 87       	std	Y+9, r25	; 0x09
    28b0:	88 87       	std	Y+8, r24	; 0x08
    28b2:	7b 87       	std	Y+11, r23	; 0x0b
    28b4:	6a 87       	std	Y+10, r22	; 0x0a
    28b6:	5d 87       	std	Y+13, r21	; 0x0d
    28b8:	4c 87       	std	Y+12, r20	; 0x0c
    28ba:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    28bc:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    28be:	88 85       	ldd	r24, Y+8	; 0x08
    28c0:	99 85       	ldd	r25, Y+9	; 0x09
    28c2:	9a 83       	std	Y+2, r25	; 0x02
    28c4:	89 83       	std	Y+1, r24	; 0x01
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    28c6:	0f b6       	in	r0, 0x3f	; 63
    28c8:	f8 94       	cli
    28ca:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    28cc:	e9 81       	ldd	r30, Y+1	; 0x01
    28ce:	fa 81       	ldd	r31, Y+2	; 0x02
    28d0:	92 8d       	ldd	r25, Z+26	; 0x1a
    28d2:	e9 81       	ldd	r30, Y+1	; 0x01
    28d4:	fa 81       	ldd	r31, Y+2	; 0x02
    28d6:	83 8d       	ldd	r24, Z+27	; 0x1b
    28d8:	98 17       	cp	r25, r24
    28da:	18 f0       	brcs	.+6      	; 0x28e2 <xQueueGenericSend+0x48>
    28dc:	8e 85       	ldd	r24, Y+14	; 0x0e
    28de:	82 30       	cpi	r24, 0x02	; 2
    28e0:	11 f5       	brne	.+68     	; 0x2926 <xQueueGenericSend+0x8c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    28e2:	89 81       	ldd	r24, Y+1	; 0x01
    28e4:	9a 81       	ldd	r25, Y+2	; 0x02
    28e6:	2a 85       	ldd	r18, Y+10	; 0x0a
    28e8:	3b 85       	ldd	r19, Y+11	; 0x0b
    28ea:	b9 01       	movw	r22, r18
    28ec:	4e 85       	ldd	r20, Y+14	; 0x0e
    28ee:	0e 94 f3 18 	call	0x31e6	; 0x31e6 <prvCopyDataToQueue>
    28f2:	8b 83       	std	Y+3, r24	; 0x03

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    28f4:	e9 81       	ldd	r30, Y+1	; 0x01
    28f6:	fa 81       	ldd	r31, Y+2	; 0x02
    28f8:	81 89       	ldd	r24, Z+17	; 0x11
    28fa:	88 23       	and	r24, r24
    28fc:	51 f0       	breq	.+20     	; 0x2912 <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    28fe:	89 81       	ldd	r24, Y+1	; 0x01
    2900:	9a 81       	ldd	r25, Y+2	; 0x02
    2902:	41 96       	adiw	r24, 0x11	; 17
    2904:	0e 94 c5 29 	call	0x538a	; 0x538a <xTaskRemoveFromEventList>
    2908:	88 23       	and	r24, r24
    290a:	41 f0       	breq	.+16     	; 0x291c <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    290c:	0e 94 e2 11 	call	0x23c4	; 0x23c4 <vPortYield>
    2910:	05 c0       	rjmp	.+10     	; 0x291c <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    2912:	8b 81       	ldd	r24, Y+3	; 0x03
    2914:	88 23       	and	r24, r24
    2916:	11 f0       	breq	.+4      	; 0x291c <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    2918:	0e 94 e2 11 	call	0x23c4	; 0x23c4 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    291c:	0f 90       	pop	r0
    291e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2920:	81 e0       	ldi	r24, 0x01	; 1
    2922:	8f 87       	std	Y+15, r24	; 0x0f
    2924:	5c c0       	rjmp	.+184    	; 0x29de <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2926:	8c 85       	ldd	r24, Y+12	; 0x0c
    2928:	9d 85       	ldd	r25, Y+13	; 0x0d
    292a:	00 97       	sbiw	r24, 0x00	; 0
    292c:	21 f4       	brne	.+8      	; 0x2936 <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    292e:	0f 90       	pop	r0
    2930:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    2932:	1f 86       	std	Y+15, r1	; 0x0f
    2934:	54 c0       	rjmp	.+168    	; 0x29de <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    2936:	8c 81       	ldd	r24, Y+4	; 0x04
    2938:	88 23       	and	r24, r24
    293a:	31 f4       	brne	.+12     	; 0x2948 <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    293c:	ce 01       	movw	r24, r28
    293e:	05 96       	adiw	r24, 0x05	; 5
    2940:	0e 94 ab 2a 	call	0x5556	; 0x5556 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2944:	81 e0       	ldi	r24, 0x01	; 1
    2946:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2948:	0f 90       	pop	r0
    294a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    294c:	0e 94 25 27 	call	0x4e4a	; 0x4e4a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2950:	0f b6       	in	r0, 0x3f	; 63
    2952:	f8 94       	cli
    2954:	0f 92       	push	r0
    2956:	e9 81       	ldd	r30, Y+1	; 0x01
    2958:	fa 81       	ldd	r31, Y+2	; 0x02
    295a:	85 8d       	ldd	r24, Z+29	; 0x1d
    295c:	8f 3f       	cpi	r24, 0xFF	; 255
    295e:	19 f4       	brne	.+6      	; 0x2966 <xQueueGenericSend+0xcc>
    2960:	e9 81       	ldd	r30, Y+1	; 0x01
    2962:	fa 81       	ldd	r31, Y+2	; 0x02
    2964:	15 8e       	std	Z+29, r1	; 0x1d
    2966:	e9 81       	ldd	r30, Y+1	; 0x01
    2968:	fa 81       	ldd	r31, Y+2	; 0x02
    296a:	86 8d       	ldd	r24, Z+30	; 0x1e
    296c:	8f 3f       	cpi	r24, 0xFF	; 255
    296e:	19 f4       	brne	.+6      	; 0x2976 <xQueueGenericSend+0xdc>
    2970:	e9 81       	ldd	r30, Y+1	; 0x01
    2972:	fa 81       	ldd	r31, Y+2	; 0x02
    2974:	16 8e       	std	Z+30, r1	; 0x1e
    2976:	0f 90       	pop	r0
    2978:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    297a:	ce 01       	movw	r24, r28
    297c:	05 96       	adiw	r24, 0x05	; 5
    297e:	9e 01       	movw	r18, r28
    2980:	24 5f       	subi	r18, 0xF4	; 244
    2982:	3f 4f       	sbci	r19, 0xFF	; 255
    2984:	b9 01       	movw	r22, r18
    2986:	0e 94 c4 2a 	call	0x5588	; 0x5588 <xTaskCheckForTimeOut>
    298a:	88 23       	and	r24, r24
    298c:	09 f5       	brne	.+66     	; 0x29d0 <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    298e:	89 81       	ldd	r24, Y+1	; 0x01
    2990:	9a 81       	ldd	r25, Y+2	; 0x02
    2992:	0e 94 81 1a 	call	0x3502	; 0x3502 <prvIsQueueFull>
    2996:	88 23       	and	r24, r24
    2998:	a1 f0       	breq	.+40     	; 0x29c2 <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    299a:	89 81       	ldd	r24, Y+1	; 0x01
    299c:	9a 81       	ldd	r25, Y+2	; 0x02
    299e:	08 96       	adiw	r24, 0x08	; 8
    29a0:	2c 85       	ldd	r18, Y+12	; 0x0c
    29a2:	3d 85       	ldd	r19, Y+13	; 0x0d
    29a4:	b9 01       	movw	r22, r18
    29a6:	0e 94 73 29 	call	0x52e6	; 0x52e6 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    29aa:	89 81       	ldd	r24, Y+1	; 0x01
    29ac:	9a 81       	ldd	r25, Y+2	; 0x02
    29ae:	0e 94 f2 19 	call	0x33e4	; 0x33e4 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    29b2:	0e 94 31 27 	call	0x4e62	; 0x4e62 <xTaskResumeAll>
    29b6:	88 23       	and	r24, r24
    29b8:	09 f0       	breq	.+2      	; 0x29bc <xQueueGenericSend+0x122>
    29ba:	85 cf       	rjmp	.-246    	; 0x28c6 <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    29bc:	0e 94 e2 11 	call	0x23c4	; 0x23c4 <vPortYield>
    29c0:	82 cf       	rjmp	.-252    	; 0x28c6 <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    29c2:	89 81       	ldd	r24, Y+1	; 0x01
    29c4:	9a 81       	ldd	r25, Y+2	; 0x02
    29c6:	0e 94 f2 19 	call	0x33e4	; 0x33e4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    29ca:	0e 94 31 27 	call	0x4e62	; 0x4e62 <xTaskResumeAll>
    29ce:	7b cf       	rjmp	.-266    	; 0x28c6 <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    29d0:	89 81       	ldd	r24, Y+1	; 0x01
    29d2:	9a 81       	ldd	r25, Y+2	; 0x02
    29d4:	0e 94 f2 19 	call	0x33e4	; 0x33e4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    29d8:	0e 94 31 27 	call	0x4e62	; 0x4e62 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    29dc:	1f 86       	std	Y+15, r1	; 0x0f
    29de:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	} /*lint -restore */
}
    29e0:	2f 96       	adiw	r28, 0x0f	; 15
    29e2:	0f b6       	in	r0, 0x3f	; 63
    29e4:	f8 94       	cli
    29e6:	de bf       	out	0x3e, r29	; 62
    29e8:	0f be       	out	0x3f, r0	; 63
    29ea:	cd bf       	out	0x3d, r28	; 61
    29ec:	cf 91       	pop	r28
    29ee:	df 91       	pop	r29
    29f0:	08 95       	ret

000029f2 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    29f2:	df 93       	push	r29
    29f4:	cf 93       	push	r28
    29f6:	cd b7       	in	r28, 0x3d	; 61
    29f8:	de b7       	in	r29, 0x3e	; 62
    29fa:	2c 97       	sbiw	r28, 0x0c	; 12
    29fc:	0f b6       	in	r0, 0x3f	; 63
    29fe:	f8 94       	cli
    2a00:	de bf       	out	0x3e, r29	; 62
    2a02:	0f be       	out	0x3f, r0	; 63
    2a04:	cd bf       	out	0x3d, r28	; 61
    2a06:	9f 83       	std	Y+7, r25	; 0x07
    2a08:	8e 83       	std	Y+6, r24	; 0x06
    2a0a:	79 87       	std	Y+9, r23	; 0x09
    2a0c:	68 87       	std	Y+8, r22	; 0x08
    2a0e:	5b 87       	std	Y+11, r21	; 0x0b
    2a10:	4a 87       	std	Y+10, r20	; 0x0a
    2a12:	2c 87       	std	Y+12, r18	; 0x0c
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    2a14:	8e 81       	ldd	r24, Y+6	; 0x06
    2a16:	9f 81       	ldd	r25, Y+7	; 0x07
    2a18:	9b 83       	std	Y+3, r25	; 0x03
    2a1a:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2a1c:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2a1e:	ea 81       	ldd	r30, Y+2	; 0x02
    2a20:	fb 81       	ldd	r31, Y+3	; 0x03
    2a22:	92 8d       	ldd	r25, Z+26	; 0x1a
    2a24:	ea 81       	ldd	r30, Y+2	; 0x02
    2a26:	fb 81       	ldd	r31, Y+3	; 0x03
    2a28:	83 8d       	ldd	r24, Z+27	; 0x1b
    2a2a:	98 17       	cp	r25, r24
    2a2c:	18 f0       	brcs	.+6      	; 0x2a34 <xQueueGenericSendFromISR+0x42>
    2a2e:	8c 85       	ldd	r24, Y+12	; 0x0c
    2a30:	82 30       	cpi	r24, 0x02	; 2
    2a32:	61 f5       	brne	.+88     	; 0x2a8c <xQueueGenericSendFromISR+0x9a>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    2a34:	ea 81       	ldd	r30, Y+2	; 0x02
    2a36:	fb 81       	ldd	r31, Y+3	; 0x03
    2a38:	86 8d       	ldd	r24, Z+30	; 0x1e
    2a3a:	89 83       	std	Y+1, r24	; 0x01
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2a3c:	8a 81       	ldd	r24, Y+2	; 0x02
    2a3e:	9b 81       	ldd	r25, Y+3	; 0x03
    2a40:	28 85       	ldd	r18, Y+8	; 0x08
    2a42:	39 85       	ldd	r19, Y+9	; 0x09
    2a44:	b9 01       	movw	r22, r18
    2a46:	4c 85       	ldd	r20, Y+12	; 0x0c
    2a48:	0e 94 f3 18 	call	0x31e6	; 0x31e6 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    2a4c:	89 81       	ldd	r24, Y+1	; 0x01
    2a4e:	8f 3f       	cpi	r24, 0xFF	; 255
    2a50:	a9 f4       	brne	.+42     	; 0x2a7c <xQueueGenericSendFromISR+0x8a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2a52:	ea 81       	ldd	r30, Y+2	; 0x02
    2a54:	fb 81       	ldd	r31, Y+3	; 0x03
    2a56:	81 89       	ldd	r24, Z+17	; 0x11
    2a58:	88 23       	and	r24, r24
    2a5a:	a9 f0       	breq	.+42     	; 0x2a86 <xQueueGenericSendFromISR+0x94>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2a5c:	8a 81       	ldd	r24, Y+2	; 0x02
    2a5e:	9b 81       	ldd	r25, Y+3	; 0x03
    2a60:	41 96       	adiw	r24, 0x11	; 17
    2a62:	0e 94 c5 29 	call	0x538a	; 0x538a <xTaskRemoveFromEventList>
    2a66:	88 23       	and	r24, r24
    2a68:	71 f0       	breq	.+28     	; 0x2a86 <xQueueGenericSendFromISR+0x94>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    2a6a:	8a 85       	ldd	r24, Y+10	; 0x0a
    2a6c:	9b 85       	ldd	r25, Y+11	; 0x0b
    2a6e:	00 97       	sbiw	r24, 0x00	; 0
    2a70:	51 f0       	breq	.+20     	; 0x2a86 <xQueueGenericSendFromISR+0x94>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    2a72:	ea 85       	ldd	r30, Y+10	; 0x0a
    2a74:	fb 85       	ldd	r31, Y+11	; 0x0b
    2a76:	81 e0       	ldi	r24, 0x01	; 1
    2a78:	80 83       	st	Z, r24
    2a7a:	05 c0       	rjmp	.+10     	; 0x2a86 <xQueueGenericSendFromISR+0x94>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    2a7c:	89 81       	ldd	r24, Y+1	; 0x01
    2a7e:	8f 5f       	subi	r24, 0xFF	; 255
    2a80:	ea 81       	ldd	r30, Y+2	; 0x02
    2a82:	fb 81       	ldd	r31, Y+3	; 0x03
    2a84:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    2a86:	81 e0       	ldi	r24, 0x01	; 1
    2a88:	8d 83       	std	Y+5, r24	; 0x05
    2a8a:	01 c0       	rjmp	.+2      	; 0x2a8e <xQueueGenericSendFromISR+0x9c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2a8c:	1d 82       	std	Y+5, r1	; 0x05
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2a8e:	8d 81       	ldd	r24, Y+5	; 0x05
}
    2a90:	2c 96       	adiw	r28, 0x0c	; 12
    2a92:	0f b6       	in	r0, 0x3f	; 63
    2a94:	f8 94       	cli
    2a96:	de bf       	out	0x3e, r29	; 62
    2a98:	0f be       	out	0x3f, r0	; 63
    2a9a:	cd bf       	out	0x3d, r28	; 61
    2a9c:	cf 91       	pop	r28
    2a9e:	df 91       	pop	r29
    2aa0:	08 95       	ret

00002aa2 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    2aa2:	df 93       	push	r29
    2aa4:	cf 93       	push	r28
    2aa6:	cd b7       	in	r28, 0x3d	; 61
    2aa8:	de b7       	in	r29, 0x3e	; 62
    2aaa:	2a 97       	sbiw	r28, 0x0a	; 10
    2aac:	0f b6       	in	r0, 0x3f	; 63
    2aae:	f8 94       	cli
    2ab0:	de bf       	out	0x3e, r29	; 62
    2ab2:	0f be       	out	0x3f, r0	; 63
    2ab4:	cd bf       	out	0x3d, r28	; 61
    2ab6:	98 87       	std	Y+8, r25	; 0x08
    2ab8:	8f 83       	std	Y+7, r24	; 0x07
    2aba:	7a 87       	std	Y+10, r23	; 0x0a
    2abc:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    2abe:	8f 81       	ldd	r24, Y+7	; 0x07
    2ac0:	98 85       	ldd	r25, Y+8	; 0x08
    2ac2:	9c 83       	std	Y+4, r25	; 0x04
    2ac4:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2ac6:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2ac8:	eb 81       	ldd	r30, Y+3	; 0x03
    2aca:	fc 81       	ldd	r31, Y+4	; 0x04
    2acc:	82 8d       	ldd	r24, Z+26	; 0x1a
    2ace:	8a 83       	std	Y+2, r24	; 0x02

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    2ad0:	eb 81       	ldd	r30, Y+3	; 0x03
    2ad2:	fc 81       	ldd	r31, Y+4	; 0x04
    2ad4:	93 8d       	ldd	r25, Z+27	; 0x1b
    2ad6:	8a 81       	ldd	r24, Y+2	; 0x02
    2ad8:	89 17       	cp	r24, r25
    2ada:	48 f5       	brcc	.+82     	; 0x2b2e <xQueueGiveFromISR+0x8c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    2adc:	eb 81       	ldd	r30, Y+3	; 0x03
    2ade:	fc 81       	ldd	r31, Y+4	; 0x04
    2ae0:	86 8d       	ldd	r24, Z+30	; 0x1e
    2ae2:	89 83       	std	Y+1, r24	; 0x01
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    2ae4:	8a 81       	ldd	r24, Y+2	; 0x02
    2ae6:	8f 5f       	subi	r24, 0xFF	; 255
    2ae8:	eb 81       	ldd	r30, Y+3	; 0x03
    2aea:	fc 81       	ldd	r31, Y+4	; 0x04
    2aec:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    2aee:	89 81       	ldd	r24, Y+1	; 0x01
    2af0:	8f 3f       	cpi	r24, 0xFF	; 255
    2af2:	a9 f4       	brne	.+42     	; 0x2b1e <xQueueGiveFromISR+0x7c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2af4:	eb 81       	ldd	r30, Y+3	; 0x03
    2af6:	fc 81       	ldd	r31, Y+4	; 0x04
    2af8:	81 89       	ldd	r24, Z+17	; 0x11
    2afa:	88 23       	and	r24, r24
    2afc:	a9 f0       	breq	.+42     	; 0x2b28 <xQueueGiveFromISR+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2afe:	8b 81       	ldd	r24, Y+3	; 0x03
    2b00:	9c 81       	ldd	r25, Y+4	; 0x04
    2b02:	41 96       	adiw	r24, 0x11	; 17
    2b04:	0e 94 c5 29 	call	0x538a	; 0x538a <xTaskRemoveFromEventList>
    2b08:	88 23       	and	r24, r24
    2b0a:	71 f0       	breq	.+28     	; 0x2b28 <xQueueGiveFromISR+0x86>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    2b0c:	89 85       	ldd	r24, Y+9	; 0x09
    2b0e:	9a 85       	ldd	r25, Y+10	; 0x0a
    2b10:	00 97       	sbiw	r24, 0x00	; 0
    2b12:	51 f0       	breq	.+20     	; 0x2b28 <xQueueGiveFromISR+0x86>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    2b14:	e9 85       	ldd	r30, Y+9	; 0x09
    2b16:	fa 85       	ldd	r31, Y+10	; 0x0a
    2b18:	81 e0       	ldi	r24, 0x01	; 1
    2b1a:	80 83       	st	Z, r24
    2b1c:	05 c0       	rjmp	.+10     	; 0x2b28 <xQueueGiveFromISR+0x86>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    2b1e:	89 81       	ldd	r24, Y+1	; 0x01
    2b20:	8f 5f       	subi	r24, 0xFF	; 255
    2b22:	eb 81       	ldd	r30, Y+3	; 0x03
    2b24:	fc 81       	ldd	r31, Y+4	; 0x04
    2b26:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    2b28:	81 e0       	ldi	r24, 0x01	; 1
    2b2a:	8e 83       	std	Y+6, r24	; 0x06
    2b2c:	01 c0       	rjmp	.+2      	; 0x2b30 <xQueueGiveFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2b2e:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2b30:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2b32:	2a 96       	adiw	r28, 0x0a	; 10
    2b34:	0f b6       	in	r0, 0x3f	; 63
    2b36:	f8 94       	cli
    2b38:	de bf       	out	0x3e, r29	; 62
    2b3a:	0f be       	out	0x3f, r0	; 63
    2b3c:	cd bf       	out	0x3d, r28	; 61
    2b3e:	cf 91       	pop	r28
    2b40:	df 91       	pop	r29
    2b42:	08 95       	ret

00002b44 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    2b44:	df 93       	push	r29
    2b46:	cf 93       	push	r28
    2b48:	cd b7       	in	r28, 0x3d	; 61
    2b4a:	de b7       	in	r29, 0x3e	; 62
    2b4c:	2e 97       	sbiw	r28, 0x0e	; 14
    2b4e:	0f b6       	in	r0, 0x3f	; 63
    2b50:	f8 94       	cli
    2b52:	de bf       	out	0x3e, r29	; 62
    2b54:	0f be       	out	0x3f, r0	; 63
    2b56:	cd bf       	out	0x3d, r28	; 61
    2b58:	99 87       	std	Y+9, r25	; 0x09
    2b5a:	88 87       	std	Y+8, r24	; 0x08
    2b5c:	7b 87       	std	Y+11, r23	; 0x0b
    2b5e:	6a 87       	std	Y+10, r22	; 0x0a
    2b60:	5d 87       	std	Y+13, r21	; 0x0d
    2b62:	4c 87       	std	Y+12, r20	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    2b64:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    2b66:	88 85       	ldd	r24, Y+8	; 0x08
    2b68:	99 85       	ldd	r25, Y+9	; 0x09
    2b6a:	9b 83       	std	Y+3, r25	; 0x03
    2b6c:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2b6e:	0f b6       	in	r0, 0x3f	; 63
    2b70:	f8 94       	cli
    2b72:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2b74:	ea 81       	ldd	r30, Y+2	; 0x02
    2b76:	fb 81       	ldd	r31, Y+3	; 0x03
    2b78:	82 8d       	ldd	r24, Z+26	; 0x1a
    2b7a:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2b7c:	89 81       	ldd	r24, Y+1	; 0x01
    2b7e:	88 23       	and	r24, r24
    2b80:	f9 f0       	breq	.+62     	; 0x2bc0 <xQueueReceive+0x7c>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    2b82:	8a 81       	ldd	r24, Y+2	; 0x02
    2b84:	9b 81       	ldd	r25, Y+3	; 0x03
    2b86:	2a 85       	ldd	r18, Y+10	; 0x0a
    2b88:	3b 85       	ldd	r19, Y+11	; 0x0b
    2b8a:	b9 01       	movw	r22, r18
    2b8c:	0e 94 ab 19 	call	0x3356	; 0x3356 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    2b90:	89 81       	ldd	r24, Y+1	; 0x01
    2b92:	81 50       	subi	r24, 0x01	; 1
    2b94:	ea 81       	ldd	r30, Y+2	; 0x02
    2b96:	fb 81       	ldd	r31, Y+3	; 0x03
    2b98:	82 8f       	std	Z+26, r24	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2b9a:	ea 81       	ldd	r30, Y+2	; 0x02
    2b9c:	fb 81       	ldd	r31, Y+3	; 0x03
    2b9e:	80 85       	ldd	r24, Z+8	; 0x08
    2ba0:	88 23       	and	r24, r24
    2ba2:	49 f0       	breq	.+18     	; 0x2bb6 <xQueueReceive+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2ba4:	8a 81       	ldd	r24, Y+2	; 0x02
    2ba6:	9b 81       	ldd	r25, Y+3	; 0x03
    2ba8:	08 96       	adiw	r24, 0x08	; 8
    2baa:	0e 94 c5 29 	call	0x538a	; 0x538a <xTaskRemoveFromEventList>
    2bae:	88 23       	and	r24, r24
    2bb0:	11 f0       	breq	.+4      	; 0x2bb6 <xQueueReceive+0x72>
					{
						queueYIELD_IF_USING_PREEMPTION();
    2bb2:	0e 94 e2 11 	call	0x23c4	; 0x23c4 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    2bb6:	0f 90       	pop	r0
    2bb8:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2bba:	81 e0       	ldi	r24, 0x01	; 1
    2bbc:	8e 87       	std	Y+14, r24	; 0x0e
    2bbe:	63 c0       	rjmp	.+198    	; 0x2c86 <xQueueReceive+0x142>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2bc0:	8c 85       	ldd	r24, Y+12	; 0x0c
    2bc2:	9d 85       	ldd	r25, Y+13	; 0x0d
    2bc4:	00 97       	sbiw	r24, 0x00	; 0
    2bc6:	21 f4       	brne	.+8      	; 0x2bd0 <xQueueReceive+0x8c>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2bc8:	0f 90       	pop	r0
    2bca:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2bcc:	1e 86       	std	Y+14, r1	; 0x0e
    2bce:	5b c0       	rjmp	.+182    	; 0x2c86 <xQueueReceive+0x142>
				}
				else if( xEntryTimeSet == pdFALSE )
    2bd0:	8c 81       	ldd	r24, Y+4	; 0x04
    2bd2:	88 23       	and	r24, r24
    2bd4:	31 f4       	brne	.+12     	; 0x2be2 <xQueueReceive+0x9e>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    2bd6:	ce 01       	movw	r24, r28
    2bd8:	05 96       	adiw	r24, 0x05	; 5
    2bda:	0e 94 ab 2a 	call	0x5556	; 0x5556 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2bde:	81 e0       	ldi	r24, 0x01	; 1
    2be0:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2be2:	0f 90       	pop	r0
    2be4:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2be6:	0e 94 25 27 	call	0x4e4a	; 0x4e4a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2bea:	0f b6       	in	r0, 0x3f	; 63
    2bec:	f8 94       	cli
    2bee:	0f 92       	push	r0
    2bf0:	ea 81       	ldd	r30, Y+2	; 0x02
    2bf2:	fb 81       	ldd	r31, Y+3	; 0x03
    2bf4:	85 8d       	ldd	r24, Z+29	; 0x1d
    2bf6:	8f 3f       	cpi	r24, 0xFF	; 255
    2bf8:	19 f4       	brne	.+6      	; 0x2c00 <xQueueReceive+0xbc>
    2bfa:	ea 81       	ldd	r30, Y+2	; 0x02
    2bfc:	fb 81       	ldd	r31, Y+3	; 0x03
    2bfe:	15 8e       	std	Z+29, r1	; 0x1d
    2c00:	ea 81       	ldd	r30, Y+2	; 0x02
    2c02:	fb 81       	ldd	r31, Y+3	; 0x03
    2c04:	86 8d       	ldd	r24, Z+30	; 0x1e
    2c06:	8f 3f       	cpi	r24, 0xFF	; 255
    2c08:	19 f4       	brne	.+6      	; 0x2c10 <xQueueReceive+0xcc>
    2c0a:	ea 81       	ldd	r30, Y+2	; 0x02
    2c0c:	fb 81       	ldd	r31, Y+3	; 0x03
    2c0e:	16 8e       	std	Z+30, r1	; 0x1e
    2c10:	0f 90       	pop	r0
    2c12:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2c14:	ce 01       	movw	r24, r28
    2c16:	05 96       	adiw	r24, 0x05	; 5
    2c18:	9e 01       	movw	r18, r28
    2c1a:	24 5f       	subi	r18, 0xF4	; 244
    2c1c:	3f 4f       	sbci	r19, 0xFF	; 255
    2c1e:	b9 01       	movw	r22, r18
    2c20:	0e 94 c4 2a 	call	0x5588	; 0x5588 <xTaskCheckForTimeOut>
    2c24:	88 23       	and	r24, r24
    2c26:	09 f5       	brne	.+66     	; 0x2c6a <xQueueReceive+0x126>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2c28:	8a 81       	ldd	r24, Y+2	; 0x02
    2c2a:	9b 81       	ldd	r25, Y+3	; 0x03
    2c2c:	0e 94 45 1a 	call	0x348a	; 0x348a <prvIsQueueEmpty>
    2c30:	88 23       	and	r24, r24
    2c32:	a1 f0       	breq	.+40     	; 0x2c5c <xQueueReceive+0x118>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2c34:	8a 81       	ldd	r24, Y+2	; 0x02
    2c36:	9b 81       	ldd	r25, Y+3	; 0x03
    2c38:	41 96       	adiw	r24, 0x11	; 17
    2c3a:	2c 85       	ldd	r18, Y+12	; 0x0c
    2c3c:	3d 85       	ldd	r19, Y+13	; 0x0d
    2c3e:	b9 01       	movw	r22, r18
    2c40:	0e 94 73 29 	call	0x52e6	; 0x52e6 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2c44:	8a 81       	ldd	r24, Y+2	; 0x02
    2c46:	9b 81       	ldd	r25, Y+3	; 0x03
    2c48:	0e 94 f2 19 	call	0x33e4	; 0x33e4 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2c4c:	0e 94 31 27 	call	0x4e62	; 0x4e62 <xTaskResumeAll>
    2c50:	88 23       	and	r24, r24
    2c52:	09 f0       	breq	.+2      	; 0x2c56 <xQueueReceive+0x112>
    2c54:	8c cf       	rjmp	.-232    	; 0x2b6e <xQueueReceive+0x2a>
				{
					portYIELD_WITHIN_API();
    2c56:	0e 94 e2 11 	call	0x23c4	; 0x23c4 <vPortYield>
    2c5a:	89 cf       	rjmp	.-238    	; 0x2b6e <xQueueReceive+0x2a>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    2c5c:	8a 81       	ldd	r24, Y+2	; 0x02
    2c5e:	9b 81       	ldd	r25, Y+3	; 0x03
    2c60:	0e 94 f2 19 	call	0x33e4	; 0x33e4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2c64:	0e 94 31 27 	call	0x4e62	; 0x4e62 <xTaskResumeAll>
    2c68:	82 cf       	rjmp	.-252    	; 0x2b6e <xQueueReceive+0x2a>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    2c6a:	8a 81       	ldd	r24, Y+2	; 0x02
    2c6c:	9b 81       	ldd	r25, Y+3	; 0x03
    2c6e:	0e 94 f2 19 	call	0x33e4	; 0x33e4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2c72:	0e 94 31 27 	call	0x4e62	; 0x4e62 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2c76:	8a 81       	ldd	r24, Y+2	; 0x02
    2c78:	9b 81       	ldd	r25, Y+3	; 0x03
    2c7a:	0e 94 45 1a 	call	0x348a	; 0x348a <prvIsQueueEmpty>
    2c7e:	88 23       	and	r24, r24
    2c80:	09 f4       	brne	.+2      	; 0x2c84 <xQueueReceive+0x140>
    2c82:	75 cf       	rjmp	.-278    	; 0x2b6e <xQueueReceive+0x2a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    2c84:	1e 86       	std	Y+14, r1	; 0x0e
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    2c86:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    2c88:	2e 96       	adiw	r28, 0x0e	; 14
    2c8a:	0f b6       	in	r0, 0x3f	; 63
    2c8c:	f8 94       	cli
    2c8e:	de bf       	out	0x3e, r29	; 62
    2c90:	0f be       	out	0x3f, r0	; 63
    2c92:	cd bf       	out	0x3d, r28	; 61
    2c94:	cf 91       	pop	r28
    2c96:	df 91       	pop	r29
    2c98:	08 95       	ret

00002c9a <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    2c9a:	df 93       	push	r29
    2c9c:	cf 93       	push	r28
    2c9e:	cd b7       	in	r28, 0x3d	; 61
    2ca0:	de b7       	in	r29, 0x3e	; 62
    2ca2:	2e 97       	sbiw	r28, 0x0e	; 14
    2ca4:	0f b6       	in	r0, 0x3f	; 63
    2ca6:	f8 94       	cli
    2ca8:	de bf       	out	0x3e, r29	; 62
    2caa:	0f be       	out	0x3f, r0	; 63
    2cac:	cd bf       	out	0x3d, r28	; 61
    2cae:	9b 87       	std	Y+11, r25	; 0x0b
    2cb0:	8a 87       	std	Y+10, r24	; 0x0a
    2cb2:	7d 87       	std	Y+13, r23	; 0x0d
    2cb4:	6c 87       	std	Y+12, r22	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    2cb6:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    2cb8:	8a 85       	ldd	r24, Y+10	; 0x0a
    2cba:	9b 85       	ldd	r25, Y+11	; 0x0b
    2cbc:	9d 83       	std	Y+5, r25	; 0x05
    2cbe:	8c 83       	std	Y+4, r24	; 0x04

#if( configUSE_MUTEXES == 1 )
	BaseType_t xInheritanceOccurred = pdFALSE;
    2cc0:	1b 82       	std	Y+3, r1	; 0x03
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2cc2:	0f b6       	in	r0, 0x3f	; 63
    2cc4:	f8 94       	cli
    2cc6:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    2cc8:	ec 81       	ldd	r30, Y+4	; 0x04
    2cca:	fd 81       	ldd	r31, Y+5	; 0x05
    2ccc:	82 8d       	ldd	r24, Z+26	; 0x1a
    2cce:	8a 83       	std	Y+2, r24	; 0x02

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    2cd0:	8a 81       	ldd	r24, Y+2	; 0x02
    2cd2:	88 23       	and	r24, r24
    2cd4:	21 f1       	breq	.+72     	; 0x2d1e <xQueueSemaphoreTake+0x84>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    2cd6:	8a 81       	ldd	r24, Y+2	; 0x02
    2cd8:	81 50       	subi	r24, 0x01	; 1
    2cda:	ec 81       	ldd	r30, Y+4	; 0x04
    2cdc:	fd 81       	ldd	r31, Y+5	; 0x05
    2cde:	82 8f       	std	Z+26, r24	; 0x1a

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2ce0:	ec 81       	ldd	r30, Y+4	; 0x04
    2ce2:	fd 81       	ldd	r31, Y+5	; 0x05
    2ce4:	80 81       	ld	r24, Z
    2ce6:	91 81       	ldd	r25, Z+1	; 0x01
    2ce8:	00 97       	sbiw	r24, 0x00	; 0
    2cea:	31 f4       	brne	.+12     	; 0x2cf8 <xQueueSemaphoreTake+0x5e>
					{
						/* Record the information required to implement
						priority inheritance should it become necessary. */
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
    2cec:	0e 94 d4 2d 	call	0x5ba8	; 0x5ba8 <pvTaskIncrementMutexHeldCount>
    2cf0:	ec 81       	ldd	r30, Y+4	; 0x04
    2cf2:	fd 81       	ldd	r31, Y+5	; 0x05
    2cf4:	95 83       	std	Z+5, r25	; 0x05
    2cf6:	84 83       	std	Z+4, r24	; 0x04
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2cf8:	ec 81       	ldd	r30, Y+4	; 0x04
    2cfa:	fd 81       	ldd	r31, Y+5	; 0x05
    2cfc:	80 85       	ldd	r24, Z+8	; 0x08
    2cfe:	88 23       	and	r24, r24
    2d00:	49 f0       	breq	.+18     	; 0x2d14 <xQueueSemaphoreTake+0x7a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2d02:	8c 81       	ldd	r24, Y+4	; 0x04
    2d04:	9d 81       	ldd	r25, Y+5	; 0x05
    2d06:	08 96       	adiw	r24, 0x08	; 8
    2d08:	0e 94 c5 29 	call	0x538a	; 0x538a <xTaskRemoveFromEventList>
    2d0c:	88 23       	and	r24, r24
    2d0e:	11 f0       	breq	.+4      	; 0x2d14 <xQueueSemaphoreTake+0x7a>
					{
						queueYIELD_IF_USING_PREEMPTION();
    2d10:	0e 94 e2 11 	call	0x23c4	; 0x23c4 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    2d14:	0f 90       	pop	r0
    2d16:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2d18:	81 e0       	ldi	r24, 0x01	; 1
    2d1a:	8e 87       	std	Y+14, r24	; 0x0e
    2d1c:	89 c0       	rjmp	.+274    	; 0x2e30 <xQueueSemaphoreTake+0x196>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2d1e:	8c 85       	ldd	r24, Y+12	; 0x0c
    2d20:	9d 85       	ldd	r25, Y+13	; 0x0d
    2d22:	00 97       	sbiw	r24, 0x00	; 0
    2d24:	21 f4       	brne	.+8      	; 0x2d2e <xQueueSemaphoreTake+0x94>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    2d26:	0f 90       	pop	r0
    2d28:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2d2a:	1e 86       	std	Y+14, r1	; 0x0e
    2d2c:	81 c0       	rjmp	.+258    	; 0x2e30 <xQueueSemaphoreTake+0x196>
				}
				else if( xEntryTimeSet == pdFALSE )
    2d2e:	8e 81       	ldd	r24, Y+6	; 0x06
    2d30:	88 23       	and	r24, r24
    2d32:	31 f4       	brne	.+12     	; 0x2d40 <xQueueSemaphoreTake+0xa6>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    2d34:	ce 01       	movw	r24, r28
    2d36:	07 96       	adiw	r24, 0x07	; 7
    2d38:	0e 94 ab 2a 	call	0x5556	; 0x5556 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2d3c:	81 e0       	ldi	r24, 0x01	; 1
    2d3e:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2d40:	0f 90       	pop	r0
    2d42:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    2d44:	0e 94 25 27 	call	0x4e4a	; 0x4e4a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2d48:	0f b6       	in	r0, 0x3f	; 63
    2d4a:	f8 94       	cli
    2d4c:	0f 92       	push	r0
    2d4e:	ec 81       	ldd	r30, Y+4	; 0x04
    2d50:	fd 81       	ldd	r31, Y+5	; 0x05
    2d52:	85 8d       	ldd	r24, Z+29	; 0x1d
    2d54:	8f 3f       	cpi	r24, 0xFF	; 255
    2d56:	19 f4       	brne	.+6      	; 0x2d5e <xQueueSemaphoreTake+0xc4>
    2d58:	ec 81       	ldd	r30, Y+4	; 0x04
    2d5a:	fd 81       	ldd	r31, Y+5	; 0x05
    2d5c:	15 8e       	std	Z+29, r1	; 0x1d
    2d5e:	ec 81       	ldd	r30, Y+4	; 0x04
    2d60:	fd 81       	ldd	r31, Y+5	; 0x05
    2d62:	86 8d       	ldd	r24, Z+30	; 0x1e
    2d64:	8f 3f       	cpi	r24, 0xFF	; 255
    2d66:	19 f4       	brne	.+6      	; 0x2d6e <xQueueSemaphoreTake+0xd4>
    2d68:	ec 81       	ldd	r30, Y+4	; 0x04
    2d6a:	fd 81       	ldd	r31, Y+5	; 0x05
    2d6c:	16 8e       	std	Z+30, r1	; 0x1e
    2d6e:	0f 90       	pop	r0
    2d70:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2d72:	ce 01       	movw	r24, r28
    2d74:	07 96       	adiw	r24, 0x07	; 7
    2d76:	9e 01       	movw	r18, r28
    2d78:	24 5f       	subi	r18, 0xF4	; 244
    2d7a:	3f 4f       	sbci	r19, 0xFF	; 255
    2d7c:	b9 01       	movw	r22, r18
    2d7e:	0e 94 c4 2a 	call	0x5588	; 0x5588 <xTaskCheckForTimeOut>
    2d82:	88 23       	and	r24, r24
    2d84:	99 f5       	brne	.+102    	; 0x2dec <xQueueSemaphoreTake+0x152>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2d86:	8c 81       	ldd	r24, Y+4	; 0x04
    2d88:	9d 81       	ldd	r25, Y+5	; 0x05
    2d8a:	0e 94 45 1a 	call	0x348a	; 0x348a <prvIsQueueEmpty>
    2d8e:	88 23       	and	r24, r24
    2d90:	31 f1       	breq	.+76     	; 0x2dde <xQueueSemaphoreTake+0x144>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2d92:	ec 81       	ldd	r30, Y+4	; 0x04
    2d94:	fd 81       	ldd	r31, Y+5	; 0x05
    2d96:	80 81       	ld	r24, Z
    2d98:	91 81       	ldd	r25, Z+1	; 0x01
    2d9a:	00 97       	sbiw	r24, 0x00	; 0
    2d9c:	61 f4       	brne	.+24     	; 0x2db6 <xQueueSemaphoreTake+0x11c>
					{
						taskENTER_CRITICAL();
    2d9e:	0f b6       	in	r0, 0x3f	; 63
    2da0:	f8 94       	cli
    2da2:	0f 92       	push	r0
						{
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
    2da4:	ec 81       	ldd	r30, Y+4	; 0x04
    2da6:	fd 81       	ldd	r31, Y+5	; 0x05
    2da8:	84 81       	ldd	r24, Z+4	; 0x04
    2daa:	95 81       	ldd	r25, Z+5	; 0x05
    2dac:	0e 94 08 2c 	call	0x5810	; 0x5810 <xTaskPriorityInherit>
    2db0:	8b 83       	std	Y+3, r24	; 0x03
						}
						taskEXIT_CRITICAL();
    2db2:	0f 90       	pop	r0
    2db4:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2db6:	8c 81       	ldd	r24, Y+4	; 0x04
    2db8:	9d 81       	ldd	r25, Y+5	; 0x05
    2dba:	41 96       	adiw	r24, 0x11	; 17
    2dbc:	2c 85       	ldd	r18, Y+12	; 0x0c
    2dbe:	3d 85       	ldd	r19, Y+13	; 0x0d
    2dc0:	b9 01       	movw	r22, r18
    2dc2:	0e 94 73 29 	call	0x52e6	; 0x52e6 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2dc6:	8c 81       	ldd	r24, Y+4	; 0x04
    2dc8:	9d 81       	ldd	r25, Y+5	; 0x05
    2dca:	0e 94 f2 19 	call	0x33e4	; 0x33e4 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2dce:	0e 94 31 27 	call	0x4e62	; 0x4e62 <xTaskResumeAll>
    2dd2:	88 23       	and	r24, r24
    2dd4:	09 f0       	breq	.+2      	; 0x2dd8 <xQueueSemaphoreTake+0x13e>
    2dd6:	75 cf       	rjmp	.-278    	; 0x2cc2 <xQueueSemaphoreTake+0x28>
				{
					portYIELD_WITHIN_API();
    2dd8:	0e 94 e2 11 	call	0x23c4	; 0x23c4 <vPortYield>
    2ddc:	72 cf       	rjmp	.-284    	; 0x2cc2 <xQueueSemaphoreTake+0x28>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    2dde:	8c 81       	ldd	r24, Y+4	; 0x04
    2de0:	9d 81       	ldd	r25, Y+5	; 0x05
    2de2:	0e 94 f2 19 	call	0x33e4	; 0x33e4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2de6:	0e 94 31 27 	call	0x4e62	; 0x4e62 <xTaskResumeAll>
    2dea:	6b cf       	rjmp	.-298    	; 0x2cc2 <xQueueSemaphoreTake+0x28>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    2dec:	8c 81       	ldd	r24, Y+4	; 0x04
    2dee:	9d 81       	ldd	r25, Y+5	; 0x05
    2df0:	0e 94 f2 19 	call	0x33e4	; 0x33e4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2df4:	0e 94 31 27 	call	0x4e62	; 0x4e62 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2df8:	8c 81       	ldd	r24, Y+4	; 0x04
    2dfa:	9d 81       	ldd	r25, Y+5	; 0x05
    2dfc:	0e 94 45 1a 	call	0x348a	; 0x348a <prvIsQueueEmpty>
    2e00:	88 23       	and	r24, r24
    2e02:	09 f4       	brne	.+2      	; 0x2e06 <xQueueSemaphoreTake+0x16c>
    2e04:	5e cf       	rjmp	.-324    	; 0x2cc2 <xQueueSemaphoreTake+0x28>
				#if ( configUSE_MUTEXES == 1 )
				{
					/* xInheritanceOccurred could only have be set if
					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
					test the mutex type again to check it is actually a mutex. */
					if( xInheritanceOccurred != pdFALSE )
    2e06:	8b 81       	ldd	r24, Y+3	; 0x03
    2e08:	88 23       	and	r24, r24
    2e0a:	89 f0       	breq	.+34     	; 0x2e2e <xQueueSemaphoreTake+0x194>
					{
						taskENTER_CRITICAL();
    2e0c:	0f b6       	in	r0, 0x3f	; 63
    2e0e:	f8 94       	cli
    2e10:	0f 92       	push	r0
							/* This task blocking on the mutex caused another
							task to inherit this task's priority.  Now this task
							has timed out the priority should be disinherited
							again, but only as low as the next highest priority
							task that is waiting for the same mutex. */
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
    2e12:	8c 81       	ldd	r24, Y+4	; 0x04
    2e14:	9d 81       	ldd	r25, Y+5	; 0x05
    2e16:	0e 94 d2 18 	call	0x31a4	; 0x31a4 <prvGetDisinheritPriorityAfterTimeout>
    2e1a:	89 83       	std	Y+1, r24	; 0x01
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
    2e1c:	ec 81       	ldd	r30, Y+4	; 0x04
    2e1e:	fd 81       	ldd	r31, Y+5	; 0x05
    2e20:	84 81       	ldd	r24, Z+4	; 0x04
    2e22:	95 81       	ldd	r25, Z+5	; 0x05
    2e24:	69 81       	ldd	r22, Y+1	; 0x01
    2e26:	0e 94 18 2d 	call	0x5a30	; 0x5a30 <vTaskPriorityDisinheritAfterTimeout>
						}
						taskEXIT_CRITICAL();
    2e2a:	0f 90       	pop	r0
    2e2c:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    2e2e:	1e 86       	std	Y+14, r1	; 0x0e
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    2e30:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    2e32:	2e 96       	adiw	r28, 0x0e	; 14
    2e34:	0f b6       	in	r0, 0x3f	; 63
    2e36:	f8 94       	cli
    2e38:	de bf       	out	0x3e, r29	; 62
    2e3a:	0f be       	out	0x3f, r0	; 63
    2e3c:	cd bf       	out	0x3d, r28	; 61
    2e3e:	cf 91       	pop	r28
    2e40:	df 91       	pop	r29
    2e42:	08 95       	ret

00002e44 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    2e44:	df 93       	push	r29
    2e46:	cf 93       	push	r28
    2e48:	cd b7       	in	r28, 0x3d	; 61
    2e4a:	de b7       	in	r29, 0x3e	; 62
    2e4c:	60 97       	sbiw	r28, 0x10	; 16
    2e4e:	0f b6       	in	r0, 0x3f	; 63
    2e50:	f8 94       	cli
    2e52:	de bf       	out	0x3e, r29	; 62
    2e54:	0f be       	out	0x3f, r0	; 63
    2e56:	cd bf       	out	0x3d, r28	; 61
    2e58:	9b 87       	std	Y+11, r25	; 0x0b
    2e5a:	8a 87       	std	Y+10, r24	; 0x0a
    2e5c:	7d 87       	std	Y+13, r23	; 0x0d
    2e5e:	6c 87       	std	Y+12, r22	; 0x0c
    2e60:	5f 87       	std	Y+15, r21	; 0x0f
    2e62:	4e 87       	std	Y+14, r20	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE;
    2e64:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    2e66:	8a 85       	ldd	r24, Y+10	; 0x0a
    2e68:	9b 85       	ldd	r25, Y+11	; 0x0b
    2e6a:	9b 83       	std	Y+3, r25	; 0x03
    2e6c:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2e6e:	0f b6       	in	r0, 0x3f	; 63
    2e70:	f8 94       	cli
    2e72:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2e74:	ea 81       	ldd	r30, Y+2	; 0x02
    2e76:	fb 81       	ldd	r31, Y+3	; 0x03
    2e78:	82 8d       	ldd	r24, Z+26	; 0x1a
    2e7a:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2e7c:	89 81       	ldd	r24, Y+1	; 0x01
    2e7e:	88 23       	and	r24, r24
    2e80:	31 f1       	breq	.+76     	; 0x2ece <xQueuePeek+0x8a>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    2e82:	ea 81       	ldd	r30, Y+2	; 0x02
    2e84:	fb 81       	ldd	r31, Y+3	; 0x03
    2e86:	86 81       	ldd	r24, Z+6	; 0x06
    2e88:	97 81       	ldd	r25, Z+7	; 0x07
    2e8a:	9d 83       	std	Y+5, r25	; 0x05
    2e8c:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    2e8e:	8a 81       	ldd	r24, Y+2	; 0x02
    2e90:	9b 81       	ldd	r25, Y+3	; 0x03
    2e92:	2c 85       	ldd	r18, Y+12	; 0x0c
    2e94:	3d 85       	ldd	r19, Y+13	; 0x0d
    2e96:	b9 01       	movw	r22, r18
    2e98:	0e 94 ab 19 	call	0x3356	; 0x3356 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2e9c:	ea 81       	ldd	r30, Y+2	; 0x02
    2e9e:	fb 81       	ldd	r31, Y+3	; 0x03
    2ea0:	8c 81       	ldd	r24, Y+4	; 0x04
    2ea2:	9d 81       	ldd	r25, Y+5	; 0x05
    2ea4:	97 83       	std	Z+7, r25	; 0x07
    2ea6:	86 83       	std	Z+6, r24	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2ea8:	ea 81       	ldd	r30, Y+2	; 0x02
    2eaa:	fb 81       	ldd	r31, Y+3	; 0x03
    2eac:	81 89       	ldd	r24, Z+17	; 0x11
    2eae:	88 23       	and	r24, r24
    2eb0:	49 f0       	breq	.+18     	; 0x2ec4 <xQueuePeek+0x80>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2eb2:	8a 81       	ldd	r24, Y+2	; 0x02
    2eb4:	9b 81       	ldd	r25, Y+3	; 0x03
    2eb6:	41 96       	adiw	r24, 0x11	; 17
    2eb8:	0e 94 c5 29 	call	0x538a	; 0x538a <xTaskRemoveFromEventList>
    2ebc:	88 23       	and	r24, r24
    2ebe:	11 f0       	breq	.+4      	; 0x2ec4 <xQueuePeek+0x80>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    2ec0:	0e 94 e2 11 	call	0x23c4	; 0x23c4 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    2ec4:	0f 90       	pop	r0
    2ec6:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2ec8:	81 e0       	ldi	r24, 0x01	; 1
    2eca:	88 8b       	std	Y+16, r24	; 0x10
    2ecc:	63 c0       	rjmp	.+198    	; 0x2f94 <xQueuePeek+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2ece:	8e 85       	ldd	r24, Y+14	; 0x0e
    2ed0:	9f 85       	ldd	r25, Y+15	; 0x0f
    2ed2:	00 97       	sbiw	r24, 0x00	; 0
    2ed4:	21 f4       	brne	.+8      	; 0x2ede <xQueuePeek+0x9a>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2ed6:	0f 90       	pop	r0
    2ed8:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2eda:	18 8a       	std	Y+16, r1	; 0x10
    2edc:	5b c0       	rjmp	.+182    	; 0x2f94 <xQueuePeek+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    2ede:	8e 81       	ldd	r24, Y+6	; 0x06
    2ee0:	88 23       	and	r24, r24
    2ee2:	31 f4       	brne	.+12     	; 0x2ef0 <xQueuePeek+0xac>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    2ee4:	ce 01       	movw	r24, r28
    2ee6:	07 96       	adiw	r24, 0x07	; 7
    2ee8:	0e 94 ab 2a 	call	0x5556	; 0x5556 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2eec:	81 e0       	ldi	r24, 0x01	; 1
    2eee:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2ef0:	0f 90       	pop	r0
    2ef2:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2ef4:	0e 94 25 27 	call	0x4e4a	; 0x4e4a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2ef8:	0f b6       	in	r0, 0x3f	; 63
    2efa:	f8 94       	cli
    2efc:	0f 92       	push	r0
    2efe:	ea 81       	ldd	r30, Y+2	; 0x02
    2f00:	fb 81       	ldd	r31, Y+3	; 0x03
    2f02:	85 8d       	ldd	r24, Z+29	; 0x1d
    2f04:	8f 3f       	cpi	r24, 0xFF	; 255
    2f06:	19 f4       	brne	.+6      	; 0x2f0e <xQueuePeek+0xca>
    2f08:	ea 81       	ldd	r30, Y+2	; 0x02
    2f0a:	fb 81       	ldd	r31, Y+3	; 0x03
    2f0c:	15 8e       	std	Z+29, r1	; 0x1d
    2f0e:	ea 81       	ldd	r30, Y+2	; 0x02
    2f10:	fb 81       	ldd	r31, Y+3	; 0x03
    2f12:	86 8d       	ldd	r24, Z+30	; 0x1e
    2f14:	8f 3f       	cpi	r24, 0xFF	; 255
    2f16:	19 f4       	brne	.+6      	; 0x2f1e <xQueuePeek+0xda>
    2f18:	ea 81       	ldd	r30, Y+2	; 0x02
    2f1a:	fb 81       	ldd	r31, Y+3	; 0x03
    2f1c:	16 8e       	std	Z+30, r1	; 0x1e
    2f1e:	0f 90       	pop	r0
    2f20:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2f22:	ce 01       	movw	r24, r28
    2f24:	07 96       	adiw	r24, 0x07	; 7
    2f26:	9e 01       	movw	r18, r28
    2f28:	22 5f       	subi	r18, 0xF2	; 242
    2f2a:	3f 4f       	sbci	r19, 0xFF	; 255
    2f2c:	b9 01       	movw	r22, r18
    2f2e:	0e 94 c4 2a 	call	0x5588	; 0x5588 <xTaskCheckForTimeOut>
    2f32:	88 23       	and	r24, r24
    2f34:	09 f5       	brne	.+66     	; 0x2f78 <xQueuePeek+0x134>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2f36:	8a 81       	ldd	r24, Y+2	; 0x02
    2f38:	9b 81       	ldd	r25, Y+3	; 0x03
    2f3a:	0e 94 45 1a 	call	0x348a	; 0x348a <prvIsQueueEmpty>
    2f3e:	88 23       	and	r24, r24
    2f40:	a1 f0       	breq	.+40     	; 0x2f6a <xQueuePeek+0x126>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2f42:	8a 81       	ldd	r24, Y+2	; 0x02
    2f44:	9b 81       	ldd	r25, Y+3	; 0x03
    2f46:	41 96       	adiw	r24, 0x11	; 17
    2f48:	2e 85       	ldd	r18, Y+14	; 0x0e
    2f4a:	3f 85       	ldd	r19, Y+15	; 0x0f
    2f4c:	b9 01       	movw	r22, r18
    2f4e:	0e 94 73 29 	call	0x52e6	; 0x52e6 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2f52:	8a 81       	ldd	r24, Y+2	; 0x02
    2f54:	9b 81       	ldd	r25, Y+3	; 0x03
    2f56:	0e 94 f2 19 	call	0x33e4	; 0x33e4 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2f5a:	0e 94 31 27 	call	0x4e62	; 0x4e62 <xTaskResumeAll>
    2f5e:	88 23       	and	r24, r24
    2f60:	09 f0       	breq	.+2      	; 0x2f64 <xQueuePeek+0x120>
    2f62:	85 cf       	rjmp	.-246    	; 0x2e6e <xQueuePeek+0x2a>
				{
					portYIELD_WITHIN_API();
    2f64:	0e 94 e2 11 	call	0x23c4	; 0x23c4 <vPortYield>
    2f68:	82 cf       	rjmp	.-252    	; 0x2e6e <xQueuePeek+0x2a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    2f6a:	8a 81       	ldd	r24, Y+2	; 0x02
    2f6c:	9b 81       	ldd	r25, Y+3	; 0x03
    2f6e:	0e 94 f2 19 	call	0x33e4	; 0x33e4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2f72:	0e 94 31 27 	call	0x4e62	; 0x4e62 <xTaskResumeAll>
    2f76:	7b cf       	rjmp	.-266    	; 0x2e6e <xQueuePeek+0x2a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    2f78:	8a 81       	ldd	r24, Y+2	; 0x02
    2f7a:	9b 81       	ldd	r25, Y+3	; 0x03
    2f7c:	0e 94 f2 19 	call	0x33e4	; 0x33e4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2f80:	0e 94 31 27 	call	0x4e62	; 0x4e62 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2f84:	8a 81       	ldd	r24, Y+2	; 0x02
    2f86:	9b 81       	ldd	r25, Y+3	; 0x03
    2f88:	0e 94 45 1a 	call	0x348a	; 0x348a <prvIsQueueEmpty>
    2f8c:	88 23       	and	r24, r24
    2f8e:	09 f4       	brne	.+2      	; 0x2f92 <xQueuePeek+0x14e>
    2f90:	6e cf       	rjmp	.-292    	; 0x2e6e <xQueuePeek+0x2a>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    2f92:	18 8a       	std	Y+16, r1	; 0x10
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    2f94:	88 89       	ldd	r24, Y+16	; 0x10
}
    2f96:	60 96       	adiw	r28, 0x10	; 16
    2f98:	0f b6       	in	r0, 0x3f	; 63
    2f9a:	f8 94       	cli
    2f9c:	de bf       	out	0x3e, r29	; 62
    2f9e:	0f be       	out	0x3f, r0	; 63
    2fa0:	cd bf       	out	0x3d, r28	; 61
    2fa2:	cf 91       	pop	r28
    2fa4:	df 91       	pop	r29
    2fa6:	08 95       	ret

00002fa8 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    2fa8:	df 93       	push	r29
    2faa:	cf 93       	push	r28
    2fac:	cd b7       	in	r28, 0x3d	; 61
    2fae:	de b7       	in	r29, 0x3e	; 62
    2fb0:	2c 97       	sbiw	r28, 0x0c	; 12
    2fb2:	0f b6       	in	r0, 0x3f	; 63
    2fb4:	f8 94       	cli
    2fb6:	de bf       	out	0x3e, r29	; 62
    2fb8:	0f be       	out	0x3f, r0	; 63
    2fba:	cd bf       	out	0x3d, r28	; 61
    2fbc:	98 87       	std	Y+8, r25	; 0x08
    2fbe:	8f 83       	std	Y+7, r24	; 0x07
    2fc0:	7a 87       	std	Y+10, r23	; 0x0a
    2fc2:	69 87       	std	Y+9, r22	; 0x09
    2fc4:	5c 87       	std	Y+12, r21	; 0x0c
    2fc6:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    2fc8:	8f 81       	ldd	r24, Y+7	; 0x07
    2fca:	98 85       	ldd	r25, Y+8	; 0x08
    2fcc:	9c 83       	std	Y+4, r25	; 0x04
    2fce:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2fd0:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2fd2:	eb 81       	ldd	r30, Y+3	; 0x03
    2fd4:	fc 81       	ldd	r31, Y+4	; 0x04
    2fd6:	82 8d       	ldd	r24, Z+26	; 0x1a
    2fd8:	8a 83       	std	Y+2, r24	; 0x02

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2fda:	8a 81       	ldd	r24, Y+2	; 0x02
    2fdc:	88 23       	and	r24, r24
    2fde:	81 f1       	breq	.+96     	; 0x3040 <xQueueReceiveFromISR+0x98>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    2fe0:	eb 81       	ldd	r30, Y+3	; 0x03
    2fe2:	fc 81       	ldd	r31, Y+4	; 0x04
    2fe4:	85 8d       	ldd	r24, Z+29	; 0x1d
    2fe6:	89 83       	std	Y+1, r24	; 0x01

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2fe8:	8b 81       	ldd	r24, Y+3	; 0x03
    2fea:	9c 81       	ldd	r25, Y+4	; 0x04
    2fec:	29 85       	ldd	r18, Y+9	; 0x09
    2fee:	3a 85       	ldd	r19, Y+10	; 0x0a
    2ff0:	b9 01       	movw	r22, r18
    2ff2:	0e 94 ab 19 	call	0x3356	; 0x3356 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    2ff6:	8a 81       	ldd	r24, Y+2	; 0x02
    2ff8:	81 50       	subi	r24, 0x01	; 1
    2ffa:	eb 81       	ldd	r30, Y+3	; 0x03
    2ffc:	fc 81       	ldd	r31, Y+4	; 0x04
    2ffe:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    3000:	89 81       	ldd	r24, Y+1	; 0x01
    3002:	8f 3f       	cpi	r24, 0xFF	; 255
    3004:	a9 f4       	brne	.+42     	; 0x3030 <xQueueReceiveFromISR+0x88>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3006:	eb 81       	ldd	r30, Y+3	; 0x03
    3008:	fc 81       	ldd	r31, Y+4	; 0x04
    300a:	80 85       	ldd	r24, Z+8	; 0x08
    300c:	88 23       	and	r24, r24
    300e:	a9 f0       	breq	.+42     	; 0x303a <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3010:	8b 81       	ldd	r24, Y+3	; 0x03
    3012:	9c 81       	ldd	r25, Y+4	; 0x04
    3014:	08 96       	adiw	r24, 0x08	; 8
    3016:	0e 94 c5 29 	call	0x538a	; 0x538a <xTaskRemoveFromEventList>
    301a:	88 23       	and	r24, r24
    301c:	71 f0       	breq	.+28     	; 0x303a <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    301e:	8b 85       	ldd	r24, Y+11	; 0x0b
    3020:	9c 85       	ldd	r25, Y+12	; 0x0c
    3022:	00 97       	sbiw	r24, 0x00	; 0
    3024:	51 f0       	breq	.+20     	; 0x303a <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    3026:	eb 85       	ldd	r30, Y+11	; 0x0b
    3028:	fc 85       	ldd	r31, Y+12	; 0x0c
    302a:	81 e0       	ldi	r24, 0x01	; 1
    302c:	80 83       	st	Z, r24
    302e:	05 c0       	rjmp	.+10     	; 0x303a <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    3030:	89 81       	ldd	r24, Y+1	; 0x01
    3032:	8f 5f       	subi	r24, 0xFF	; 255
    3034:	eb 81       	ldd	r30, Y+3	; 0x03
    3036:	fc 81       	ldd	r31, Y+4	; 0x04
    3038:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    303a:	81 e0       	ldi	r24, 0x01	; 1
    303c:	8e 83       	std	Y+6, r24	; 0x06
    303e:	01 c0       	rjmp	.+2      	; 0x3042 <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    3040:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3042:	8e 81       	ldd	r24, Y+6	; 0x06
}
    3044:	2c 96       	adiw	r28, 0x0c	; 12
    3046:	0f b6       	in	r0, 0x3f	; 63
    3048:	f8 94       	cli
    304a:	de bf       	out	0x3e, r29	; 62
    304c:	0f be       	out	0x3f, r0	; 63
    304e:	cd bf       	out	0x3d, r28	; 61
    3050:	cf 91       	pop	r28
    3052:	df 91       	pop	r29
    3054:	08 95       	ret

00003056 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    3056:	df 93       	push	r29
    3058:	cf 93       	push	r28
    305a:	cd b7       	in	r28, 0x3d	; 61
    305c:	de b7       	in	r29, 0x3e	; 62
    305e:	2a 97       	sbiw	r28, 0x0a	; 10
    3060:	0f b6       	in	r0, 0x3f	; 63
    3062:	f8 94       	cli
    3064:	de bf       	out	0x3e, r29	; 62
    3066:	0f be       	out	0x3f, r0	; 63
    3068:	cd bf       	out	0x3d, r28	; 61
    306a:	98 87       	std	Y+8, r25	; 0x08
    306c:	8f 83       	std	Y+7, r24	; 0x07
    306e:	7a 87       	std	Y+10, r23	; 0x0a
    3070:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    3072:	8f 81       	ldd	r24, Y+7	; 0x07
    3074:	98 85       	ldd	r25, Y+8	; 0x08
    3076:	9a 83       	std	Y+2, r25	; 0x02
    3078:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    307a:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    307c:	e9 81       	ldd	r30, Y+1	; 0x01
    307e:	fa 81       	ldd	r31, Y+2	; 0x02
    3080:	82 8d       	ldd	r24, Z+26	; 0x1a
    3082:	88 23       	and	r24, r24
    3084:	b1 f0       	breq	.+44     	; 0x30b2 <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    3086:	e9 81       	ldd	r30, Y+1	; 0x01
    3088:	fa 81       	ldd	r31, Y+2	; 0x02
    308a:	86 81       	ldd	r24, Z+6	; 0x06
    308c:	97 81       	ldd	r25, Z+7	; 0x07
    308e:	9c 83       	std	Y+4, r25	; 0x04
    3090:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    3092:	89 81       	ldd	r24, Y+1	; 0x01
    3094:	9a 81       	ldd	r25, Y+2	; 0x02
    3096:	29 85       	ldd	r18, Y+9	; 0x09
    3098:	3a 85       	ldd	r19, Y+10	; 0x0a
    309a:	b9 01       	movw	r22, r18
    309c:	0e 94 ab 19 	call	0x3356	; 0x3356 <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    30a0:	e9 81       	ldd	r30, Y+1	; 0x01
    30a2:	fa 81       	ldd	r31, Y+2	; 0x02
    30a4:	8b 81       	ldd	r24, Y+3	; 0x03
    30a6:	9c 81       	ldd	r25, Y+4	; 0x04
    30a8:	97 83       	std	Z+7, r25	; 0x07
    30aa:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    30ac:	81 e0       	ldi	r24, 0x01	; 1
    30ae:	8e 83       	std	Y+6, r24	; 0x06
    30b0:	01 c0       	rjmp	.+2      	; 0x30b4 <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    30b2:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    30b4:	8e 81       	ldd	r24, Y+6	; 0x06
}
    30b6:	2a 96       	adiw	r28, 0x0a	; 10
    30b8:	0f b6       	in	r0, 0x3f	; 63
    30ba:	f8 94       	cli
    30bc:	de bf       	out	0x3e, r29	; 62
    30be:	0f be       	out	0x3f, r0	; 63
    30c0:	cd bf       	out	0x3d, r28	; 61
    30c2:	cf 91       	pop	r28
    30c4:	df 91       	pop	r29
    30c6:	08 95       	ret

000030c8 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    30c8:	df 93       	push	r29
    30ca:	cf 93       	push	r28
    30cc:	00 d0       	rcall	.+0      	; 0x30ce <uxQueueMessagesWaiting+0x6>
    30ce:	0f 92       	push	r0
    30d0:	cd b7       	in	r28, 0x3d	; 61
    30d2:	de b7       	in	r29, 0x3e	; 62
    30d4:	9b 83       	std	Y+3, r25	; 0x03
    30d6:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    30d8:	0f b6       	in	r0, 0x3f	; 63
    30da:	f8 94       	cli
    30dc:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    30de:	ea 81       	ldd	r30, Y+2	; 0x02
    30e0:	fb 81       	ldd	r31, Y+3	; 0x03
    30e2:	82 8d       	ldd	r24, Z+26	; 0x1a
    30e4:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    30e6:	0f 90       	pop	r0
    30e8:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    30ea:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    30ec:	0f 90       	pop	r0
    30ee:	0f 90       	pop	r0
    30f0:	0f 90       	pop	r0
    30f2:	cf 91       	pop	r28
    30f4:	df 91       	pop	r29
    30f6:	08 95       	ret

000030f8 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    30f8:	df 93       	push	r29
    30fa:	cf 93       	push	r28
    30fc:	00 d0       	rcall	.+0      	; 0x30fe <uxQueueSpacesAvailable+0x6>
    30fe:	00 d0       	rcall	.+0      	; 0x3100 <uxQueueSpacesAvailable+0x8>
    3100:	0f 92       	push	r0
    3102:	cd b7       	in	r28, 0x3d	; 61
    3104:	de b7       	in	r29, 0x3e	; 62
    3106:	9d 83       	std	Y+5, r25	; 0x05
    3108:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    310a:	8c 81       	ldd	r24, Y+4	; 0x04
    310c:	9d 81       	ldd	r25, Y+5	; 0x05
    310e:	9a 83       	std	Y+2, r25	; 0x02
    3110:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    3112:	0f b6       	in	r0, 0x3f	; 63
    3114:	f8 94       	cli
    3116:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    3118:	e9 81       	ldd	r30, Y+1	; 0x01
    311a:	fa 81       	ldd	r31, Y+2	; 0x02
    311c:	93 8d       	ldd	r25, Z+27	; 0x1b
    311e:	e9 81       	ldd	r30, Y+1	; 0x01
    3120:	fa 81       	ldd	r31, Y+2	; 0x02
    3122:	82 8d       	ldd	r24, Z+26	; 0x1a
    3124:	29 2f       	mov	r18, r25
    3126:	28 1b       	sub	r18, r24
    3128:	82 2f       	mov	r24, r18
    312a:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    312c:	0f 90       	pop	r0
    312e:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    3130:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3132:	0f 90       	pop	r0
    3134:	0f 90       	pop	r0
    3136:	0f 90       	pop	r0
    3138:	0f 90       	pop	r0
    313a:	0f 90       	pop	r0
    313c:	cf 91       	pop	r28
    313e:	df 91       	pop	r29
    3140:	08 95       	ret

00003142 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    3142:	df 93       	push	r29
    3144:	cf 93       	push	r28
    3146:	00 d0       	rcall	.+0      	; 0x3148 <uxQueueMessagesWaitingFromISR+0x6>
    3148:	00 d0       	rcall	.+0      	; 0x314a <uxQueueMessagesWaitingFromISR+0x8>
    314a:	0f 92       	push	r0
    314c:	cd b7       	in	r28, 0x3d	; 61
    314e:	de b7       	in	r29, 0x3e	; 62
    3150:	9d 83       	std	Y+5, r25	; 0x05
    3152:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    3154:	8c 81       	ldd	r24, Y+4	; 0x04
    3156:	9d 81       	ldd	r25, Y+5	; 0x05
    3158:	9a 83       	std	Y+2, r25	; 0x02
    315a:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    315c:	e9 81       	ldd	r30, Y+1	; 0x01
    315e:	fa 81       	ldd	r31, Y+2	; 0x02
    3160:	82 8d       	ldd	r24, Z+26	; 0x1a
    3162:	8b 83       	std	Y+3, r24	; 0x03

	return uxReturn;
    3164:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3166:	0f 90       	pop	r0
    3168:	0f 90       	pop	r0
    316a:	0f 90       	pop	r0
    316c:	0f 90       	pop	r0
    316e:	0f 90       	pop	r0
    3170:	cf 91       	pop	r28
    3172:	df 91       	pop	r29
    3174:	08 95       	ret

00003176 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    3176:	df 93       	push	r29
    3178:	cf 93       	push	r28
    317a:	00 d0       	rcall	.+0      	; 0x317c <vQueueDelete+0x6>
    317c:	00 d0       	rcall	.+0      	; 0x317e <vQueueDelete+0x8>
    317e:	cd b7       	in	r28, 0x3d	; 61
    3180:	de b7       	in	r29, 0x3e	; 62
    3182:	9c 83       	std	Y+4, r25	; 0x04
    3184:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = xQueue;
    3186:	8b 81       	ldd	r24, Y+3	; 0x03
    3188:	9c 81       	ldd	r25, Y+4	; 0x04
    318a:	9a 83       	std	Y+2, r25	; 0x02
    318c:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    318e:	89 81       	ldd	r24, Y+1	; 0x01
    3190:	9a 81       	ldd	r25, Y+2	; 0x02
    3192:	0e 94 58 09 	call	0x12b0	; 0x12b0 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    3196:	0f 90       	pop	r0
    3198:	0f 90       	pop	r0
    319a:	0f 90       	pop	r0
    319c:	0f 90       	pop	r0
    319e:	cf 91       	pop	r28
    31a0:	df 91       	pop	r29
    31a2:	08 95       	ret

000031a4 <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
	{
    31a4:	df 93       	push	r29
    31a6:	cf 93       	push	r28
    31a8:	00 d0       	rcall	.+0      	; 0x31aa <prvGetDisinheritPriorityAfterTimeout+0x6>
    31aa:	0f 92       	push	r0
    31ac:	cd b7       	in	r28, 0x3d	; 61
    31ae:	de b7       	in	r29, 0x3e	; 62
    31b0:	9b 83       	std	Y+3, r25	; 0x03
    31b2:	8a 83       	std	Y+2, r24	; 0x02
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
    31b4:	ea 81       	ldd	r30, Y+2	; 0x02
    31b6:	fb 81       	ldd	r31, Y+3	; 0x03
    31b8:	81 89       	ldd	r24, Z+17	; 0x11
    31ba:	88 23       	and	r24, r24
    31bc:	61 f0       	breq	.+24     	; 0x31d6 <prvGetDisinheritPriorityAfterTimeout+0x32>
		{
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
    31be:	ea 81       	ldd	r30, Y+2	; 0x02
    31c0:	fb 81       	ldd	r31, Y+3	; 0x03
    31c2:	06 88       	ldd	r0, Z+22	; 0x16
    31c4:	f7 89       	ldd	r31, Z+23	; 0x17
    31c6:	e0 2d       	mov	r30, r0
    31c8:	80 81       	ld	r24, Z
    31ca:	91 81       	ldd	r25, Z+1	; 0x01
    31cc:	98 2f       	mov	r25, r24
    31ce:	8a e0       	ldi	r24, 0x0A	; 10
    31d0:	89 1b       	sub	r24, r25
    31d2:	89 83       	std	Y+1, r24	; 0x01
    31d4:	01 c0       	rjmp	.+2      	; 0x31d8 <prvGetDisinheritPriorityAfterTimeout+0x34>
		}
		else
		{
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
    31d6:	19 82       	std	Y+1, r1	; 0x01
		}

		return uxHighestPriorityOfWaitingTasks;
    31d8:	89 81       	ldd	r24, Y+1	; 0x01
	}
    31da:	0f 90       	pop	r0
    31dc:	0f 90       	pop	r0
    31de:	0f 90       	pop	r0
    31e0:	cf 91       	pop	r28
    31e2:	df 91       	pop	r29
    31e4:	08 95       	ret

000031e6 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    31e6:	df 93       	push	r29
    31e8:	cf 93       	push	r28
    31ea:	cd b7       	in	r28, 0x3d	; 61
    31ec:	de b7       	in	r29, 0x3e	; 62
    31ee:	27 97       	sbiw	r28, 0x07	; 7
    31f0:	0f b6       	in	r0, 0x3f	; 63
    31f2:	f8 94       	cli
    31f4:	de bf       	out	0x3e, r29	; 62
    31f6:	0f be       	out	0x3f, r0	; 63
    31f8:	cd bf       	out	0x3d, r28	; 61
    31fa:	9c 83       	std	Y+4, r25	; 0x04
    31fc:	8b 83       	std	Y+3, r24	; 0x03
    31fe:	7e 83       	std	Y+6, r23	; 0x06
    3200:	6d 83       	std	Y+5, r22	; 0x05
    3202:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    3204:	1a 82       	std	Y+2, r1	; 0x02
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3206:	eb 81       	ldd	r30, Y+3	; 0x03
    3208:	fc 81       	ldd	r31, Y+4	; 0x04
    320a:	82 8d       	ldd	r24, Z+26	; 0x1a
    320c:	89 83       	std	Y+1, r24	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    320e:	eb 81       	ldd	r30, Y+3	; 0x03
    3210:	fc 81       	ldd	r31, Y+4	; 0x04
    3212:	84 8d       	ldd	r24, Z+28	; 0x1c
    3214:	88 23       	and	r24, r24
    3216:	99 f4       	brne	.+38     	; 0x323e <prvCopyDataToQueue+0x58>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    3218:	eb 81       	ldd	r30, Y+3	; 0x03
    321a:	fc 81       	ldd	r31, Y+4	; 0x04
    321c:	80 81       	ld	r24, Z
    321e:	91 81       	ldd	r25, Z+1	; 0x01
    3220:	00 97       	sbiw	r24, 0x00	; 0
    3222:	09 f0       	breq	.+2      	; 0x3226 <prvCopyDataToQueue+0x40>
    3224:	89 c0       	rjmp	.+274    	; 0x3338 <prvCopyDataToQueue+0x152>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
    3226:	eb 81       	ldd	r30, Y+3	; 0x03
    3228:	fc 81       	ldd	r31, Y+4	; 0x04
    322a:	84 81       	ldd	r24, Z+4	; 0x04
    322c:	95 81       	ldd	r25, Z+5	; 0x05
    322e:	0e 94 a6 2c 	call	0x594c	; 0x594c <xTaskPriorityDisinherit>
    3232:	8a 83       	std	Y+2, r24	; 0x02
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
    3234:	eb 81       	ldd	r30, Y+3	; 0x03
    3236:	fc 81       	ldd	r31, Y+4	; 0x04
    3238:	15 82       	std	Z+5, r1	; 0x05
    323a:	14 82       	std	Z+4, r1	; 0x04
    323c:	7d c0       	rjmp	.+250    	; 0x3338 <prvCopyDataToQueue+0x152>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    323e:	8f 81       	ldd	r24, Y+7	; 0x07
    3240:	88 23       	and	r24, r24
    3242:	99 f5       	brne	.+102    	; 0x32aa <prvCopyDataToQueue+0xc4>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    3244:	eb 81       	ldd	r30, Y+3	; 0x03
    3246:	fc 81       	ldd	r31, Y+4	; 0x04
    3248:	62 81       	ldd	r22, Z+2	; 0x02
    324a:	73 81       	ldd	r23, Z+3	; 0x03
    324c:	eb 81       	ldd	r30, Y+3	; 0x03
    324e:	fc 81       	ldd	r31, Y+4	; 0x04
    3250:	84 8d       	ldd	r24, Z+28	; 0x1c
    3252:	48 2f       	mov	r20, r24
    3254:	50 e0       	ldi	r21, 0x00	; 0
    3256:	2d 81       	ldd	r18, Y+5	; 0x05
    3258:	3e 81       	ldd	r19, Y+6	; 0x06
    325a:	cb 01       	movw	r24, r22
    325c:	b9 01       	movw	r22, r18
    325e:	0e 94 8d 32 	call	0x651a	; 0x651a <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    3262:	eb 81       	ldd	r30, Y+3	; 0x03
    3264:	fc 81       	ldd	r31, Y+4	; 0x04
    3266:	22 81       	ldd	r18, Z+2	; 0x02
    3268:	33 81       	ldd	r19, Z+3	; 0x03
    326a:	eb 81       	ldd	r30, Y+3	; 0x03
    326c:	fc 81       	ldd	r31, Y+4	; 0x04
    326e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3270:	88 2f       	mov	r24, r24
    3272:	90 e0       	ldi	r25, 0x00	; 0
    3274:	82 0f       	add	r24, r18
    3276:	93 1f       	adc	r25, r19
    3278:	eb 81       	ldd	r30, Y+3	; 0x03
    327a:	fc 81       	ldd	r31, Y+4	; 0x04
    327c:	93 83       	std	Z+3, r25	; 0x03
    327e:	82 83       	std	Z+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3280:	eb 81       	ldd	r30, Y+3	; 0x03
    3282:	fc 81       	ldd	r31, Y+4	; 0x04
    3284:	22 81       	ldd	r18, Z+2	; 0x02
    3286:	33 81       	ldd	r19, Z+3	; 0x03
    3288:	eb 81       	ldd	r30, Y+3	; 0x03
    328a:	fc 81       	ldd	r31, Y+4	; 0x04
    328c:	84 81       	ldd	r24, Z+4	; 0x04
    328e:	95 81       	ldd	r25, Z+5	; 0x05
    3290:	28 17       	cp	r18, r24
    3292:	39 07       	cpc	r19, r25
    3294:	08 f4       	brcc	.+2      	; 0x3298 <prvCopyDataToQueue+0xb2>
    3296:	50 c0       	rjmp	.+160    	; 0x3338 <prvCopyDataToQueue+0x152>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    3298:	eb 81       	ldd	r30, Y+3	; 0x03
    329a:	fc 81       	ldd	r31, Y+4	; 0x04
    329c:	80 81       	ld	r24, Z
    329e:	91 81       	ldd	r25, Z+1	; 0x01
    32a0:	eb 81       	ldd	r30, Y+3	; 0x03
    32a2:	fc 81       	ldd	r31, Y+4	; 0x04
    32a4:	93 83       	std	Z+3, r25	; 0x03
    32a6:	82 83       	std	Z+2, r24	; 0x02
    32a8:	47 c0       	rjmp	.+142    	; 0x3338 <prvCopyDataToQueue+0x152>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    32aa:	eb 81       	ldd	r30, Y+3	; 0x03
    32ac:	fc 81       	ldd	r31, Y+4	; 0x04
    32ae:	66 81       	ldd	r22, Z+6	; 0x06
    32b0:	77 81       	ldd	r23, Z+7	; 0x07
    32b2:	eb 81       	ldd	r30, Y+3	; 0x03
    32b4:	fc 81       	ldd	r31, Y+4	; 0x04
    32b6:	84 8d       	ldd	r24, Z+28	; 0x1c
    32b8:	48 2f       	mov	r20, r24
    32ba:	50 e0       	ldi	r21, 0x00	; 0
    32bc:	2d 81       	ldd	r18, Y+5	; 0x05
    32be:	3e 81       	ldd	r19, Y+6	; 0x06
    32c0:	cb 01       	movw	r24, r22
    32c2:	b9 01       	movw	r22, r18
    32c4:	0e 94 8d 32 	call	0x651a	; 0x651a <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    32c8:	eb 81       	ldd	r30, Y+3	; 0x03
    32ca:	fc 81       	ldd	r31, Y+4	; 0x04
    32cc:	26 81       	ldd	r18, Z+6	; 0x06
    32ce:	37 81       	ldd	r19, Z+7	; 0x07
    32d0:	eb 81       	ldd	r30, Y+3	; 0x03
    32d2:	fc 81       	ldd	r31, Y+4	; 0x04
    32d4:	84 8d       	ldd	r24, Z+28	; 0x1c
    32d6:	88 2f       	mov	r24, r24
    32d8:	90 e0       	ldi	r25, 0x00	; 0
    32da:	90 95       	com	r25
    32dc:	81 95       	neg	r24
    32de:	9f 4f       	sbci	r25, 0xFF	; 255
    32e0:	82 0f       	add	r24, r18
    32e2:	93 1f       	adc	r25, r19
    32e4:	eb 81       	ldd	r30, Y+3	; 0x03
    32e6:	fc 81       	ldd	r31, Y+4	; 0x04
    32e8:	97 83       	std	Z+7, r25	; 0x07
    32ea:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    32ec:	eb 81       	ldd	r30, Y+3	; 0x03
    32ee:	fc 81       	ldd	r31, Y+4	; 0x04
    32f0:	26 81       	ldd	r18, Z+6	; 0x06
    32f2:	37 81       	ldd	r19, Z+7	; 0x07
    32f4:	eb 81       	ldd	r30, Y+3	; 0x03
    32f6:	fc 81       	ldd	r31, Y+4	; 0x04
    32f8:	80 81       	ld	r24, Z
    32fa:	91 81       	ldd	r25, Z+1	; 0x01
    32fc:	28 17       	cp	r18, r24
    32fe:	39 07       	cpc	r19, r25
    3300:	90 f4       	brcc	.+36     	; 0x3326 <prvCopyDataToQueue+0x140>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    3302:	eb 81       	ldd	r30, Y+3	; 0x03
    3304:	fc 81       	ldd	r31, Y+4	; 0x04
    3306:	24 81       	ldd	r18, Z+4	; 0x04
    3308:	35 81       	ldd	r19, Z+5	; 0x05
    330a:	eb 81       	ldd	r30, Y+3	; 0x03
    330c:	fc 81       	ldd	r31, Y+4	; 0x04
    330e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3310:	88 2f       	mov	r24, r24
    3312:	90 e0       	ldi	r25, 0x00	; 0
    3314:	90 95       	com	r25
    3316:	81 95       	neg	r24
    3318:	9f 4f       	sbci	r25, 0xFF	; 255
    331a:	82 0f       	add	r24, r18
    331c:	93 1f       	adc	r25, r19
    331e:	eb 81       	ldd	r30, Y+3	; 0x03
    3320:	fc 81       	ldd	r31, Y+4	; 0x04
    3322:	97 83       	std	Z+7, r25	; 0x07
    3324:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    3326:	8f 81       	ldd	r24, Y+7	; 0x07
    3328:	82 30       	cpi	r24, 0x02	; 2
    332a:	31 f4       	brne	.+12     	; 0x3338 <prvCopyDataToQueue+0x152>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    332c:	89 81       	ldd	r24, Y+1	; 0x01
    332e:	88 23       	and	r24, r24
    3330:	19 f0       	breq	.+6      	; 0x3338 <prvCopyDataToQueue+0x152>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    3332:	89 81       	ldd	r24, Y+1	; 0x01
    3334:	81 50       	subi	r24, 0x01	; 1
    3336:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    3338:	89 81       	ldd	r24, Y+1	; 0x01
    333a:	8f 5f       	subi	r24, 0xFF	; 255
    333c:	eb 81       	ldd	r30, Y+3	; 0x03
    333e:	fc 81       	ldd	r31, Y+4	; 0x04
    3340:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    3342:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3344:	27 96       	adiw	r28, 0x07	; 7
    3346:	0f b6       	in	r0, 0x3f	; 63
    3348:	f8 94       	cli
    334a:	de bf       	out	0x3e, r29	; 62
    334c:	0f be       	out	0x3f, r0	; 63
    334e:	cd bf       	out	0x3d, r28	; 61
    3350:	cf 91       	pop	r28
    3352:	df 91       	pop	r29
    3354:	08 95       	ret

00003356 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    3356:	df 93       	push	r29
    3358:	cf 93       	push	r28
    335a:	00 d0       	rcall	.+0      	; 0x335c <prvCopyDataFromQueue+0x6>
    335c:	00 d0       	rcall	.+0      	; 0x335e <prvCopyDataFromQueue+0x8>
    335e:	cd b7       	in	r28, 0x3d	; 61
    3360:	de b7       	in	r29, 0x3e	; 62
    3362:	9a 83       	std	Y+2, r25	; 0x02
    3364:	89 83       	std	Y+1, r24	; 0x01
    3366:	7c 83       	std	Y+4, r23	; 0x04
    3368:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    336a:	e9 81       	ldd	r30, Y+1	; 0x01
    336c:	fa 81       	ldd	r31, Y+2	; 0x02
    336e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3370:	88 23       	and	r24, r24
    3372:	89 f1       	breq	.+98     	; 0x33d6 <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    3374:	e9 81       	ldd	r30, Y+1	; 0x01
    3376:	fa 81       	ldd	r31, Y+2	; 0x02
    3378:	26 81       	ldd	r18, Z+6	; 0x06
    337a:	37 81       	ldd	r19, Z+7	; 0x07
    337c:	e9 81       	ldd	r30, Y+1	; 0x01
    337e:	fa 81       	ldd	r31, Y+2	; 0x02
    3380:	84 8d       	ldd	r24, Z+28	; 0x1c
    3382:	88 2f       	mov	r24, r24
    3384:	90 e0       	ldi	r25, 0x00	; 0
    3386:	82 0f       	add	r24, r18
    3388:	93 1f       	adc	r25, r19
    338a:	e9 81       	ldd	r30, Y+1	; 0x01
    338c:	fa 81       	ldd	r31, Y+2	; 0x02
    338e:	97 83       	std	Z+7, r25	; 0x07
    3390:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    3392:	e9 81       	ldd	r30, Y+1	; 0x01
    3394:	fa 81       	ldd	r31, Y+2	; 0x02
    3396:	26 81       	ldd	r18, Z+6	; 0x06
    3398:	37 81       	ldd	r19, Z+7	; 0x07
    339a:	e9 81       	ldd	r30, Y+1	; 0x01
    339c:	fa 81       	ldd	r31, Y+2	; 0x02
    339e:	84 81       	ldd	r24, Z+4	; 0x04
    33a0:	95 81       	ldd	r25, Z+5	; 0x05
    33a2:	28 17       	cp	r18, r24
    33a4:	39 07       	cpc	r19, r25
    33a6:	40 f0       	brcs	.+16     	; 0x33b8 <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    33a8:	e9 81       	ldd	r30, Y+1	; 0x01
    33aa:	fa 81       	ldd	r31, Y+2	; 0x02
    33ac:	80 81       	ld	r24, Z
    33ae:	91 81       	ldd	r25, Z+1	; 0x01
    33b0:	e9 81       	ldd	r30, Y+1	; 0x01
    33b2:	fa 81       	ldd	r31, Y+2	; 0x02
    33b4:	97 83       	std	Z+7, r25	; 0x07
    33b6:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    33b8:	e9 81       	ldd	r30, Y+1	; 0x01
    33ba:	fa 81       	ldd	r31, Y+2	; 0x02
    33bc:	46 81       	ldd	r20, Z+6	; 0x06
    33be:	57 81       	ldd	r21, Z+7	; 0x07
    33c0:	e9 81       	ldd	r30, Y+1	; 0x01
    33c2:	fa 81       	ldd	r31, Y+2	; 0x02
    33c4:	84 8d       	ldd	r24, Z+28	; 0x1c
    33c6:	28 2f       	mov	r18, r24
    33c8:	30 e0       	ldi	r19, 0x00	; 0
    33ca:	8b 81       	ldd	r24, Y+3	; 0x03
    33cc:	9c 81       	ldd	r25, Y+4	; 0x04
    33ce:	ba 01       	movw	r22, r20
    33d0:	a9 01       	movw	r20, r18
    33d2:	0e 94 8d 32 	call	0x651a	; 0x651a <memcpy>
	}
}
    33d6:	0f 90       	pop	r0
    33d8:	0f 90       	pop	r0
    33da:	0f 90       	pop	r0
    33dc:	0f 90       	pop	r0
    33de:	cf 91       	pop	r28
    33e0:	df 91       	pop	r29
    33e2:	08 95       	ret

000033e4 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    33e4:	df 93       	push	r29
    33e6:	cf 93       	push	r28
    33e8:	00 d0       	rcall	.+0      	; 0x33ea <prvUnlockQueue+0x6>
    33ea:	00 d0       	rcall	.+0      	; 0x33ec <prvUnlockQueue+0x8>
    33ec:	cd b7       	in	r28, 0x3d	; 61
    33ee:	de b7       	in	r29, 0x3e	; 62
    33f0:	9c 83       	std	Y+4, r25	; 0x04
    33f2:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    33f4:	0f b6       	in	r0, 0x3f	; 63
    33f6:	f8 94       	cli
    33f8:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    33fa:	eb 81       	ldd	r30, Y+3	; 0x03
    33fc:	fc 81       	ldd	r31, Y+4	; 0x04
    33fe:	86 8d       	ldd	r24, Z+30	; 0x1e
    3400:	8a 83       	std	Y+2, r24	; 0x02
    3402:	11 c0       	rjmp	.+34     	; 0x3426 <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3404:	eb 81       	ldd	r30, Y+3	; 0x03
    3406:	fc 81       	ldd	r31, Y+4	; 0x04
    3408:	81 89       	ldd	r24, Z+17	; 0x11
    340a:	88 23       	and	r24, r24
    340c:	79 f0       	breq	.+30     	; 0x342c <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    340e:	8b 81       	ldd	r24, Y+3	; 0x03
    3410:	9c 81       	ldd	r25, Y+4	; 0x04
    3412:	41 96       	adiw	r24, 0x11	; 17
    3414:	0e 94 c5 29 	call	0x538a	; 0x538a <xTaskRemoveFromEventList>
    3418:	88 23       	and	r24, r24
    341a:	11 f0       	breq	.+4      	; 0x3420 <prvUnlockQueue+0x3c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    341c:	0e 94 31 2b 	call	0x5662	; 0x5662 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    3420:	8a 81       	ldd	r24, Y+2	; 0x02
    3422:	81 50       	subi	r24, 0x01	; 1
    3424:	8a 83       	std	Y+2, r24	; 0x02
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    3426:	8a 81       	ldd	r24, Y+2	; 0x02
    3428:	18 16       	cp	r1, r24
    342a:	64 f3       	brlt	.-40     	; 0x3404 <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    342c:	eb 81       	ldd	r30, Y+3	; 0x03
    342e:	fc 81       	ldd	r31, Y+4	; 0x04
    3430:	8f ef       	ldi	r24, 0xFF	; 255
    3432:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    3434:	0f 90       	pop	r0
    3436:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    3438:	0f b6       	in	r0, 0x3f	; 63
    343a:	f8 94       	cli
    343c:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    343e:	eb 81       	ldd	r30, Y+3	; 0x03
    3440:	fc 81       	ldd	r31, Y+4	; 0x04
    3442:	85 8d       	ldd	r24, Z+29	; 0x1d
    3444:	89 83       	std	Y+1, r24	; 0x01
    3446:	11 c0       	rjmp	.+34     	; 0x346a <prvUnlockQueue+0x86>

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3448:	eb 81       	ldd	r30, Y+3	; 0x03
    344a:	fc 81       	ldd	r31, Y+4	; 0x04
    344c:	80 85       	ldd	r24, Z+8	; 0x08
    344e:	88 23       	and	r24, r24
    3450:	79 f0       	breq	.+30     	; 0x3470 <prvUnlockQueue+0x8c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3452:	8b 81       	ldd	r24, Y+3	; 0x03
    3454:	9c 81       	ldd	r25, Y+4	; 0x04
    3456:	08 96       	adiw	r24, 0x08	; 8
    3458:	0e 94 c5 29 	call	0x538a	; 0x538a <xTaskRemoveFromEventList>
    345c:	88 23       	and	r24, r24
    345e:	11 f0       	breq	.+4      	; 0x3464 <prvUnlockQueue+0x80>
				{
					vTaskMissedYield();
    3460:	0e 94 31 2b 	call	0x5662	; 0x5662 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    3464:	89 81       	ldd	r24, Y+1	; 0x01
    3466:	81 50       	subi	r24, 0x01	; 1
    3468:	89 83       	std	Y+1, r24	; 0x01
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    346a:	89 81       	ldd	r24, Y+1	; 0x01
    346c:	18 16       	cp	r1, r24
    346e:	64 f3       	brlt	.-40     	; 0x3448 <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    3470:	eb 81       	ldd	r30, Y+3	; 0x03
    3472:	fc 81       	ldd	r31, Y+4	; 0x04
    3474:	8f ef       	ldi	r24, 0xFF	; 255
    3476:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    3478:	0f 90       	pop	r0
    347a:	0f be       	out	0x3f, r0	; 63
}
    347c:	0f 90       	pop	r0
    347e:	0f 90       	pop	r0
    3480:	0f 90       	pop	r0
    3482:	0f 90       	pop	r0
    3484:	cf 91       	pop	r28
    3486:	df 91       	pop	r29
    3488:	08 95       	ret

0000348a <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    348a:	df 93       	push	r29
    348c:	cf 93       	push	r28
    348e:	00 d0       	rcall	.+0      	; 0x3490 <prvIsQueueEmpty+0x6>
    3490:	0f 92       	push	r0
    3492:	cd b7       	in	r28, 0x3d	; 61
    3494:	de b7       	in	r29, 0x3e	; 62
    3496:	9b 83       	std	Y+3, r25	; 0x03
    3498:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    349a:	0f b6       	in	r0, 0x3f	; 63
    349c:	f8 94       	cli
    349e:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    34a0:	ea 81       	ldd	r30, Y+2	; 0x02
    34a2:	fb 81       	ldd	r31, Y+3	; 0x03
    34a4:	82 8d       	ldd	r24, Z+26	; 0x1a
    34a6:	88 23       	and	r24, r24
    34a8:	19 f4       	brne	.+6      	; 0x34b0 <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    34aa:	81 e0       	ldi	r24, 0x01	; 1
    34ac:	89 83       	std	Y+1, r24	; 0x01
    34ae:	01 c0       	rjmp	.+2      	; 0x34b2 <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    34b0:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    34b2:	0f 90       	pop	r0
    34b4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    34b6:	89 81       	ldd	r24, Y+1	; 0x01
}
    34b8:	0f 90       	pop	r0
    34ba:	0f 90       	pop	r0
    34bc:	0f 90       	pop	r0
    34be:	cf 91       	pop	r28
    34c0:	df 91       	pop	r29
    34c2:	08 95       	ret

000034c4 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    34c4:	df 93       	push	r29
    34c6:	cf 93       	push	r28
    34c8:	00 d0       	rcall	.+0      	; 0x34ca <xQueueIsQueueEmptyFromISR+0x6>
    34ca:	00 d0       	rcall	.+0      	; 0x34cc <xQueueIsQueueEmptyFromISR+0x8>
    34cc:	0f 92       	push	r0
    34ce:	cd b7       	in	r28, 0x3d	; 61
    34d0:	de b7       	in	r29, 0x3e	; 62
    34d2:	9d 83       	std	Y+5, r25	; 0x05
    34d4:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    34d6:	8c 81       	ldd	r24, Y+4	; 0x04
    34d8:	9d 81       	ldd	r25, Y+5	; 0x05
    34da:	9a 83       	std	Y+2, r25	; 0x02
    34dc:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    34de:	e9 81       	ldd	r30, Y+1	; 0x01
    34e0:	fa 81       	ldd	r31, Y+2	; 0x02
    34e2:	82 8d       	ldd	r24, Z+26	; 0x1a
    34e4:	88 23       	and	r24, r24
    34e6:	19 f4       	brne	.+6      	; 0x34ee <xQueueIsQueueEmptyFromISR+0x2a>
	{
		xReturn = pdTRUE;
    34e8:	81 e0       	ldi	r24, 0x01	; 1
    34ea:	8b 83       	std	Y+3, r24	; 0x03
    34ec:	01 c0       	rjmp	.+2      	; 0x34f0 <xQueueIsQueueEmptyFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
    34ee:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    34f0:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    34f2:	0f 90       	pop	r0
    34f4:	0f 90       	pop	r0
    34f6:	0f 90       	pop	r0
    34f8:	0f 90       	pop	r0
    34fa:	0f 90       	pop	r0
    34fc:	cf 91       	pop	r28
    34fe:	df 91       	pop	r29
    3500:	08 95       	ret

00003502 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    3502:	df 93       	push	r29
    3504:	cf 93       	push	r28
    3506:	00 d0       	rcall	.+0      	; 0x3508 <prvIsQueueFull+0x6>
    3508:	0f 92       	push	r0
    350a:	cd b7       	in	r28, 0x3d	; 61
    350c:	de b7       	in	r29, 0x3e	; 62
    350e:	9b 83       	std	Y+3, r25	; 0x03
    3510:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    3512:	0f b6       	in	r0, 0x3f	; 63
    3514:	f8 94       	cli
    3516:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    3518:	ea 81       	ldd	r30, Y+2	; 0x02
    351a:	fb 81       	ldd	r31, Y+3	; 0x03
    351c:	92 8d       	ldd	r25, Z+26	; 0x1a
    351e:	ea 81       	ldd	r30, Y+2	; 0x02
    3520:	fb 81       	ldd	r31, Y+3	; 0x03
    3522:	83 8d       	ldd	r24, Z+27	; 0x1b
    3524:	98 17       	cp	r25, r24
    3526:	19 f4       	brne	.+6      	; 0x352e <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    3528:	81 e0       	ldi	r24, 0x01	; 1
    352a:	89 83       	std	Y+1, r24	; 0x01
    352c:	01 c0       	rjmp	.+2      	; 0x3530 <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    352e:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    3530:	0f 90       	pop	r0
    3532:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3534:	89 81       	ldd	r24, Y+1	; 0x01
}
    3536:	0f 90       	pop	r0
    3538:	0f 90       	pop	r0
    353a:	0f 90       	pop	r0
    353c:	cf 91       	pop	r28
    353e:	df 91       	pop	r29
    3540:	08 95       	ret

00003542 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    3542:	df 93       	push	r29
    3544:	cf 93       	push	r28
    3546:	00 d0       	rcall	.+0      	; 0x3548 <xQueueIsQueueFullFromISR+0x6>
    3548:	00 d0       	rcall	.+0      	; 0x354a <xQueueIsQueueFullFromISR+0x8>
    354a:	0f 92       	push	r0
    354c:	cd b7       	in	r28, 0x3d	; 61
    354e:	de b7       	in	r29, 0x3e	; 62
    3550:	9d 83       	std	Y+5, r25	; 0x05
    3552:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    3554:	8c 81       	ldd	r24, Y+4	; 0x04
    3556:	9d 81       	ldd	r25, Y+5	; 0x05
    3558:	9a 83       	std	Y+2, r25	; 0x02
    355a:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    355c:	e9 81       	ldd	r30, Y+1	; 0x01
    355e:	fa 81       	ldd	r31, Y+2	; 0x02
    3560:	92 8d       	ldd	r25, Z+26	; 0x1a
    3562:	e9 81       	ldd	r30, Y+1	; 0x01
    3564:	fa 81       	ldd	r31, Y+2	; 0x02
    3566:	83 8d       	ldd	r24, Z+27	; 0x1b
    3568:	98 17       	cp	r25, r24
    356a:	19 f4       	brne	.+6      	; 0x3572 <xQueueIsQueueFullFromISR+0x30>
	{
		xReturn = pdTRUE;
    356c:	81 e0       	ldi	r24, 0x01	; 1
    356e:	8b 83       	std	Y+3, r24	; 0x03
    3570:	01 c0       	rjmp	.+2      	; 0x3574 <xQueueIsQueueFullFromISR+0x32>
	}
	else
	{
		xReturn = pdFALSE;
    3572:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    3574:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    3576:	0f 90       	pop	r0
    3578:	0f 90       	pop	r0
    357a:	0f 90       	pop	r0
    357c:	0f 90       	pop	r0
    357e:	0f 90       	pop	r0
    3580:	cf 91       	pop	r28
    3582:	df 91       	pop	r29
    3584:	08 95       	ret

00003586 <SwDelay_ms>:
/**
 * Description: this delay function operate in a polling manner
 * 				don't use it with RTOSs
 * @param n: the milli-seconds
 */
void SwDelay_ms(uint32 n) {
    3586:	df 93       	push	r29
    3588:	cf 93       	push	r28
    358a:	cd b7       	in	r28, 0x3d	; 61
    358c:	de b7       	in	r29, 0x3e	; 62
    358e:	28 97       	sbiw	r28, 0x08	; 8
    3590:	0f b6       	in	r0, 0x3f	; 63
    3592:	f8 94       	cli
    3594:	de bf       	out	0x3e, r29	; 62
    3596:	0f be       	out	0x3f, r0	; 63
    3598:	cd bf       	out	0x3d, r28	; 61
    359a:	6d 83       	std	Y+5, r22	; 0x05
    359c:	7e 83       	std	Y+6, r23	; 0x06
    359e:	8f 83       	std	Y+7, r24	; 0x07
    35a0:	98 87       	std	Y+8, r25	; 0x08
	 }
	 }
	 }
	 */

	for (i = 0; i < n * 220; i++) {
    35a2:	19 82       	std	Y+1, r1	; 0x01
    35a4:	1a 82       	std	Y+2, r1	; 0x02
    35a6:	1b 82       	std	Y+3, r1	; 0x03
    35a8:	1c 82       	std	Y+4, r1	; 0x04
    35aa:	0b c0       	rjmp	.+22     	; 0x35c2 <SwDelay_ms+0x3c>
    35ac:	89 81       	ldd	r24, Y+1	; 0x01
    35ae:	9a 81       	ldd	r25, Y+2	; 0x02
    35b0:	ab 81       	ldd	r26, Y+3	; 0x03
    35b2:	bc 81       	ldd	r27, Y+4	; 0x04
    35b4:	01 96       	adiw	r24, 0x01	; 1
    35b6:	a1 1d       	adc	r26, r1
    35b8:	b1 1d       	adc	r27, r1
    35ba:	89 83       	std	Y+1, r24	; 0x01
    35bc:	9a 83       	std	Y+2, r25	; 0x02
    35be:	ab 83       	std	Y+3, r26	; 0x03
    35c0:	bc 83       	std	Y+4, r27	; 0x04
    35c2:	8d 81       	ldd	r24, Y+5	; 0x05
    35c4:	9e 81       	ldd	r25, Y+6	; 0x06
    35c6:	af 81       	ldd	r26, Y+7	; 0x07
    35c8:	b8 85       	ldd	r27, Y+8	; 0x08
    35ca:	2c ed       	ldi	r18, 0xDC	; 220
    35cc:	30 e0       	ldi	r19, 0x00	; 0
    35ce:	40 e0       	ldi	r20, 0x00	; 0
    35d0:	50 e0       	ldi	r21, 0x00	; 0
    35d2:	bc 01       	movw	r22, r24
    35d4:	cd 01       	movw	r24, r26
    35d6:	0e 94 10 32 	call	0x6420	; 0x6420 <__mulsi3>
    35da:	9b 01       	movw	r18, r22
    35dc:	ac 01       	movw	r20, r24
    35de:	89 81       	ldd	r24, Y+1	; 0x01
    35e0:	9a 81       	ldd	r25, Y+2	; 0x02
    35e2:	ab 81       	ldd	r26, Y+3	; 0x03
    35e4:	bc 81       	ldd	r27, Y+4	; 0x04
    35e6:	82 17       	cp	r24, r18
    35e8:	93 07       	cpc	r25, r19
    35ea:	a4 07       	cpc	r26, r20
    35ec:	b5 07       	cpc	r27, r21
    35ee:	f0 f2       	brcs	.-68     	; 0x35ac <SwDelay_ms+0x26>
		/*for (j = 0; j < (n * 1000); j++) {

		 }*/
	}
}
    35f0:	28 96       	adiw	r28, 0x08	; 8
    35f2:	0f b6       	in	r0, 0x3f	; 63
    35f4:	f8 94       	cli
    35f6:	de bf       	out	0x3e, r29	; 62
    35f8:	0f be       	out	0x3f, r0	; 63
    35fa:	cd bf       	out	0x3d, r28	; 61
    35fc:	cf 91       	pop	r28
    35fe:	df 91       	pop	r29
    3600:	08 95       	ret

00003602 <SwDelay_us>:
/**
 * Description: this delay function operate in a polling manner
 * 				don't use it with RTOSs
 * @param n: the micro-seconds
 */
void SwDelay_us(uint32 n){
    3602:	df 93       	push	r29
    3604:	cf 93       	push	r28
    3606:	00 d0       	rcall	.+0      	; 0x3608 <SwDelay_us+0x6>
    3608:	00 d0       	rcall	.+0      	; 0x360a <SwDelay_us+0x8>
    360a:	0f 92       	push	r0
    360c:	cd b7       	in	r28, 0x3d	; 61
    360e:	de b7       	in	r29, 0x3e	; 62
    3610:	69 83       	std	Y+1, r22	; 0x01
    3612:	7a 83       	std	Y+2, r23	; 0x02
    3614:	8b 83       	std	Y+3, r24	; 0x03
    3616:	9c 83       	std	Y+4, r25	; 0x04
	while(n--);
    3618:	1d 82       	std	Y+5, r1	; 0x05
    361a:	89 81       	ldd	r24, Y+1	; 0x01
    361c:	9a 81       	ldd	r25, Y+2	; 0x02
    361e:	ab 81       	ldd	r26, Y+3	; 0x03
    3620:	bc 81       	ldd	r27, Y+4	; 0x04
    3622:	00 97       	sbiw	r24, 0x00	; 0
    3624:	a1 05       	cpc	r26, r1
    3626:	b1 05       	cpc	r27, r1
    3628:	11 f0       	breq	.+4      	; 0x362e <SwDelay_us+0x2c>
    362a:	81 e0       	ldi	r24, 0x01	; 1
    362c:	8d 83       	std	Y+5, r24	; 0x05
    362e:	89 81       	ldd	r24, Y+1	; 0x01
    3630:	9a 81       	ldd	r25, Y+2	; 0x02
    3632:	ab 81       	ldd	r26, Y+3	; 0x03
    3634:	bc 81       	ldd	r27, Y+4	; 0x04
    3636:	01 97       	sbiw	r24, 0x01	; 1
    3638:	a1 09       	sbc	r26, r1
    363a:	b1 09       	sbc	r27, r1
    363c:	89 83       	std	Y+1, r24	; 0x01
    363e:	9a 83       	std	Y+2, r25	; 0x02
    3640:	ab 83       	std	Y+3, r26	; 0x03
    3642:	bc 83       	std	Y+4, r27	; 0x04
    3644:	8d 81       	ldd	r24, Y+5	; 0x05
    3646:	88 23       	and	r24, r24
    3648:	39 f7       	brne	.-50     	; 0x3618 <SwDelay_us+0x16>
}
    364a:	0f 90       	pop	r0
    364c:	0f 90       	pop	r0
    364e:	0f 90       	pop	r0
    3650:	0f 90       	pop	r0
    3652:	0f 90       	pop	r0
    3654:	cf 91       	pop	r28
    3656:	df 91       	pop	r29
    3658:	08 95       	ret

0000365a <xStreamBufferGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer )
	{
    365a:	0f 93       	push	r16
    365c:	df 93       	push	r29
    365e:	cf 93       	push	r28
    3660:	cd b7       	in	r28, 0x3d	; 61
    3662:	de b7       	in	r29, 0x3e	; 62
    3664:	28 97       	sbiw	r28, 0x08	; 8
    3666:	0f b6       	in	r0, 0x3f	; 63
    3668:	f8 94       	cli
    366a:	de bf       	out	0x3e, r29	; 62
    366c:	0f be       	out	0x3f, r0	; 63
    366e:	cd bf       	out	0x3d, r28	; 61
    3670:	9d 83       	std	Y+5, r25	; 0x05
    3672:	8c 83       	std	Y+4, r24	; 0x04
    3674:	7f 83       	std	Y+7, r23	; 0x07
    3676:	6e 83       	std	Y+6, r22	; 0x06
    3678:	48 87       	std	Y+8, r20	; 0x08

		/* In case the stream buffer is going to be used as a message buffer
		(that is, it will hold discrete messages with a little meta data that
		says how big the next message is) check the buffer will be large enough
		to hold at least one message. */
		if( xIsMessageBuffer == pdTRUE )
    367a:	88 85       	ldd	r24, Y+8	; 0x08
    367c:	81 30       	cpi	r24, 0x01	; 1
    367e:	19 f4       	brne	.+6      	; 0x3686 <xStreamBufferGenericCreate+0x2c>
		{
			/* Is a message buffer but not statically allocated. */
			ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
    3680:	81 e0       	ldi	r24, 0x01	; 1
    3682:	89 83       	std	Y+1, r24	; 0x01
    3684:	01 c0       	rjmp	.+2      	; 0x3688 <xStreamBufferGenericCreate+0x2e>
			configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
		}
		else
		{
			/* Not a message buffer and not statically allocated. */
			ucFlags = 0;
    3686:	19 82       	std	Y+1, r1	; 0x01
		}
		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

		/* A trigger level of 0 would cause a waiting task to unblock even when
		the buffer was empty. */
		if( xTriggerLevelBytes == ( size_t ) 0 )
    3688:	8e 81       	ldd	r24, Y+6	; 0x06
    368a:	9f 81       	ldd	r25, Y+7	; 0x07
    368c:	00 97       	sbiw	r24, 0x00	; 0
    368e:	21 f4       	brne	.+8      	; 0x3698 <xStreamBufferGenericCreate+0x3e>
		{
			xTriggerLevelBytes = ( size_t ) 1;
    3690:	81 e0       	ldi	r24, 0x01	; 1
    3692:	90 e0       	ldi	r25, 0x00	; 0
    3694:	9f 83       	std	Y+7, r25	; 0x07
    3696:	8e 83       	std	Y+6, r24	; 0x06
		and the buffer follows immediately after.  The requested size is
		incremented so the free space is returned as the user would expect -
		this is a quirk of the implementation that means otherwise the free
		space would be reported as one byte smaller than would be logically
		expected. */
		xBufferSizeBytes++;
    3698:	8c 81       	ldd	r24, Y+4	; 0x04
    369a:	9d 81       	ldd	r25, Y+5	; 0x05
    369c:	01 96       	adiw	r24, 0x01	; 1
    369e:	9d 83       	std	Y+5, r25	; 0x05
    36a0:	8c 83       	std	Y+4, r24	; 0x04
		pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
    36a2:	8c 81       	ldd	r24, Y+4	; 0x04
    36a4:	9d 81       	ldd	r25, Y+5	; 0x05
    36a6:	0f 96       	adiw	r24, 0x0f	; 15
    36a8:	0e 94 02 09 	call	0x1204	; 0x1204 <pvPortMalloc>
    36ac:	9b 83       	std	Y+3, r25	; 0x03
    36ae:	8a 83       	std	Y+2, r24	; 0x02

		if( pucAllocatedMemory != NULL )
    36b0:	8a 81       	ldd	r24, Y+2	; 0x02
    36b2:	9b 81       	ldd	r25, Y+3	; 0x03
    36b4:	00 97       	sbiw	r24, 0x00	; 0
    36b6:	89 f0       	breq	.+34     	; 0x36da <xStreamBufferGenericCreate+0x80>
		{
			prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory, /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
    36b8:	6a 81       	ldd	r22, Y+2	; 0x02
    36ba:	7b 81       	ldd	r23, Y+3	; 0x03
    36bc:	8a 81       	ldd	r24, Y+2	; 0x02
    36be:	9b 81       	ldd	r25, Y+3	; 0x03
    36c0:	9c 01       	movw	r18, r24
    36c2:	21 5f       	subi	r18, 0xF1	; 241
    36c4:	3f 4f       	sbci	r19, 0xFF	; 255
    36c6:	4c 81       	ldd	r20, Y+4	; 0x04
    36c8:	5d 81       	ldd	r21, Y+5	; 0x05
    36ca:	ee 81       	ldd	r30, Y+6	; 0x06
    36cc:	ff 81       	ldd	r31, Y+7	; 0x07
    36ce:	cb 01       	movw	r24, r22
    36d0:	b9 01       	movw	r22, r18
    36d2:	9f 01       	movw	r18, r30
    36d4:	09 81       	ldd	r16, Y+1	; 0x01
    36d6:	0e 94 85 22 	call	0x450a	; 0x450a <prvInitialiseNewStreamBuffer>
		else
		{
			traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
		}

		return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
    36da:	8a 81       	ldd	r24, Y+2	; 0x02
    36dc:	9b 81       	ldd	r25, Y+3	; 0x03
	}
    36de:	28 96       	adiw	r28, 0x08	; 8
    36e0:	0f b6       	in	r0, 0x3f	; 63
    36e2:	f8 94       	cli
    36e4:	de bf       	out	0x3e, r29	; 62
    36e6:	0f be       	out	0x3f, r0	; 63
    36e8:	cd bf       	out	0x3d, r28	; 61
    36ea:	cf 91       	pop	r28
    36ec:	df 91       	pop	r29
    36ee:	0f 91       	pop	r16
    36f0:	08 95       	ret

000036f2 <vStreamBufferDelete>:

#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
    36f2:	df 93       	push	r29
    36f4:	cf 93       	push	r28
    36f6:	00 d0       	rcall	.+0      	; 0x36f8 <vStreamBufferDelete+0x6>
    36f8:	00 d0       	rcall	.+0      	; 0x36fa <vStreamBufferDelete+0x8>
    36fa:	cd b7       	in	r28, 0x3d	; 61
    36fc:	de b7       	in	r29, 0x3e	; 62
    36fe:	9c 83       	std	Y+4, r25	; 0x04
    3700:	8b 83       	std	Y+3, r24	; 0x03
StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
    3702:	8b 81       	ldd	r24, Y+3	; 0x03
    3704:	9c 81       	ldd	r25, Y+4	; 0x04
    3706:	9a 83       	std	Y+2, r25	; 0x02
    3708:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxStreamBuffer );

	traceSTREAM_BUFFER_DELETE( xStreamBuffer );

	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
    370a:	e9 81       	ldd	r30, Y+1	; 0x01
    370c:	fa 81       	ldd	r31, Y+2	; 0x02
    370e:	86 85       	ldd	r24, Z+14	; 0x0e
    3710:	88 2f       	mov	r24, r24
    3712:	90 e0       	ldi	r25, 0x00	; 0
    3714:	82 70       	andi	r24, 0x02	; 2
    3716:	90 70       	andi	r25, 0x00	; 0
    3718:	00 97       	sbiw	r24, 0x00	; 0
    371a:	29 f4       	brne	.+10     	; 0x3726 <vStreamBufferDelete+0x34>
	{
		#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
		{
			/* Both the structure and the buffer were allocated using a single call
			to pvPortMalloc(), hence only one call to vPortFree() is required. */
			vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
    371c:	89 81       	ldd	r24, Y+1	; 0x01
    371e:	9a 81       	ldd	r25, Y+2	; 0x02
    3720:	0e 94 58 09 	call	0x12b0	; 0x12b0 <vPortFree>
    3724:	08 c0       	rjmp	.+16     	; 0x3736 <vStreamBufferDelete+0x44>
	}
	else
	{
		/* The structure and buffer were not allocated dynamically and cannot be
		freed - just scrub the structure so future use will assert. */
		( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
    3726:	89 81       	ldd	r24, Y+1	; 0x01
    3728:	9a 81       	ldd	r25, Y+2	; 0x02
    372a:	60 e0       	ldi	r22, 0x00	; 0
    372c:	70 e0       	ldi	r23, 0x00	; 0
    372e:	4f e0       	ldi	r20, 0x0F	; 15
    3730:	50 e0       	ldi	r21, 0x00	; 0
    3732:	0e 94 96 32 	call	0x652c	; 0x652c <memset>
	}
}
    3736:	0f 90       	pop	r0
    3738:	0f 90       	pop	r0
    373a:	0f 90       	pop	r0
    373c:	0f 90       	pop	r0
    373e:	cf 91       	pop	r28
    3740:	df 91       	pop	r29
    3742:	08 95       	ret

00003744 <xStreamBufferReset>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
    3744:	0f 93       	push	r16
    3746:	df 93       	push	r29
    3748:	cf 93       	push	r28
    374a:	00 d0       	rcall	.+0      	; 0x374c <xStreamBufferReset+0x8>
    374c:	00 d0       	rcall	.+0      	; 0x374e <xStreamBufferReset+0xa>
    374e:	0f 92       	push	r0
    3750:	cd b7       	in	r28, 0x3d	; 61
    3752:	de b7       	in	r29, 0x3e	; 62
    3754:	9d 83       	std	Y+5, r25	; 0x05
    3756:	8c 83       	std	Y+4, r24	; 0x04
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3758:	8c 81       	ldd	r24, Y+4	; 0x04
    375a:	9d 81       	ldd	r25, Y+5	; 0x05
    375c:	9b 83       	std	Y+3, r25	; 0x03
    375e:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn = pdFAIL;
    3760:	19 82       	std	Y+1, r1	; 0x01
		uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
	}
	#endif

	/* Can only reset a message buffer if there are no tasks blocked on it. */
	taskENTER_CRITICAL();
    3762:	0f b6       	in	r0, 0x3f	; 63
    3764:	f8 94       	cli
    3766:	0f 92       	push	r0
	{
		if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
    3768:	ea 81       	ldd	r30, Y+2	; 0x02
    376a:	fb 81       	ldd	r31, Y+3	; 0x03
    376c:	80 85       	ldd	r24, Z+8	; 0x08
    376e:	91 85       	ldd	r25, Z+9	; 0x09
    3770:	00 97       	sbiw	r24, 0x00	; 0
    3772:	f1 f4       	brne	.+60     	; 0x37b0 <xStreamBufferReset+0x6c>
		{
			if( pxStreamBuffer->xTaskWaitingToSend == NULL )
    3774:	ea 81       	ldd	r30, Y+2	; 0x02
    3776:	fb 81       	ldd	r31, Y+3	; 0x03
    3778:	82 85       	ldd	r24, Z+10	; 0x0a
    377a:	93 85       	ldd	r25, Z+11	; 0x0b
    377c:	00 97       	sbiw	r24, 0x00	; 0
    377e:	c1 f4       	brne	.+48     	; 0x37b0 <xStreamBufferReset+0x6c>
			{
				prvInitialiseNewStreamBuffer( pxStreamBuffer,
    3780:	ea 81       	ldd	r30, Y+2	; 0x02
    3782:	fb 81       	ldd	r31, Y+3	; 0x03
    3784:	24 85       	ldd	r18, Z+12	; 0x0c
    3786:	35 85       	ldd	r19, Z+13	; 0x0d
    3788:	ea 81       	ldd	r30, Y+2	; 0x02
    378a:	fb 81       	ldd	r31, Y+3	; 0x03
    378c:	44 81       	ldd	r20, Z+4	; 0x04
    378e:	55 81       	ldd	r21, Z+5	; 0x05
    3790:	ea 81       	ldd	r30, Y+2	; 0x02
    3792:	fb 81       	ldd	r31, Y+3	; 0x03
    3794:	a6 81       	ldd	r26, Z+6	; 0x06
    3796:	b7 81       	ldd	r27, Z+7	; 0x07
    3798:	ea 81       	ldd	r30, Y+2	; 0x02
    379a:	fb 81       	ldd	r31, Y+3	; 0x03
    379c:	e6 85       	ldd	r30, Z+14	; 0x0e
    379e:	8a 81       	ldd	r24, Y+2	; 0x02
    37a0:	9b 81       	ldd	r25, Y+3	; 0x03
    37a2:	b9 01       	movw	r22, r18
    37a4:	9d 01       	movw	r18, r26
    37a6:	0e 2f       	mov	r16, r30
    37a8:	0e 94 85 22 	call	0x450a	; 0x450a <prvInitialiseNewStreamBuffer>
											  pxStreamBuffer->pucBuffer,
											  pxStreamBuffer->xLength,
											  pxStreamBuffer->xTriggerLevelBytes,
											  pxStreamBuffer->ucFlags );
				xReturn = pdPASS;
    37ac:	81 e0       	ldi	r24, 0x01	; 1
    37ae:	89 83       	std	Y+1, r24	; 0x01

				traceSTREAM_BUFFER_RESET( xStreamBuffer );
			}
		}
	}
	taskEXIT_CRITICAL();
    37b0:	0f 90       	pop	r0
    37b2:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    37b4:	89 81       	ldd	r24, Y+1	; 0x01
}
    37b6:	0f 90       	pop	r0
    37b8:	0f 90       	pop	r0
    37ba:	0f 90       	pop	r0
    37bc:	0f 90       	pop	r0
    37be:	0f 90       	pop	r0
    37c0:	cf 91       	pop	r28
    37c2:	df 91       	pop	r29
    37c4:	0f 91       	pop	r16
    37c6:	08 95       	ret

000037c8 <xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel )
{
    37c8:	df 93       	push	r29
    37ca:	cf 93       	push	r28
    37cc:	cd b7       	in	r28, 0x3d	; 61
    37ce:	de b7       	in	r29, 0x3e	; 62
    37d0:	27 97       	sbiw	r28, 0x07	; 7
    37d2:	0f b6       	in	r0, 0x3f	; 63
    37d4:	f8 94       	cli
    37d6:	de bf       	out	0x3e, r29	; 62
    37d8:	0f be       	out	0x3f, r0	; 63
    37da:	cd bf       	out	0x3d, r28	; 61
    37dc:	9d 83       	std	Y+5, r25	; 0x05
    37de:	8c 83       	std	Y+4, r24	; 0x04
    37e0:	7f 83       	std	Y+7, r23	; 0x07
    37e2:	6e 83       	std	Y+6, r22	; 0x06
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    37e4:	8c 81       	ldd	r24, Y+4	; 0x04
    37e6:	9d 81       	ldd	r25, Y+5	; 0x05
    37e8:	9b 83       	std	Y+3, r25	; 0x03
    37ea:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( pxStreamBuffer );

	/* It is not valid for the trigger level to be 0. */
	if( xTriggerLevel == ( size_t ) 0 )
    37ec:	8e 81       	ldd	r24, Y+6	; 0x06
    37ee:	9f 81       	ldd	r25, Y+7	; 0x07
    37f0:	00 97       	sbiw	r24, 0x00	; 0
    37f2:	21 f4       	brne	.+8      	; 0x37fc <xStreamBufferSetTriggerLevel+0x34>
	{
		xTriggerLevel = ( size_t ) 1;
    37f4:	81 e0       	ldi	r24, 0x01	; 1
    37f6:	90 e0       	ldi	r25, 0x00	; 0
    37f8:	9f 83       	std	Y+7, r25	; 0x07
    37fa:	8e 83       	std	Y+6, r24	; 0x06
	}

	/* The trigger level is the number of bytes that must be in the stream
	buffer before a task that is waiting for data is unblocked. */
	if( xTriggerLevel <= pxStreamBuffer->xLength )
    37fc:	ea 81       	ldd	r30, Y+2	; 0x02
    37fe:	fb 81       	ldd	r31, Y+3	; 0x03
    3800:	24 81       	ldd	r18, Z+4	; 0x04
    3802:	35 81       	ldd	r19, Z+5	; 0x05
    3804:	8e 81       	ldd	r24, Y+6	; 0x06
    3806:	9f 81       	ldd	r25, Y+7	; 0x07
    3808:	28 17       	cp	r18, r24
    380a:	39 07       	cpc	r19, r25
    380c:	48 f0       	brcs	.+18     	; 0x3820 <xStreamBufferSetTriggerLevel+0x58>
	{
		pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
    380e:	ea 81       	ldd	r30, Y+2	; 0x02
    3810:	fb 81       	ldd	r31, Y+3	; 0x03
    3812:	8e 81       	ldd	r24, Y+6	; 0x06
    3814:	9f 81       	ldd	r25, Y+7	; 0x07
    3816:	97 83       	std	Z+7, r25	; 0x07
    3818:	86 83       	std	Z+6, r24	; 0x06
		xReturn = pdPASS;
    381a:	81 e0       	ldi	r24, 0x01	; 1
    381c:	89 83       	std	Y+1, r24	; 0x01
    381e:	01 c0       	rjmp	.+2      	; 0x3822 <xStreamBufferSetTriggerLevel+0x5a>
	}
	else
	{
		xReturn = pdFALSE;
    3820:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3822:	89 81       	ldd	r24, Y+1	; 0x01
}
    3824:	27 96       	adiw	r28, 0x07	; 7
    3826:	0f b6       	in	r0, 0x3f	; 63
    3828:	f8 94       	cli
    382a:	de bf       	out	0x3e, r29	; 62
    382c:	0f be       	out	0x3f, r0	; 63
    382e:	cd bf       	out	0x3d, r28	; 61
    3830:	cf 91       	pop	r28
    3832:	df 91       	pop	r29
    3834:	08 95       	ret

00003836 <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    3836:	df 93       	push	r29
    3838:	cf 93       	push	r28
    383a:	00 d0       	rcall	.+0      	; 0x383c <xStreamBufferSpacesAvailable+0x6>
    383c:	00 d0       	rcall	.+0      	; 0x383e <xStreamBufferSpacesAvailable+0x8>
    383e:	00 d0       	rcall	.+0      	; 0x3840 <xStreamBufferSpacesAvailable+0xa>
    3840:	cd b7       	in	r28, 0x3d	; 61
    3842:	de b7       	in	r29, 0x3e	; 62
    3844:	9e 83       	std	Y+6, r25	; 0x06
    3846:	8d 83       	std	Y+5, r24	; 0x05
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3848:	8d 81       	ldd	r24, Y+5	; 0x05
    384a:	9e 81       	ldd	r25, Y+6	; 0x06
    384c:	9c 83       	std	Y+4, r25	; 0x04
    384e:	8b 83       	std	Y+3, r24	; 0x03
size_t xSpace;

	configASSERT( pxStreamBuffer );

	xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    3850:	eb 81       	ldd	r30, Y+3	; 0x03
    3852:	fc 81       	ldd	r31, Y+4	; 0x04
    3854:	24 81       	ldd	r18, Z+4	; 0x04
    3856:	35 81       	ldd	r19, Z+5	; 0x05
    3858:	eb 81       	ldd	r30, Y+3	; 0x03
    385a:	fc 81       	ldd	r31, Y+4	; 0x04
    385c:	80 81       	ld	r24, Z
    385e:	91 81       	ldd	r25, Z+1	; 0x01
    3860:	82 0f       	add	r24, r18
    3862:	93 1f       	adc	r25, r19
    3864:	9a 83       	std	Y+2, r25	; 0x02
    3866:	89 83       	std	Y+1, r24	; 0x01
	xSpace -= pxStreamBuffer->xHead;
    3868:	eb 81       	ldd	r30, Y+3	; 0x03
    386a:	fc 81       	ldd	r31, Y+4	; 0x04
    386c:	22 81       	ldd	r18, Z+2	; 0x02
    386e:	33 81       	ldd	r19, Z+3	; 0x03
    3870:	89 81       	ldd	r24, Y+1	; 0x01
    3872:	9a 81       	ldd	r25, Y+2	; 0x02
    3874:	82 1b       	sub	r24, r18
    3876:	93 0b       	sbc	r25, r19
    3878:	9a 83       	std	Y+2, r25	; 0x02
    387a:	89 83       	std	Y+1, r24	; 0x01
	xSpace -= ( size_t ) 1;
    387c:	89 81       	ldd	r24, Y+1	; 0x01
    387e:	9a 81       	ldd	r25, Y+2	; 0x02
    3880:	01 97       	sbiw	r24, 0x01	; 1
    3882:	9a 83       	std	Y+2, r25	; 0x02
    3884:	89 83       	std	Y+1, r24	; 0x01

	if( xSpace >= pxStreamBuffer->xLength )
    3886:	eb 81       	ldd	r30, Y+3	; 0x03
    3888:	fc 81       	ldd	r31, Y+4	; 0x04
    388a:	24 81       	ldd	r18, Z+4	; 0x04
    388c:	35 81       	ldd	r19, Z+5	; 0x05
    388e:	89 81       	ldd	r24, Y+1	; 0x01
    3890:	9a 81       	ldd	r25, Y+2	; 0x02
    3892:	82 17       	cp	r24, r18
    3894:	93 07       	cpc	r25, r19
    3896:	50 f0       	brcs	.+20     	; 0x38ac <xStreamBufferSpacesAvailable+0x76>
	{
		xSpace -= pxStreamBuffer->xLength;
    3898:	eb 81       	ldd	r30, Y+3	; 0x03
    389a:	fc 81       	ldd	r31, Y+4	; 0x04
    389c:	24 81       	ldd	r18, Z+4	; 0x04
    389e:	35 81       	ldd	r19, Z+5	; 0x05
    38a0:	89 81       	ldd	r24, Y+1	; 0x01
    38a2:	9a 81       	ldd	r25, Y+2	; 0x02
    38a4:	82 1b       	sub	r24, r18
    38a6:	93 0b       	sbc	r25, r19
    38a8:	9a 83       	std	Y+2, r25	; 0x02
    38aa:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xSpace;
    38ac:	89 81       	ldd	r24, Y+1	; 0x01
    38ae:	9a 81       	ldd	r25, Y+2	; 0x02
}
    38b0:	26 96       	adiw	r28, 0x06	; 6
    38b2:	0f b6       	in	r0, 0x3f	; 63
    38b4:	f8 94       	cli
    38b6:	de bf       	out	0x3e, r29	; 62
    38b8:	0f be       	out	0x3f, r0	; 63
    38ba:	cd bf       	out	0x3d, r28	; 61
    38bc:	cf 91       	pop	r28
    38be:	df 91       	pop	r29
    38c0:	08 95       	ret

000038c2 <xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    38c2:	df 93       	push	r29
    38c4:	cf 93       	push	r28
    38c6:	00 d0       	rcall	.+0      	; 0x38c8 <xStreamBufferBytesAvailable+0x6>
    38c8:	00 d0       	rcall	.+0      	; 0x38ca <xStreamBufferBytesAvailable+0x8>
    38ca:	00 d0       	rcall	.+0      	; 0x38cc <xStreamBufferBytesAvailable+0xa>
    38cc:	cd b7       	in	r28, 0x3d	; 61
    38ce:	de b7       	in	r29, 0x3e	; 62
    38d0:	9e 83       	std	Y+6, r25	; 0x06
    38d2:	8d 83       	std	Y+5, r24	; 0x05
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    38d4:	8d 81       	ldd	r24, Y+5	; 0x05
    38d6:	9e 81       	ldd	r25, Y+6	; 0x06
    38d8:	9c 83       	std	Y+4, r25	; 0x04
    38da:	8b 83       	std	Y+3, r24	; 0x03
size_t xReturn;

	configASSERT( pxStreamBuffer );

	xReturn = prvBytesInBuffer( pxStreamBuffer );
    38dc:	8b 81       	ldd	r24, Y+3	; 0x03
    38de:	9c 81       	ldd	r25, Y+4	; 0x04
    38e0:	0e 94 4b 22 	call	0x4496	; 0x4496 <prvBytesInBuffer>
    38e4:	9a 83       	std	Y+2, r25	; 0x02
    38e6:	89 83       	std	Y+1, r24	; 0x01
	return xReturn;
    38e8:	89 81       	ldd	r24, Y+1	; 0x01
    38ea:	9a 81       	ldd	r25, Y+2	; 0x02
}
    38ec:	26 96       	adiw	r28, 0x06	; 6
    38ee:	0f b6       	in	r0, 0x3f	; 63
    38f0:	f8 94       	cli
    38f2:	de bf       	out	0x3e, r29	; 62
    38f4:	0f be       	out	0x3f, r0	; 63
    38f6:	cd bf       	out	0x3d, r28	; 61
    38f8:	cf 91       	pop	r28
    38fa:	df 91       	pop	r29
    38fc:	08 95       	ret

000038fe <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
						  const void *pvTxData,
						  size_t xDataLengthBytes,
						  TickType_t xTicksToWait )
{
    38fe:	ef 92       	push	r14
    3900:	ff 92       	push	r15
    3902:	0f 93       	push	r16
    3904:	1f 93       	push	r17
    3906:	df 93       	push	r29
    3908:	cf 93       	push	r28
    390a:	cd b7       	in	r28, 0x3d	; 61
    390c:	de b7       	in	r29, 0x3e	; 62
    390e:	63 97       	sbiw	r28, 0x13	; 19
    3910:	0f b6       	in	r0, 0x3f	; 63
    3912:	f8 94       	cli
    3914:	de bf       	out	0x3e, r29	; 62
    3916:	0f be       	out	0x3f, r0	; 63
    3918:	cd bf       	out	0x3d, r28	; 61
    391a:	9d 87       	std	Y+13, r25	; 0x0d
    391c:	8c 87       	std	Y+12, r24	; 0x0c
    391e:	7f 87       	std	Y+15, r23	; 0x0f
    3920:	6e 87       	std	Y+14, r22	; 0x0e
    3922:	59 8b       	std	Y+17, r21	; 0x11
    3924:	48 8b       	std	Y+16, r20	; 0x10
    3926:	3b 8b       	std	Y+19, r19	; 0x13
    3928:	2a 8b       	std	Y+18, r18	; 0x12
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    392a:	8c 85       	ldd	r24, Y+12	; 0x0c
    392c:	9d 85       	ldd	r25, Y+13	; 0x0d
    392e:	98 87       	std	Y+8, r25	; 0x08
    3930:	8f 83       	std	Y+7, r24	; 0x07
size_t xReturn, xSpace = 0;
    3932:	1c 82       	std	Y+4, r1	; 0x04
    3934:	1b 82       	std	Y+3, r1	; 0x03
size_t xRequiredSpace = xDataLengthBytes;
    3936:	88 89       	ldd	r24, Y+16	; 0x10
    3938:	99 89       	ldd	r25, Y+17	; 0x11
    393a:	9a 83       	std	Y+2, r25	; 0x02
    393c:	89 83       	std	Y+1, r24	; 0x01

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    393e:	ef 81       	ldd	r30, Y+7	; 0x07
    3940:	f8 85       	ldd	r31, Y+8	; 0x08
    3942:	86 85       	ldd	r24, Z+14	; 0x0e
    3944:	88 2f       	mov	r24, r24
    3946:	90 e0       	ldi	r25, 0x00	; 0
    3948:	81 70       	andi	r24, 0x01	; 1
    394a:	90 70       	andi	r25, 0x00	; 0
    394c:	88 23       	and	r24, r24
    394e:	29 f0       	breq	.+10     	; 0x395a <xStreamBufferSend+0x5c>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3950:	89 81       	ldd	r24, Y+1	; 0x01
    3952:	9a 81       	ldd	r25, Y+2	; 0x02
    3954:	02 96       	adiw	r24, 0x02	; 2
    3956:	9a 83       	std	Y+2, r25	; 0x02
    3958:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    395a:	8a 89       	ldd	r24, Y+18	; 0x12
    395c:	9b 89       	ldd	r25, Y+19	; 0x13
    395e:	00 97       	sbiw	r24, 0x00	; 0
    3960:	09 f4       	brne	.+2      	; 0x3964 <xStreamBufferSend+0x66>
    3962:	40 c0       	rjmp	.+128    	; 0x39e4 <xStreamBufferSend+0xe6>
	{
		vTaskSetTimeOutState( &xTimeOut );
    3964:	ce 01       	movw	r24, r28
    3966:	09 96       	adiw	r24, 0x09	; 9
    3968:	0e 94 8d 2a 	call	0x551a	; 0x551a <vTaskSetTimeOutState>

		do
		{
			/* Wait until the required number of bytes are free in the message
			buffer. */
			taskENTER_CRITICAL();
    396c:	0f b6       	in	r0, 0x3f	; 63
    396e:	f8 94       	cli
    3970:	0f 92       	push	r0
			{
				xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    3972:	8f 81       	ldd	r24, Y+7	; 0x07
    3974:	98 85       	ldd	r25, Y+8	; 0x08
    3976:	0e 94 1b 1c 	call	0x3836	; 0x3836 <xStreamBufferSpacesAvailable>
    397a:	9c 83       	std	Y+4, r25	; 0x04
    397c:	8b 83       	std	Y+3, r24	; 0x03

				if( xSpace < xRequiredSpace )
    397e:	2b 81       	ldd	r18, Y+3	; 0x03
    3980:	3c 81       	ldd	r19, Y+4	; 0x04
    3982:	89 81       	ldd	r24, Y+1	; 0x01
    3984:	9a 81       	ldd	r25, Y+2	; 0x02
    3986:	28 17       	cp	r18, r24
    3988:	39 07       	cpc	r19, r25
    398a:	50 f5       	brcc	.+84     	; 0x39e0 <xStreamBufferSend+0xe2>
				{
					/* Clear notification state as going to wait for space. */
					( void ) xTaskNotifyStateClear( NULL );
    398c:	80 e0       	ldi	r24, 0x00	; 0
    398e:	90 e0       	ldi	r25, 0x00	; 0
    3990:	0e 94 5a 31 	call	0x62b4	; 0x62b4 <xTaskNotifyStateClear>

					/* Should only be one writer. */
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
    3994:	0e 94 f6 2b 	call	0x57ec	; 0x57ec <xTaskGetCurrentTaskHandle>
    3998:	ef 81       	ldd	r30, Y+7	; 0x07
    399a:	f8 85       	ldd	r31, Y+8	; 0x08
    399c:	93 87       	std	Z+11, r25	; 0x0b
    399e:	82 87       	std	Z+10, r24	; 0x0a
				{
					taskEXIT_CRITICAL();
					break;
				}
			}
			taskEXIT_CRITICAL();
    39a0:	0f 90       	pop	r0
    39a2:	0f be       	out	0x3f, r0	; 63

			traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    39a4:	ea 89       	ldd	r30, Y+18	; 0x12
    39a6:	fb 89       	ldd	r31, Y+19	; 0x13
    39a8:	60 e0       	ldi	r22, 0x00	; 0
    39aa:	70 e0       	ldi	r23, 0x00	; 0
    39ac:	80 e0       	ldi	r24, 0x00	; 0
    39ae:	90 e0       	ldi	r25, 0x00	; 0
    39b0:	20 e0       	ldi	r18, 0x00	; 0
    39b2:	30 e0       	ldi	r19, 0x00	; 0
    39b4:	40 e0       	ldi	r20, 0x00	; 0
    39b6:	50 e0       	ldi	r21, 0x00	; 0
    39b8:	00 e0       	ldi	r16, 0x00	; 0
    39ba:	10 e0       	ldi	r17, 0x00	; 0
    39bc:	7f 01       	movw	r14, r30
    39be:	0e 94 63 2e 	call	0x5cc6	; 0x5cc6 <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToSend = NULL;
    39c2:	ef 81       	ldd	r30, Y+7	; 0x07
    39c4:	f8 85       	ldd	r31, Y+8	; 0x08
    39c6:	13 86       	std	Z+11, r1	; 0x0b
    39c8:	12 86       	std	Z+10, r1	; 0x0a

		} while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
    39ca:	ce 01       	movw	r24, r28
    39cc:	09 96       	adiw	r24, 0x09	; 9
    39ce:	9e 01       	movw	r18, r28
    39d0:	2e 5e       	subi	r18, 0xEE	; 238
    39d2:	3f 4f       	sbci	r19, 0xFF	; 255
    39d4:	b9 01       	movw	r22, r18
    39d6:	0e 94 c4 2a 	call	0x5588	; 0x5588 <xTaskCheckForTimeOut>
    39da:	88 23       	and	r24, r24
    39dc:	39 f2       	breq	.-114    	; 0x396c <xStreamBufferSend+0x6e>
    39de:	02 c0       	rjmp	.+4      	; 0x39e4 <xStreamBufferSend+0xe6>
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
				}
				else
				{
					taskEXIT_CRITICAL();
    39e0:	0f 90       	pop	r0
    39e2:	0f be       	out	0x3f, r0	; 63
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xSpace == ( size_t ) 0 )
    39e4:	8b 81       	ldd	r24, Y+3	; 0x03
    39e6:	9c 81       	ldd	r25, Y+4	; 0x04
    39e8:	00 97       	sbiw	r24, 0x00	; 0
    39ea:	31 f4       	brne	.+12     	; 0x39f8 <xStreamBufferSend+0xfa>
	{
		xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    39ec:	8f 81       	ldd	r24, Y+7	; 0x07
    39ee:	98 85       	ldd	r25, Y+8	; 0x08
    39f0:	0e 94 1b 1c 	call	0x3836	; 0x3836 <xStreamBufferSpacesAvailable>
    39f4:	9c 83       	std	Y+4, r25	; 0x04
    39f6:	8b 83       	std	Y+3, r24	; 0x03
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    39f8:	8f 81       	ldd	r24, Y+7	; 0x07
    39fa:	98 85       	ldd	r25, Y+8	; 0x08
    39fc:	2e 85       	ldd	r18, Y+14	; 0x0e
    39fe:	3f 85       	ldd	r19, Y+15	; 0x0f
    3a00:	48 89       	ldd	r20, Y+16	; 0x10
    3a02:	59 89       	ldd	r21, Y+17	; 0x11
    3a04:	eb 81       	ldd	r30, Y+3	; 0x03
    3a06:	fc 81       	ldd	r31, Y+4	; 0x04
    3a08:	a9 81       	ldd	r26, Y+1	; 0x01
    3a0a:	ba 81       	ldd	r27, Y+2	; 0x02
    3a0c:	b9 01       	movw	r22, r18
    3a0e:	9f 01       	movw	r18, r30
    3a10:	8d 01       	movw	r16, r26
    3a12:	0e 94 c4 1d 	call	0x3b88	; 0x3b88 <prvWriteMessageToBuffer>
    3a16:	9e 83       	std	Y+6, r25	; 0x06
    3a18:	8d 83       	std	Y+5, r24	; 0x05

	if( xReturn > ( size_t ) 0 )
    3a1a:	8d 81       	ldd	r24, Y+5	; 0x05
    3a1c:	9e 81       	ldd	r25, Y+6	; 0x06
    3a1e:	00 97       	sbiw	r24, 0x00	; 0
    3a20:	39 f1       	breq	.+78     	; 0x3a70 <xStreamBufferSend+0x172>
	{
		traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    3a22:	8f 81       	ldd	r24, Y+7	; 0x07
    3a24:	98 85       	ldd	r25, Y+8	; 0x08
    3a26:	0e 94 4b 22 	call	0x4496	; 0x4496 <prvBytesInBuffer>
    3a2a:	9c 01       	movw	r18, r24
    3a2c:	ef 81       	ldd	r30, Y+7	; 0x07
    3a2e:	f8 85       	ldd	r31, Y+8	; 0x08
    3a30:	86 81       	ldd	r24, Z+6	; 0x06
    3a32:	97 81       	ldd	r25, Z+7	; 0x07
    3a34:	28 17       	cp	r18, r24
    3a36:	39 07       	cpc	r19, r25
    3a38:	d8 f0       	brcs	.+54     	; 0x3a70 <xStreamBufferSend+0x172>
		{
			sbSEND_COMPLETED( pxStreamBuffer );
    3a3a:	0e 94 25 27 	call	0x4e4a	; 0x4e4a <vTaskSuspendAll>
    3a3e:	ef 81       	ldd	r30, Y+7	; 0x07
    3a40:	f8 85       	ldd	r31, Y+8	; 0x08
    3a42:	80 85       	ldd	r24, Z+8	; 0x08
    3a44:	91 85       	ldd	r25, Z+9	; 0x09
    3a46:	00 97       	sbiw	r24, 0x00	; 0
    3a48:	89 f0       	breq	.+34     	; 0x3a6c <xStreamBufferSend+0x16e>
    3a4a:	ef 81       	ldd	r30, Y+7	; 0x07
    3a4c:	f8 85       	ldd	r31, Y+8	; 0x08
    3a4e:	80 85       	ldd	r24, Z+8	; 0x08
    3a50:	91 85       	ldd	r25, Z+9	; 0x09
    3a52:	40 e0       	ldi	r20, 0x00	; 0
    3a54:	50 e0       	ldi	r21, 0x00	; 0
    3a56:	60 e0       	ldi	r22, 0x00	; 0
    3a58:	70 e0       	ldi	r23, 0x00	; 0
    3a5a:	20 e0       	ldi	r18, 0x00	; 0
    3a5c:	00 e0       	ldi	r16, 0x00	; 0
    3a5e:	10 e0       	ldi	r17, 0x00	; 0
    3a60:	0e 94 ff 2e 	call	0x5dfe	; 0x5dfe <xTaskGenericNotify>
    3a64:	ef 81       	ldd	r30, Y+7	; 0x07
    3a66:	f8 85       	ldd	r31, Y+8	; 0x08
    3a68:	11 86       	std	Z+9, r1	; 0x09
    3a6a:	10 86       	std	Z+8, r1	; 0x08
    3a6c:	0e 94 31 27 	call	0x4e62	; 0x4e62 <xTaskResumeAll>
	{
		mtCOVERAGE_TEST_MARKER();
		traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
	}

	return xReturn;
    3a70:	8d 81       	ldd	r24, Y+5	; 0x05
    3a72:	9e 81       	ldd	r25, Y+6	; 0x06
}
    3a74:	63 96       	adiw	r28, 0x13	; 19
    3a76:	0f b6       	in	r0, 0x3f	; 63
    3a78:	f8 94       	cli
    3a7a:	de bf       	out	0x3e, r29	; 62
    3a7c:	0f be       	out	0x3f, r0	; 63
    3a7e:	cd bf       	out	0x3d, r28	; 61
    3a80:	cf 91       	pop	r28
    3a82:	df 91       	pop	r29
    3a84:	1f 91       	pop	r17
    3a86:	0f 91       	pop	r16
    3a88:	ff 90       	pop	r15
    3a8a:	ef 90       	pop	r14
    3a8c:	08 95       	ret

00003a8e <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
								 const void *pvTxData,
								 size_t xDataLengthBytes,
								 BaseType_t * const pxHigherPriorityTaskWoken )
{
    3a8e:	ef 92       	push	r14
    3a90:	ff 92       	push	r15
    3a92:	0f 93       	push	r16
    3a94:	1f 93       	push	r17
    3a96:	df 93       	push	r29
    3a98:	cf 93       	push	r28
    3a9a:	cd b7       	in	r28, 0x3d	; 61
    3a9c:	de b7       	in	r29, 0x3e	; 62
    3a9e:	61 97       	sbiw	r28, 0x11	; 17
    3aa0:	0f b6       	in	r0, 0x3f	; 63
    3aa2:	f8 94       	cli
    3aa4:	de bf       	out	0x3e, r29	; 62
    3aa6:	0f be       	out	0x3f, r0	; 63
    3aa8:	cd bf       	out	0x3d, r28	; 61
    3aaa:	9b 87       	std	Y+11, r25	; 0x0b
    3aac:	8a 87       	std	Y+10, r24	; 0x0a
    3aae:	7d 87       	std	Y+13, r23	; 0x0d
    3ab0:	6c 87       	std	Y+12, r22	; 0x0c
    3ab2:	5f 87       	std	Y+15, r21	; 0x0f
    3ab4:	4e 87       	std	Y+14, r20	; 0x0e
    3ab6:	39 8b       	std	Y+17, r19	; 0x11
    3ab8:	28 8b       	std	Y+16, r18	; 0x10
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3aba:	8a 85       	ldd	r24, Y+10	; 0x0a
    3abc:	9b 85       	ldd	r25, Y+11	; 0x0b
    3abe:	99 87       	std	Y+9, r25	; 0x09
    3ac0:	88 87       	std	Y+8, r24	; 0x08
size_t xReturn, xSpace;
size_t xRequiredSpace = xDataLengthBytes;
    3ac2:	8e 85       	ldd	r24, Y+14	; 0x0e
    3ac4:	9f 85       	ldd	r25, Y+15	; 0x0f
    3ac6:	9b 83       	std	Y+3, r25	; 0x03
    3ac8:	8a 83       	std	Y+2, r24	; 0x02

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3aca:	e8 85       	ldd	r30, Y+8	; 0x08
    3acc:	f9 85       	ldd	r31, Y+9	; 0x09
    3ace:	86 85       	ldd	r24, Z+14	; 0x0e
    3ad0:	88 2f       	mov	r24, r24
    3ad2:	90 e0       	ldi	r25, 0x00	; 0
    3ad4:	81 70       	andi	r24, 0x01	; 1
    3ad6:	90 70       	andi	r25, 0x00	; 0
    3ad8:	88 23       	and	r24, r24
    3ada:	29 f0       	breq	.+10     	; 0x3ae6 <xStreamBufferSendFromISR+0x58>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3adc:	8a 81       	ldd	r24, Y+2	; 0x02
    3ade:	9b 81       	ldd	r25, Y+3	; 0x03
    3ae0:	02 96       	adiw	r24, 0x02	; 2
    3ae2:	9b 83       	std	Y+3, r25	; 0x03
    3ae4:	8a 83       	std	Y+2, r24	; 0x02
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    3ae6:	88 85       	ldd	r24, Y+8	; 0x08
    3ae8:	99 85       	ldd	r25, Y+9	; 0x09
    3aea:	0e 94 1b 1c 	call	0x3836	; 0x3836 <xStreamBufferSpacesAvailable>
    3aee:	9d 83       	std	Y+5, r25	; 0x05
    3af0:	8c 83       	std	Y+4, r24	; 0x04
	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    3af2:	88 85       	ldd	r24, Y+8	; 0x08
    3af4:	99 85       	ldd	r25, Y+9	; 0x09
    3af6:	2c 85       	ldd	r18, Y+12	; 0x0c
    3af8:	3d 85       	ldd	r19, Y+13	; 0x0d
    3afa:	4e 85       	ldd	r20, Y+14	; 0x0e
    3afc:	5f 85       	ldd	r21, Y+15	; 0x0f
    3afe:	ec 81       	ldd	r30, Y+4	; 0x04
    3b00:	fd 81       	ldd	r31, Y+5	; 0x05
    3b02:	aa 81       	ldd	r26, Y+2	; 0x02
    3b04:	bb 81       	ldd	r27, Y+3	; 0x03
    3b06:	b9 01       	movw	r22, r18
    3b08:	9f 01       	movw	r18, r30
    3b0a:	8d 01       	movw	r16, r26
    3b0c:	0e 94 c4 1d 	call	0x3b88	; 0x3b88 <prvWriteMessageToBuffer>
    3b10:	9f 83       	std	Y+7, r25	; 0x07
    3b12:	8e 83       	std	Y+6, r24	; 0x06

	if( xReturn > ( size_t ) 0 )
    3b14:	8e 81       	ldd	r24, Y+6	; 0x06
    3b16:	9f 81       	ldd	r25, Y+7	; 0x07
    3b18:	00 97       	sbiw	r24, 0x00	; 0
    3b1a:	39 f1       	breq	.+78     	; 0x3b6a <xStreamBufferSendFromISR+0xdc>
	{
		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    3b1c:	88 85       	ldd	r24, Y+8	; 0x08
    3b1e:	99 85       	ldd	r25, Y+9	; 0x09
    3b20:	0e 94 4b 22 	call	0x4496	; 0x4496 <prvBytesInBuffer>
    3b24:	9c 01       	movw	r18, r24
    3b26:	e8 85       	ldd	r30, Y+8	; 0x08
    3b28:	f9 85       	ldd	r31, Y+9	; 0x09
    3b2a:	86 81       	ldd	r24, Z+6	; 0x06
    3b2c:	97 81       	ldd	r25, Z+7	; 0x07
    3b2e:	28 17       	cp	r18, r24
    3b30:	39 07       	cpc	r19, r25
    3b32:	d8 f0       	brcs	.+54     	; 0x3b6a <xStreamBufferSendFromISR+0xdc>
		{
			sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    3b34:	19 82       	std	Y+1, r1	; 0x01
    3b36:	e8 85       	ldd	r30, Y+8	; 0x08
    3b38:	f9 85       	ldd	r31, Y+9	; 0x09
    3b3a:	80 85       	ldd	r24, Z+8	; 0x08
    3b3c:	91 85       	ldd	r25, Z+9	; 0x09
    3b3e:	00 97       	sbiw	r24, 0x00	; 0
    3b40:	a1 f0       	breq	.+40     	; 0x3b6a <xStreamBufferSendFromISR+0xdc>
    3b42:	e8 85       	ldd	r30, Y+8	; 0x08
    3b44:	f9 85       	ldd	r31, Y+9	; 0x09
    3b46:	80 85       	ldd	r24, Z+8	; 0x08
    3b48:	91 85       	ldd	r25, Z+9	; 0x09
    3b4a:	e8 89       	ldd	r30, Y+16	; 0x10
    3b4c:	f9 89       	ldd	r31, Y+17	; 0x11
    3b4e:	40 e0       	ldi	r20, 0x00	; 0
    3b50:	50 e0       	ldi	r21, 0x00	; 0
    3b52:	60 e0       	ldi	r22, 0x00	; 0
    3b54:	70 e0       	ldi	r23, 0x00	; 0
    3b56:	20 e0       	ldi	r18, 0x00	; 0
    3b58:	00 e0       	ldi	r16, 0x00	; 0
    3b5a:	10 e0       	ldi	r17, 0x00	; 0
    3b5c:	7f 01       	movw	r14, r30
    3b5e:	0e 94 dc 2f 	call	0x5fb8	; 0x5fb8 <xTaskGenericNotifyFromISR>
    3b62:	e8 85       	ldd	r30, Y+8	; 0x08
    3b64:	f9 85       	ldd	r31, Y+9	; 0x09
    3b66:	11 86       	std	Z+9, r1	; 0x09
    3b68:	10 86       	std	Z+8, r1	; 0x08
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

	return xReturn;
    3b6a:	8e 81       	ldd	r24, Y+6	; 0x06
    3b6c:	9f 81       	ldd	r25, Y+7	; 0x07
}
    3b6e:	61 96       	adiw	r28, 0x11	; 17
    3b70:	0f b6       	in	r0, 0x3f	; 63
    3b72:	f8 94       	cli
    3b74:	de bf       	out	0x3e, r29	; 62
    3b76:	0f be       	out	0x3f, r0	; 63
    3b78:	cd bf       	out	0x3d, r28	; 61
    3b7a:	cf 91       	pop	r28
    3b7c:	df 91       	pop	r29
    3b7e:	1f 91       	pop	r17
    3b80:	0f 91       	pop	r16
    3b82:	ff 90       	pop	r15
    3b84:	ef 90       	pop	r14
    3b86:	08 95       	ret

00003b88 <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
									   const void * pvTxData,
									   size_t xDataLengthBytes,
									   size_t xSpace,
									   size_t xRequiredSpace )
{
    3b88:	0f 93       	push	r16
    3b8a:	1f 93       	push	r17
    3b8c:	df 93       	push	r29
    3b8e:	cf 93       	push	r28
    3b90:	cd b7       	in	r28, 0x3d	; 61
    3b92:	de b7       	in	r29, 0x3e	; 62
    3b94:	61 97       	sbiw	r28, 0x11	; 17
    3b96:	0f b6       	in	r0, 0x3f	; 63
    3b98:	f8 94       	cli
    3b9a:	de bf       	out	0x3e, r29	; 62
    3b9c:	0f be       	out	0x3f, r0	; 63
    3b9e:	cd bf       	out	0x3d, r28	; 61
    3ba0:	9d 83       	std	Y+5, r25	; 0x05
    3ba2:	8c 83       	std	Y+4, r24	; 0x04
    3ba4:	7f 83       	std	Y+7, r23	; 0x07
    3ba6:	6e 83       	std	Y+6, r22	; 0x06
    3ba8:	59 87       	std	Y+9, r21	; 0x09
    3baa:	48 87       	std	Y+8, r20	; 0x08
    3bac:	3b 87       	std	Y+11, r19	; 0x0b
    3bae:	2a 87       	std	Y+10, r18	; 0x0a
    3bb0:	1d 87       	std	Y+13, r17	; 0x0d
    3bb2:	0c 87       	std	Y+12, r16	; 0x0c
	BaseType_t xShouldWrite;
	size_t xReturn;

	if( xSpace == ( size_t ) 0 )
    3bb4:	8a 85       	ldd	r24, Y+10	; 0x0a
    3bb6:	9b 85       	ldd	r25, Y+11	; 0x0b
    3bb8:	00 97       	sbiw	r24, 0x00	; 0
    3bba:	11 f4       	brne	.+4      	; 0x3bc0 <prvWriteMessageToBuffer+0x38>
	{
		/* Doesn't matter if this is a stream buffer or a message buffer, there
		is no space to write. */
		xShouldWrite = pdFALSE;
    3bbc:	1b 82       	std	Y+3, r1	; 0x03
    3bbe:	38 c0       	rjmp	.+112    	; 0x3c30 <prvWriteMessageToBuffer+0xa8>
	}
	else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )
    3bc0:	ec 81       	ldd	r30, Y+4	; 0x04
    3bc2:	fd 81       	ldd	r31, Y+5	; 0x05
    3bc4:	86 85       	ldd	r24, Z+14	; 0x0e
    3bc6:	88 2f       	mov	r24, r24
    3bc8:	90 e0       	ldi	r25, 0x00	; 0
    3bca:	81 70       	andi	r24, 0x01	; 1
    3bcc:	90 70       	andi	r25, 0x00	; 0
    3bce:	00 97       	sbiw	r24, 0x00	; 0
    3bd0:	d1 f4       	brne	.+52     	; 0x3c06 <prvWriteMessageToBuffer+0x7e>
	{
		/* This is a stream buffer, as opposed to a message buffer, so writing a
		stream of bytes rather than discrete messages.  Write as many bytes as
		possible. */
		xShouldWrite = pdTRUE;
    3bd2:	81 e0       	ldi	r24, 0x01	; 1
    3bd4:	8b 83       	std	Y+3, r24	; 0x03
		xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
    3bd6:	28 85       	ldd	r18, Y+8	; 0x08
    3bd8:	39 85       	ldd	r19, Y+9	; 0x09
    3bda:	39 8b       	std	Y+17, r19	; 0x11
    3bdc:	28 8b       	std	Y+16, r18	; 0x10
    3bde:	8a 85       	ldd	r24, Y+10	; 0x0a
    3be0:	9b 85       	ldd	r25, Y+11	; 0x0b
    3be2:	9f 87       	std	Y+15, r25	; 0x0f
    3be4:	8e 87       	std	Y+14, r24	; 0x0e
    3be6:	2e 85       	ldd	r18, Y+14	; 0x0e
    3be8:	3f 85       	ldd	r19, Y+15	; 0x0f
    3bea:	88 89       	ldd	r24, Y+16	; 0x10
    3bec:	99 89       	ldd	r25, Y+17	; 0x11
    3bee:	82 17       	cp	r24, r18
    3bf0:	93 07       	cpc	r25, r19
    3bf2:	20 f4       	brcc	.+8      	; 0x3bfc <prvWriteMessageToBuffer+0x74>
    3bf4:	28 89       	ldd	r18, Y+16	; 0x10
    3bf6:	39 89       	ldd	r19, Y+17	; 0x11
    3bf8:	3f 87       	std	Y+15, r19	; 0x0f
    3bfa:	2e 87       	std	Y+14, r18	; 0x0e
    3bfc:	8e 85       	ldd	r24, Y+14	; 0x0e
    3bfe:	9f 85       	ldd	r25, Y+15	; 0x0f
    3c00:	99 87       	std	Y+9, r25	; 0x09
    3c02:	88 87       	std	Y+8, r24	; 0x08
    3c04:	15 c0       	rjmp	.+42     	; 0x3c30 <prvWriteMessageToBuffer+0xa8>
	}
	else if( xSpace >= xRequiredSpace )
    3c06:	2a 85       	ldd	r18, Y+10	; 0x0a
    3c08:	3b 85       	ldd	r19, Y+11	; 0x0b
    3c0a:	8c 85       	ldd	r24, Y+12	; 0x0c
    3c0c:	9d 85       	ldd	r25, Y+13	; 0x0d
    3c0e:	28 17       	cp	r18, r24
    3c10:	39 07       	cpc	r19, r25
    3c12:	68 f0       	brcs	.+26     	; 0x3c2e <prvWriteMessageToBuffer+0xa6>
	{
		/* This is a message buffer, as opposed to a stream buffer, and there
		is enough space to write both the message length and the message itself
		into the buffer.  Start by writing the length of the data, the data
		itself will be written later in this function. */
		xShouldWrite = pdTRUE;
    3c14:	81 e0       	ldi	r24, 0x01	; 1
    3c16:	8b 83       	std	Y+3, r24	; 0x03
		( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );
    3c18:	9e 01       	movw	r18, r28
    3c1a:	28 5f       	subi	r18, 0xF8	; 248
    3c1c:	3f 4f       	sbci	r19, 0xFF	; 255
    3c1e:	8c 81       	ldd	r24, Y+4	; 0x04
    3c20:	9d 81       	ldd	r25, Y+5	; 0x05
    3c22:	b9 01       	movw	r22, r18
    3c24:	42 e0       	ldi	r20, 0x02	; 2
    3c26:	50 e0       	ldi	r21, 0x00	; 0
    3c28:	0e 94 11 21 	call	0x4222	; 0x4222 <prvWriteBytesToBuffer>
    3c2c:	01 c0       	rjmp	.+2      	; 0x3c30 <prvWriteMessageToBuffer+0xa8>
	}
	else
	{
		/* There is space available, but not enough space. */
		xShouldWrite = pdFALSE;
    3c2e:	1b 82       	std	Y+3, r1	; 0x03
	}

	if( xShouldWrite != pdFALSE )
    3c30:	8b 81       	ldd	r24, Y+3	; 0x03
    3c32:	88 23       	and	r24, r24
    3c34:	61 f0       	breq	.+24     	; 0x3c4e <prvWriteMessageToBuffer+0xc6>
	{
		/* Writes the data itself. */
		xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alighment and access. */
    3c36:	2e 81       	ldd	r18, Y+6	; 0x06
    3c38:	3f 81       	ldd	r19, Y+7	; 0x07
    3c3a:	48 85       	ldd	r20, Y+8	; 0x08
    3c3c:	59 85       	ldd	r21, Y+9	; 0x09
    3c3e:	8c 81       	ldd	r24, Y+4	; 0x04
    3c40:	9d 81       	ldd	r25, Y+5	; 0x05
    3c42:	b9 01       	movw	r22, r18
    3c44:	0e 94 11 21 	call	0x4222	; 0x4222 <prvWriteBytesToBuffer>
    3c48:	9a 83       	std	Y+2, r25	; 0x02
    3c4a:	89 83       	std	Y+1, r24	; 0x01
    3c4c:	02 c0       	rjmp	.+4      	; 0x3c52 <prvWriteMessageToBuffer+0xca>
	}
	else
	{
		xReturn = 0;
    3c4e:	1a 82       	std	Y+2, r1	; 0x02
    3c50:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3c52:	89 81       	ldd	r24, Y+1	; 0x01
    3c54:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3c56:	61 96       	adiw	r28, 0x11	; 17
    3c58:	0f b6       	in	r0, 0x3f	; 63
    3c5a:	f8 94       	cli
    3c5c:	de bf       	out	0x3e, r29	; 62
    3c5e:	0f be       	out	0x3f, r0	; 63
    3c60:	cd bf       	out	0x3d, r28	; 61
    3c62:	cf 91       	pop	r28
    3c64:	df 91       	pop	r29
    3c66:	1f 91       	pop	r17
    3c68:	0f 91       	pop	r16
    3c6a:	08 95       	ret

00003c6c <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
							 void *pvRxData,
							 size_t xBufferLengthBytes,
							 TickType_t xTicksToWait )
{
    3c6c:	ef 92       	push	r14
    3c6e:	ff 92       	push	r15
    3c70:	0f 93       	push	r16
    3c72:	1f 93       	push	r17
    3c74:	df 93       	push	r29
    3c76:	cf 93       	push	r28
    3c78:	cd b7       	in	r28, 0x3d	; 61
    3c7a:	de b7       	in	r29, 0x3e	; 62
    3c7c:	60 97       	sbiw	r28, 0x10	; 16
    3c7e:	0f b6       	in	r0, 0x3f	; 63
    3c80:	f8 94       	cli
    3c82:	de bf       	out	0x3e, r29	; 62
    3c84:	0f be       	out	0x3f, r0	; 63
    3c86:	cd bf       	out	0x3d, r28	; 61
    3c88:	9a 87       	std	Y+10, r25	; 0x0a
    3c8a:	89 87       	std	Y+9, r24	; 0x09
    3c8c:	7c 87       	std	Y+12, r23	; 0x0c
    3c8e:	6b 87       	std	Y+11, r22	; 0x0b
    3c90:	5e 87       	std	Y+14, r21	; 0x0e
    3c92:	4d 87       	std	Y+13, r20	; 0x0d
    3c94:	38 8b       	std	Y+16, r19	; 0x10
    3c96:	2f 87       	std	Y+15, r18	; 0x0f
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3c98:	89 85       	ldd	r24, Y+9	; 0x09
    3c9a:	9a 85       	ldd	r25, Y+10	; 0x0a
    3c9c:	98 87       	std	Y+8, r25	; 0x08
    3c9e:	8f 83       	std	Y+7, r24	; 0x07
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    3ca0:	1e 82       	std	Y+6, r1	; 0x06
    3ca2:	1d 82       	std	Y+5, r1	; 0x05
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3ca4:	ef 81       	ldd	r30, Y+7	; 0x07
    3ca6:	f8 85       	ldd	r31, Y+8	; 0x08
    3ca8:	86 85       	ldd	r24, Z+14	; 0x0e
    3caa:	88 2f       	mov	r24, r24
    3cac:	90 e0       	ldi	r25, 0x00	; 0
    3cae:	81 70       	andi	r24, 0x01	; 1
    3cb0:	90 70       	andi	r25, 0x00	; 0
    3cb2:	88 23       	and	r24, r24
    3cb4:	29 f0       	breq	.+10     	; 0x3cc0 <xStreamBufferReceive+0x54>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3cb6:	82 e0       	ldi	r24, 0x02	; 2
    3cb8:	90 e0       	ldi	r25, 0x00	; 0
    3cba:	9a 83       	std	Y+2, r25	; 0x02
    3cbc:	89 83       	std	Y+1, r24	; 0x01
    3cbe:	02 c0       	rjmp	.+4      	; 0x3cc4 <xStreamBufferReceive+0x58>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    3cc0:	1a 82       	std	Y+2, r1	; 0x02
    3cc2:	19 82       	std	Y+1, r1	; 0x01
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    3cc4:	8f 85       	ldd	r24, Y+15	; 0x0f
    3cc6:	98 89       	ldd	r25, Y+16	; 0x10
    3cc8:	00 97       	sbiw	r24, 0x00	; 0
    3cca:	09 f4       	brne	.+2      	; 0x3cce <xStreamBufferReceive+0x62>
    3ccc:	3d c0       	rjmp	.+122    	; 0x3d48 <xStreamBufferReceive+0xdc>
	{
		/* Checking if there is data and clearing the notification state must be
		performed atomically. */
		taskENTER_CRITICAL();
    3cce:	0f b6       	in	r0, 0x3f	; 63
    3cd0:	f8 94       	cli
    3cd2:	0f 92       	push	r0
		{
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3cd4:	8f 81       	ldd	r24, Y+7	; 0x07
    3cd6:	98 85       	ldd	r25, Y+8	; 0x08
    3cd8:	0e 94 4b 22 	call	0x4496	; 0x4496 <prvBytesInBuffer>
    3cdc:	9c 83       	std	Y+4, r25	; 0x04
    3cde:	8b 83       	std	Y+3, r24	; 0x03
			/* If this function was invoked by a message buffer read then
			xBytesToStoreMessageLength holds the number of bytes used to hold
			the length of the next discrete message.  If this function was
			invoked by a stream buffer read then xBytesToStoreMessageLength will
			be 0. */
			if( xBytesAvailable <= xBytesToStoreMessageLength )
    3ce0:	2b 81       	ldd	r18, Y+3	; 0x03
    3ce2:	3c 81       	ldd	r19, Y+4	; 0x04
    3ce4:	89 81       	ldd	r24, Y+1	; 0x01
    3ce6:	9a 81       	ldd	r25, Y+2	; 0x02
    3ce8:	82 17       	cp	r24, r18
    3cea:	93 07       	cpc	r25, r19
    3cec:	50 f0       	brcs	.+20     	; 0x3d02 <xStreamBufferReceive+0x96>
			{
				/* Clear notification state as going to wait for data. */
				( void ) xTaskNotifyStateClear( NULL );
    3cee:	80 e0       	ldi	r24, 0x00	; 0
    3cf0:	90 e0       	ldi	r25, 0x00	; 0
    3cf2:	0e 94 5a 31 	call	0x62b4	; 0x62b4 <xTaskNotifyStateClear>

				/* Should only be one reader. */
				configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
				pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
    3cf6:	0e 94 f6 2b 	call	0x57ec	; 0x57ec <xTaskGetCurrentTaskHandle>
    3cfa:	ef 81       	ldd	r30, Y+7	; 0x07
    3cfc:	f8 85       	ldd	r31, Y+8	; 0x08
    3cfe:	91 87       	std	Z+9, r25	; 0x09
    3d00:	80 87       	std	Z+8, r24	; 0x08
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    3d02:	0f 90       	pop	r0
    3d04:	0f be       	out	0x3f, r0	; 63

		if( xBytesAvailable <= xBytesToStoreMessageLength )
    3d06:	2b 81       	ldd	r18, Y+3	; 0x03
    3d08:	3c 81       	ldd	r19, Y+4	; 0x04
    3d0a:	89 81       	ldd	r24, Y+1	; 0x01
    3d0c:	9a 81       	ldd	r25, Y+2	; 0x02
    3d0e:	82 17       	cp	r24, r18
    3d10:	93 07       	cpc	r25, r19
    3d12:	00 f1       	brcs	.+64     	; 0x3d54 <xStreamBufferReceive+0xe8>
		{
			/* Wait for data to be available. */
			traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    3d14:	ef 85       	ldd	r30, Y+15	; 0x0f
    3d16:	f8 89       	ldd	r31, Y+16	; 0x10
    3d18:	60 e0       	ldi	r22, 0x00	; 0
    3d1a:	70 e0       	ldi	r23, 0x00	; 0
    3d1c:	80 e0       	ldi	r24, 0x00	; 0
    3d1e:	90 e0       	ldi	r25, 0x00	; 0
    3d20:	20 e0       	ldi	r18, 0x00	; 0
    3d22:	30 e0       	ldi	r19, 0x00	; 0
    3d24:	40 e0       	ldi	r20, 0x00	; 0
    3d26:	50 e0       	ldi	r21, 0x00	; 0
    3d28:	00 e0       	ldi	r16, 0x00	; 0
    3d2a:	10 e0       	ldi	r17, 0x00	; 0
    3d2c:	7f 01       	movw	r14, r30
    3d2e:	0e 94 63 2e 	call	0x5cc6	; 0x5cc6 <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToReceive = NULL;
    3d32:	ef 81       	ldd	r30, Y+7	; 0x07
    3d34:	f8 85       	ldd	r31, Y+8	; 0x08
    3d36:	11 86       	std	Z+9, r1	; 0x09
    3d38:	10 86       	std	Z+8, r1	; 0x08

			/* Recheck the data available after blocking. */
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3d3a:	8f 81       	ldd	r24, Y+7	; 0x07
    3d3c:	98 85       	ldd	r25, Y+8	; 0x08
    3d3e:	0e 94 4b 22 	call	0x4496	; 0x4496 <prvBytesInBuffer>
    3d42:	9c 83       	std	Y+4, r25	; 0x04
    3d44:	8b 83       	std	Y+3, r24	; 0x03
    3d46:	06 c0       	rjmp	.+12     	; 0x3d54 <xStreamBufferReceive+0xe8>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3d48:	8f 81       	ldd	r24, Y+7	; 0x07
    3d4a:	98 85       	ldd	r25, Y+8	; 0x08
    3d4c:	0e 94 4b 22 	call	0x4496	; 0x4496 <prvBytesInBuffer>
    3d50:	9c 83       	std	Y+4, r25	; 0x04
    3d52:	8b 83       	std	Y+3, r24	; 0x03
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    3d54:	2b 81       	ldd	r18, Y+3	; 0x03
    3d56:	3c 81       	ldd	r19, Y+4	; 0x04
    3d58:	89 81       	ldd	r24, Y+1	; 0x01
    3d5a:	9a 81       	ldd	r25, Y+2	; 0x02
    3d5c:	82 17       	cp	r24, r18
    3d5e:	93 07       	cpc	r25, r19
    3d60:	80 f5       	brcc	.+96     	; 0x3dc2 <xStreamBufferReceive+0x156>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    3d62:	8f 81       	ldd	r24, Y+7	; 0x07
    3d64:	98 85       	ldd	r25, Y+8	; 0x08
    3d66:	2b 85       	ldd	r18, Y+11	; 0x0b
    3d68:	3c 85       	ldd	r19, Y+12	; 0x0c
    3d6a:	4d 85       	ldd	r20, Y+13	; 0x0d
    3d6c:	5e 85       	ldd	r21, Y+14	; 0x0e
    3d6e:	eb 81       	ldd	r30, Y+3	; 0x03
    3d70:	fc 81       	ldd	r31, Y+4	; 0x04
    3d72:	a9 81       	ldd	r26, Y+1	; 0x01
    3d74:	ba 81       	ldd	r27, Y+2	; 0x02
    3d76:	b9 01       	movw	r22, r18
    3d78:	9f 01       	movw	r18, r30
    3d7a:	8d 01       	movw	r16, r26
    3d7c:	0e 94 ba 1f 	call	0x3f74	; 0x3f74 <prvReadMessageFromBuffer>
    3d80:	9e 83       	std	Y+6, r25	; 0x06
    3d82:	8d 83       	std	Y+5, r24	; 0x05

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    3d84:	8d 81       	ldd	r24, Y+5	; 0x05
    3d86:	9e 81       	ldd	r25, Y+6	; 0x06
    3d88:	00 97       	sbiw	r24, 0x00	; 0
    3d8a:	d9 f0       	breq	.+54     	; 0x3dc2 <xStreamBufferReceive+0x156>
		{
			traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
			sbRECEIVE_COMPLETED( pxStreamBuffer );
    3d8c:	0e 94 25 27 	call	0x4e4a	; 0x4e4a <vTaskSuspendAll>
    3d90:	ef 81       	ldd	r30, Y+7	; 0x07
    3d92:	f8 85       	ldd	r31, Y+8	; 0x08
    3d94:	82 85       	ldd	r24, Z+10	; 0x0a
    3d96:	93 85       	ldd	r25, Z+11	; 0x0b
    3d98:	00 97       	sbiw	r24, 0x00	; 0
    3d9a:	89 f0       	breq	.+34     	; 0x3dbe <xStreamBufferReceive+0x152>
    3d9c:	ef 81       	ldd	r30, Y+7	; 0x07
    3d9e:	f8 85       	ldd	r31, Y+8	; 0x08
    3da0:	82 85       	ldd	r24, Z+10	; 0x0a
    3da2:	93 85       	ldd	r25, Z+11	; 0x0b
    3da4:	40 e0       	ldi	r20, 0x00	; 0
    3da6:	50 e0       	ldi	r21, 0x00	; 0
    3da8:	60 e0       	ldi	r22, 0x00	; 0
    3daa:	70 e0       	ldi	r23, 0x00	; 0
    3dac:	20 e0       	ldi	r18, 0x00	; 0
    3dae:	00 e0       	ldi	r16, 0x00	; 0
    3db0:	10 e0       	ldi	r17, 0x00	; 0
    3db2:	0e 94 ff 2e 	call	0x5dfe	; 0x5dfe <xTaskGenericNotify>
    3db6:	ef 81       	ldd	r30, Y+7	; 0x07
    3db8:	f8 85       	ldd	r31, Y+8	; 0x08
    3dba:	13 86       	std	Z+11, r1	; 0x0b
    3dbc:	12 86       	std	Z+10, r1	; 0x0a
    3dbe:	0e 94 31 27 	call	0x4e62	; 0x4e62 <xTaskResumeAll>
	{
		traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
		mtCOVERAGE_TEST_MARKER();
	}

	return xReceivedLength;
    3dc2:	8d 81       	ldd	r24, Y+5	; 0x05
    3dc4:	9e 81       	ldd	r25, Y+6	; 0x06
}
    3dc6:	60 96       	adiw	r28, 0x10	; 16
    3dc8:	0f b6       	in	r0, 0x3f	; 63
    3dca:	f8 94       	cli
    3dcc:	de bf       	out	0x3e, r29	; 62
    3dce:	0f be       	out	0x3f, r0	; 63
    3dd0:	cd bf       	out	0x3d, r28	; 61
    3dd2:	cf 91       	pop	r28
    3dd4:	df 91       	pop	r29
    3dd6:	1f 91       	pop	r17
    3dd8:	0f 91       	pop	r16
    3dda:	ff 90       	pop	r15
    3ddc:	ef 90       	pop	r14
    3dde:	08 95       	ret

00003de0 <xStreamBufferNextMessageLengthBytes>:
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
    3de0:	df 93       	push	r29
    3de2:	cf 93       	push	r28
    3de4:	cd b7       	in	r28, 0x3d	; 61
    3de6:	de b7       	in	r29, 0x3e	; 62
    3de8:	2c 97       	sbiw	r28, 0x0c	; 12
    3dea:	0f b6       	in	r0, 0x3f	; 63
    3dec:	f8 94       	cli
    3dee:	de bf       	out	0x3e, r29	; 62
    3df0:	0f be       	out	0x3f, r0	; 63
    3df2:	cd bf       	out	0x3d, r28	; 61
    3df4:	9c 87       	std	Y+12, r25	; 0x0c
    3df6:	8b 87       	std	Y+11, r24	; 0x0b
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3df8:	8b 85       	ldd	r24, Y+11	; 0x0b
    3dfa:	9c 85       	ldd	r25, Y+12	; 0x0c
    3dfc:	98 87       	std	Y+8, r25	; 0x08
    3dfe:	8f 83       	std	Y+7, r24	; 0x07
configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

	configASSERT( pxStreamBuffer );

	/* Ensure the stream buffer is being used as a message buffer. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3e00:	ef 81       	ldd	r30, Y+7	; 0x07
    3e02:	f8 85       	ldd	r31, Y+8	; 0x08
    3e04:	86 85       	ldd	r24, Z+14	; 0x0e
    3e06:	88 2f       	mov	r24, r24
    3e08:	90 e0       	ldi	r25, 0x00	; 0
    3e0a:	81 70       	andi	r24, 0x01	; 1
    3e0c:	90 70       	andi	r25, 0x00	; 0
    3e0e:	88 23       	and	r24, r24
    3e10:	61 f1       	breq	.+88     	; 0x3e6a <xStreamBufferNextMessageLengthBytes+0x8a>
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3e12:	8f 81       	ldd	r24, Y+7	; 0x07
    3e14:	98 85       	ldd	r25, Y+8	; 0x08
    3e16:	0e 94 4b 22 	call	0x4496	; 0x4496 <prvBytesInBuffer>
    3e1a:	9c 83       	std	Y+4, r25	; 0x04
    3e1c:	8b 83       	std	Y+3, r24	; 0x03
		if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
    3e1e:	8b 81       	ldd	r24, Y+3	; 0x03
    3e20:	9c 81       	ldd	r25, Y+4	; 0x04
    3e22:	83 30       	cpi	r24, 0x03	; 3
    3e24:	91 05       	cpc	r25, r1
    3e26:	f0 f0       	brcs	.+60     	; 0x3e64 <xStreamBufferNextMessageLengthBytes+0x84>
			required to hold the length of the next message, so another message
			is available.  Return its length without removing the length bytes
			from the buffer.  A copy of the tail is stored so the buffer can be
			returned to its prior state as the message is not actually being
			removed from the buffer. */
			xOriginalTail = pxStreamBuffer->xTail;
    3e28:	ef 81       	ldd	r30, Y+7	; 0x07
    3e2a:	f8 85       	ldd	r31, Y+8	; 0x08
    3e2c:	80 81       	ld	r24, Z
    3e2e:	91 81       	ldd	r25, Z+1	; 0x01
    3e30:	9a 83       	std	Y+2, r25	; 0x02
    3e32:	89 83       	std	Y+1, r24	; 0x01
			( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, xBytesAvailable );
    3e34:	9e 01       	movw	r18, r28
    3e36:	27 5f       	subi	r18, 0xF7	; 247
    3e38:	3f 4f       	sbci	r19, 0xFF	; 255
    3e3a:	8f 81       	ldd	r24, Y+7	; 0x07
    3e3c:	98 85       	ldd	r25, Y+8	; 0x08
    3e3e:	eb 81       	ldd	r30, Y+3	; 0x03
    3e40:	fc 81       	ldd	r31, Y+4	; 0x04
    3e42:	b9 01       	movw	r22, r18
    3e44:	42 e0       	ldi	r20, 0x02	; 2
    3e46:	50 e0       	ldi	r21, 0x00	; 0
    3e48:	9f 01       	movw	r18, r30
    3e4a:	0e 94 9e 21 	call	0x433c	; 0x433c <prvReadBytesFromBuffer>
			xReturn = ( size_t ) xTempReturn;
    3e4e:	89 85       	ldd	r24, Y+9	; 0x09
    3e50:	9a 85       	ldd	r25, Y+10	; 0x0a
    3e52:	9e 83       	std	Y+6, r25	; 0x06
    3e54:	8d 83       	std	Y+5, r24	; 0x05
			pxStreamBuffer->xTail = xOriginalTail;
    3e56:	ef 81       	ldd	r30, Y+7	; 0x07
    3e58:	f8 85       	ldd	r31, Y+8	; 0x08
    3e5a:	89 81       	ldd	r24, Y+1	; 0x01
    3e5c:	9a 81       	ldd	r25, Y+2	; 0x02
    3e5e:	91 83       	std	Z+1, r25	; 0x01
    3e60:	80 83       	st	Z, r24
    3e62:	05 c0       	rjmp	.+10     	; 0x3e6e <xStreamBufferNextMessageLengthBytes+0x8e>
			/* The minimum amount of bytes in a message buffer is
			( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
			less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
			value is 0. */
			configASSERT( xBytesAvailable == 0 );
			xReturn = 0;
    3e64:	1e 82       	std	Y+6, r1	; 0x06
    3e66:	1d 82       	std	Y+5, r1	; 0x05
    3e68:	02 c0       	rjmp	.+4      	; 0x3e6e <xStreamBufferNextMessageLengthBytes+0x8e>
		}
	}
	else
	{
		xReturn = 0;
    3e6a:	1e 82       	std	Y+6, r1	; 0x06
    3e6c:	1d 82       	std	Y+5, r1	; 0x05
	}

	return xReturn;
    3e6e:	8d 81       	ldd	r24, Y+5	; 0x05
    3e70:	9e 81       	ldd	r25, Y+6	; 0x06
}
    3e72:	2c 96       	adiw	r28, 0x0c	; 12
    3e74:	0f b6       	in	r0, 0x3f	; 63
    3e76:	f8 94       	cli
    3e78:	de bf       	out	0x3e, r29	; 62
    3e7a:	0f be       	out	0x3f, r0	; 63
    3e7c:	cd bf       	out	0x3d, r28	; 61
    3e7e:	cf 91       	pop	r28
    3e80:	df 91       	pop	r29
    3e82:	08 95       	ret

00003e84 <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
									void *pvRxData,
									size_t xBufferLengthBytes,
									BaseType_t * const pxHigherPriorityTaskWoken )
{
    3e84:	ef 92       	push	r14
    3e86:	ff 92       	push	r15
    3e88:	0f 93       	push	r16
    3e8a:	1f 93       	push	r17
    3e8c:	df 93       	push	r29
    3e8e:	cf 93       	push	r28
    3e90:	cd b7       	in	r28, 0x3d	; 61
    3e92:	de b7       	in	r29, 0x3e	; 62
    3e94:	61 97       	sbiw	r28, 0x11	; 17
    3e96:	0f b6       	in	r0, 0x3f	; 63
    3e98:	f8 94       	cli
    3e9a:	de bf       	out	0x3e, r29	; 62
    3e9c:	0f be       	out	0x3f, r0	; 63
    3e9e:	cd bf       	out	0x3d, r28	; 61
    3ea0:	9b 87       	std	Y+11, r25	; 0x0b
    3ea2:	8a 87       	std	Y+10, r24	; 0x0a
    3ea4:	7d 87       	std	Y+13, r23	; 0x0d
    3ea6:	6c 87       	std	Y+12, r22	; 0x0c
    3ea8:	5f 87       	std	Y+15, r21	; 0x0f
    3eaa:	4e 87       	std	Y+14, r20	; 0x0e
    3eac:	39 8b       	std	Y+17, r19	; 0x11
    3eae:	28 8b       	std	Y+16, r18	; 0x10
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3eb0:	8a 85       	ldd	r24, Y+10	; 0x0a
    3eb2:	9b 85       	ldd	r25, Y+11	; 0x0b
    3eb4:	99 87       	std	Y+9, r25	; 0x09
    3eb6:	88 87       	std	Y+8, r24	; 0x08
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    3eb8:	1f 82       	std	Y+7, r1	; 0x07
    3eba:	1e 82       	std	Y+6, r1	; 0x06
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3ebc:	e8 85       	ldd	r30, Y+8	; 0x08
    3ebe:	f9 85       	ldd	r31, Y+9	; 0x09
    3ec0:	86 85       	ldd	r24, Z+14	; 0x0e
    3ec2:	88 2f       	mov	r24, r24
    3ec4:	90 e0       	ldi	r25, 0x00	; 0
    3ec6:	81 70       	andi	r24, 0x01	; 1
    3ec8:	90 70       	andi	r25, 0x00	; 0
    3eca:	88 23       	and	r24, r24
    3ecc:	29 f0       	breq	.+10     	; 0x3ed8 <xStreamBufferReceiveFromISR+0x54>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3ece:	82 e0       	ldi	r24, 0x02	; 2
    3ed0:	90 e0       	ldi	r25, 0x00	; 0
    3ed2:	9b 83       	std	Y+3, r25	; 0x03
    3ed4:	8a 83       	std	Y+2, r24	; 0x02
    3ed6:	02 c0       	rjmp	.+4      	; 0x3edc <xStreamBufferReceiveFromISR+0x58>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    3ed8:	1b 82       	std	Y+3, r1	; 0x03
    3eda:	1a 82       	std	Y+2, r1	; 0x02
	}

	xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3edc:	88 85       	ldd	r24, Y+8	; 0x08
    3ede:	99 85       	ldd	r25, Y+9	; 0x09
    3ee0:	0e 94 4b 22 	call	0x4496	; 0x4496 <prvBytesInBuffer>
    3ee4:	9d 83       	std	Y+5, r25	; 0x05
    3ee6:	8c 83       	std	Y+4, r24	; 0x04
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    3ee8:	2c 81       	ldd	r18, Y+4	; 0x04
    3eea:	3d 81       	ldd	r19, Y+5	; 0x05
    3eec:	8a 81       	ldd	r24, Y+2	; 0x02
    3eee:	9b 81       	ldd	r25, Y+3	; 0x03
    3ef0:	82 17       	cp	r24, r18
    3ef2:	93 07       	cpc	r25, r19
    3ef4:	80 f5       	brcc	.+96     	; 0x3f56 <xStreamBufferReceiveFromISR+0xd2>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    3ef6:	88 85       	ldd	r24, Y+8	; 0x08
    3ef8:	99 85       	ldd	r25, Y+9	; 0x09
    3efa:	2c 85       	ldd	r18, Y+12	; 0x0c
    3efc:	3d 85       	ldd	r19, Y+13	; 0x0d
    3efe:	4e 85       	ldd	r20, Y+14	; 0x0e
    3f00:	5f 85       	ldd	r21, Y+15	; 0x0f
    3f02:	ec 81       	ldd	r30, Y+4	; 0x04
    3f04:	fd 81       	ldd	r31, Y+5	; 0x05
    3f06:	aa 81       	ldd	r26, Y+2	; 0x02
    3f08:	bb 81       	ldd	r27, Y+3	; 0x03
    3f0a:	b9 01       	movw	r22, r18
    3f0c:	9f 01       	movw	r18, r30
    3f0e:	8d 01       	movw	r16, r26
    3f10:	0e 94 ba 1f 	call	0x3f74	; 0x3f74 <prvReadMessageFromBuffer>
    3f14:	9f 83       	std	Y+7, r25	; 0x07
    3f16:	8e 83       	std	Y+6, r24	; 0x06

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    3f18:	8e 81       	ldd	r24, Y+6	; 0x06
    3f1a:	9f 81       	ldd	r25, Y+7	; 0x07
    3f1c:	00 97       	sbiw	r24, 0x00	; 0
    3f1e:	d9 f0       	breq	.+54     	; 0x3f56 <xStreamBufferReceiveFromISR+0xd2>
		{
			sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    3f20:	19 82       	std	Y+1, r1	; 0x01
    3f22:	e8 85       	ldd	r30, Y+8	; 0x08
    3f24:	f9 85       	ldd	r31, Y+9	; 0x09
    3f26:	82 85       	ldd	r24, Z+10	; 0x0a
    3f28:	93 85       	ldd	r25, Z+11	; 0x0b
    3f2a:	00 97       	sbiw	r24, 0x00	; 0
    3f2c:	a1 f0       	breq	.+40     	; 0x3f56 <xStreamBufferReceiveFromISR+0xd2>
    3f2e:	e8 85       	ldd	r30, Y+8	; 0x08
    3f30:	f9 85       	ldd	r31, Y+9	; 0x09
    3f32:	82 85       	ldd	r24, Z+10	; 0x0a
    3f34:	93 85       	ldd	r25, Z+11	; 0x0b
    3f36:	e8 89       	ldd	r30, Y+16	; 0x10
    3f38:	f9 89       	ldd	r31, Y+17	; 0x11
    3f3a:	40 e0       	ldi	r20, 0x00	; 0
    3f3c:	50 e0       	ldi	r21, 0x00	; 0
    3f3e:	60 e0       	ldi	r22, 0x00	; 0
    3f40:	70 e0       	ldi	r23, 0x00	; 0
    3f42:	20 e0       	ldi	r18, 0x00	; 0
    3f44:	00 e0       	ldi	r16, 0x00	; 0
    3f46:	10 e0       	ldi	r17, 0x00	; 0
    3f48:	7f 01       	movw	r14, r30
    3f4a:	0e 94 dc 2f 	call	0x5fb8	; 0x5fb8 <xTaskGenericNotifyFromISR>
    3f4e:	e8 85       	ldd	r30, Y+8	; 0x08
    3f50:	f9 85       	ldd	r31, Y+9	; 0x09
    3f52:	13 86       	std	Z+11, r1	; 0x0b
    3f54:	12 86       	std	Z+10, r1	; 0x0a
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

	return xReceivedLength;
    3f56:	8e 81       	ldd	r24, Y+6	; 0x06
    3f58:	9f 81       	ldd	r25, Y+7	; 0x07
}
    3f5a:	61 96       	adiw	r28, 0x11	; 17
    3f5c:	0f b6       	in	r0, 0x3f	; 63
    3f5e:	f8 94       	cli
    3f60:	de bf       	out	0x3e, r29	; 62
    3f62:	0f be       	out	0x3f, r0	; 63
    3f64:	cd bf       	out	0x3d, r28	; 61
    3f66:	cf 91       	pop	r28
    3f68:	df 91       	pop	r29
    3f6a:	1f 91       	pop	r17
    3f6c:	0f 91       	pop	r16
    3f6e:	ff 90       	pop	r15
    3f70:	ef 90       	pop	r14
    3f72:	08 95       	ret

00003f74 <prvReadMessageFromBuffer>:
static size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,
										void *pvRxData,
										size_t xBufferLengthBytes,
										size_t xBytesAvailable,
										size_t xBytesToStoreMessageLength )
{
    3f74:	0f 93       	push	r16
    3f76:	1f 93       	push	r17
    3f78:	df 93       	push	r29
    3f7a:	cf 93       	push	r28
    3f7c:	cd b7       	in	r28, 0x3d	; 61
    3f7e:	de b7       	in	r29, 0x3e	; 62
    3f80:	62 97       	sbiw	r28, 0x12	; 18
    3f82:	0f b6       	in	r0, 0x3f	; 63
    3f84:	f8 94       	cli
    3f86:	de bf       	out	0x3e, r29	; 62
    3f88:	0f be       	out	0x3f, r0	; 63
    3f8a:	cd bf       	out	0x3d, r28	; 61
    3f8c:	9a 87       	std	Y+10, r25	; 0x0a
    3f8e:	89 87       	std	Y+9, r24	; 0x09
    3f90:	7c 87       	std	Y+12, r23	; 0x0c
    3f92:	6b 87       	std	Y+11, r22	; 0x0b
    3f94:	5e 87       	std	Y+14, r21	; 0x0e
    3f96:	4d 87       	std	Y+13, r20	; 0x0d
    3f98:	38 8b       	std	Y+16, r19	; 0x10
    3f9a:	2f 87       	std	Y+15, r18	; 0x0f
    3f9c:	1a 8b       	std	Y+18, r17	; 0x12
    3f9e:	09 8b       	std	Y+17, r16	; 0x11
size_t xOriginalTail, xReceivedLength, xNextMessageLength;
configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;

	if( xBytesToStoreMessageLength != ( size_t ) 0 )
    3fa0:	89 89       	ldd	r24, Y+17	; 0x11
    3fa2:	9a 89       	ldd	r25, Y+18	; 0x12
    3fa4:	00 97       	sbiw	r24, 0x00	; 0
    3fa6:	91 f1       	breq	.+100    	; 0x400c <prvReadMessageFromBuffer+0x98>
	{
		/* A discrete message is being received.  First receive the length
		of the message.  A copy of the tail is stored so the buffer can be
		returned to its prior state if the length of the message is too
		large for the provided buffer. */
		xOriginalTail = pxStreamBuffer->xTail;
    3fa8:	e9 85       	ldd	r30, Y+9	; 0x09
    3faa:	fa 85       	ldd	r31, Y+10	; 0x0a
    3fac:	80 81       	ld	r24, Z
    3fae:	91 81       	ldd	r25, Z+1	; 0x01
    3fb0:	9e 83       	std	Y+6, r25	; 0x06
    3fb2:	8d 83       	std	Y+5, r24	; 0x05
		( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );
    3fb4:	ae 01       	movw	r20, r28
    3fb6:	49 5f       	subi	r20, 0xF9	; 249
    3fb8:	5f 4f       	sbci	r21, 0xFF	; 255
    3fba:	89 85       	ldd	r24, Y+9	; 0x09
    3fbc:	9a 85       	ldd	r25, Y+10	; 0x0a
    3fbe:	29 89       	ldd	r18, Y+17	; 0x11
    3fc0:	3a 89       	ldd	r19, Y+18	; 0x12
    3fc2:	ef 85       	ldd	r30, Y+15	; 0x0f
    3fc4:	f8 89       	ldd	r31, Y+16	; 0x10
    3fc6:	ba 01       	movw	r22, r20
    3fc8:	a9 01       	movw	r20, r18
    3fca:	9f 01       	movw	r18, r30
    3fcc:	0e 94 9e 21 	call	0x433c	; 0x433c <prvReadBytesFromBuffer>
		xNextMessageLength = ( size_t ) xTempNextMessageLength;
    3fd0:	8f 81       	ldd	r24, Y+7	; 0x07
    3fd2:	98 85       	ldd	r25, Y+8	; 0x08
    3fd4:	9a 83       	std	Y+2, r25	; 0x02
    3fd6:	89 83       	std	Y+1, r24	; 0x01

		/* Reduce the number of bytes available by the number of bytes just
		read out. */
		xBytesAvailable -= xBytesToStoreMessageLength;
    3fd8:	2f 85       	ldd	r18, Y+15	; 0x0f
    3fda:	38 89       	ldd	r19, Y+16	; 0x10
    3fdc:	89 89       	ldd	r24, Y+17	; 0x11
    3fde:	9a 89       	ldd	r25, Y+18	; 0x12
    3fe0:	a9 01       	movw	r20, r18
    3fe2:	48 1b       	sub	r20, r24
    3fe4:	59 0b       	sbc	r21, r25
    3fe6:	ca 01       	movw	r24, r20
    3fe8:	98 8b       	std	Y+16, r25	; 0x10
    3fea:	8f 87       	std	Y+15, r24	; 0x0f

		/* Check there is enough space in the buffer provided by the
		user. */
		if( xNextMessageLength > xBufferLengthBytes )
    3fec:	29 81       	ldd	r18, Y+1	; 0x01
    3fee:	3a 81       	ldd	r19, Y+2	; 0x02
    3ff0:	8d 85       	ldd	r24, Y+13	; 0x0d
    3ff2:	9e 85       	ldd	r25, Y+14	; 0x0e
    3ff4:	82 17       	cp	r24, r18
    3ff6:	93 07       	cpc	r25, r19
    3ff8:	68 f4       	brcc	.+26     	; 0x4014 <prvReadMessageFromBuffer+0xa0>
		{
			/* The user has provided insufficient space to read the message
			so return the buffer to its previous state (so the length of
			the message is in the buffer again). */
			pxStreamBuffer->xTail = xOriginalTail;
    3ffa:	e9 85       	ldd	r30, Y+9	; 0x09
    3ffc:	fa 85       	ldd	r31, Y+10	; 0x0a
    3ffe:	8d 81       	ldd	r24, Y+5	; 0x05
    4000:	9e 81       	ldd	r25, Y+6	; 0x06
    4002:	91 83       	std	Z+1, r25	; 0x01
    4004:	80 83       	st	Z, r24
			xNextMessageLength = 0;
    4006:	1a 82       	std	Y+2, r1	; 0x02
    4008:	19 82       	std	Y+1, r1	; 0x01
    400a:	04 c0       	rjmp	.+8      	; 0x4014 <prvReadMessageFromBuffer+0xa0>
	}
	else
	{
		/* A stream of bytes is being received (as opposed to a discrete
		message), so read as many bytes as possible. */
		xNextMessageLength = xBufferLengthBytes;
    400c:	8d 85       	ldd	r24, Y+13	; 0x0d
    400e:	9e 85       	ldd	r25, Y+14	; 0x0e
    4010:	9a 83       	std	Y+2, r25	; 0x02
    4012:	89 83       	std	Y+1, r24	; 0x01
	}

	/* Read the actual data. */
	xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
    4014:	4b 85       	ldd	r20, Y+11	; 0x0b
    4016:	5c 85       	ldd	r21, Y+12	; 0x0c
    4018:	89 85       	ldd	r24, Y+9	; 0x09
    401a:	9a 85       	ldd	r25, Y+10	; 0x0a
    401c:	29 81       	ldd	r18, Y+1	; 0x01
    401e:	3a 81       	ldd	r19, Y+2	; 0x02
    4020:	ef 85       	ldd	r30, Y+15	; 0x0f
    4022:	f8 89       	ldd	r31, Y+16	; 0x10
    4024:	ba 01       	movw	r22, r20
    4026:	a9 01       	movw	r20, r18
    4028:	9f 01       	movw	r18, r30
    402a:	0e 94 9e 21 	call	0x433c	; 0x433c <prvReadBytesFromBuffer>
    402e:	9c 83       	std	Y+4, r25	; 0x04
    4030:	8b 83       	std	Y+3, r24	; 0x03

	return xReceivedLength;
    4032:	8b 81       	ldd	r24, Y+3	; 0x03
    4034:	9c 81       	ldd	r25, Y+4	; 0x04
}
    4036:	62 96       	adiw	r28, 0x12	; 18
    4038:	0f b6       	in	r0, 0x3f	; 63
    403a:	f8 94       	cli
    403c:	de bf       	out	0x3e, r29	; 62
    403e:	0f be       	out	0x3f, r0	; 63
    4040:	cd bf       	out	0x3d, r28	; 61
    4042:	cf 91       	pop	r28
    4044:	df 91       	pop	r29
    4046:	1f 91       	pop	r17
    4048:	0f 91       	pop	r16
    404a:	08 95       	ret

0000404c <xStreamBufferIsEmpty>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
    404c:	df 93       	push	r29
    404e:	cf 93       	push	r28
    4050:	cd b7       	in	r28, 0x3d	; 61
    4052:	de b7       	in	r29, 0x3e	; 62
    4054:	27 97       	sbiw	r28, 0x07	; 7
    4056:	0f b6       	in	r0, 0x3f	; 63
    4058:	f8 94       	cli
    405a:	de bf       	out	0x3e, r29	; 62
    405c:	0f be       	out	0x3f, r0	; 63
    405e:	cd bf       	out	0x3d, r28	; 61
    4060:	9f 83       	std	Y+7, r25	; 0x07
    4062:	8e 83       	std	Y+6, r24	; 0x06
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    4064:	8e 81       	ldd	r24, Y+6	; 0x06
    4066:	9f 81       	ldd	r25, Y+7	; 0x07
    4068:	9d 83       	std	Y+5, r25	; 0x05
    406a:	8c 83       	std	Y+4, r24	; 0x04
size_t xTail;

	configASSERT( pxStreamBuffer );

	/* True if no bytes are available. */
	xTail = pxStreamBuffer->xTail;
    406c:	ec 81       	ldd	r30, Y+4	; 0x04
    406e:	fd 81       	ldd	r31, Y+5	; 0x05
    4070:	80 81       	ld	r24, Z
    4072:	91 81       	ldd	r25, Z+1	; 0x01
    4074:	9a 83       	std	Y+2, r25	; 0x02
    4076:	89 83       	std	Y+1, r24	; 0x01
	if( pxStreamBuffer->xHead == xTail )
    4078:	ec 81       	ldd	r30, Y+4	; 0x04
    407a:	fd 81       	ldd	r31, Y+5	; 0x05
    407c:	22 81       	ldd	r18, Z+2	; 0x02
    407e:	33 81       	ldd	r19, Z+3	; 0x03
    4080:	89 81       	ldd	r24, Y+1	; 0x01
    4082:	9a 81       	ldd	r25, Y+2	; 0x02
    4084:	28 17       	cp	r18, r24
    4086:	39 07       	cpc	r19, r25
    4088:	19 f4       	brne	.+6      	; 0x4090 <xStreamBufferIsEmpty+0x44>
	{
		xReturn = pdTRUE;
    408a:	81 e0       	ldi	r24, 0x01	; 1
    408c:	8b 83       	std	Y+3, r24	; 0x03
    408e:	01 c0       	rjmp	.+2      	; 0x4092 <xStreamBufferIsEmpty+0x46>
	}
	else
	{
		xReturn = pdFALSE;
    4090:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    4092:	8b 81       	ldd	r24, Y+3	; 0x03
}
    4094:	27 96       	adiw	r28, 0x07	; 7
    4096:	0f b6       	in	r0, 0x3f	; 63
    4098:	f8 94       	cli
    409a:	de bf       	out	0x3e, r29	; 62
    409c:	0f be       	out	0x3f, r0	; 63
    409e:	cd bf       	out	0x3d, r28	; 61
    40a0:	cf 91       	pop	r28
    40a2:	df 91       	pop	r29
    40a4:	08 95       	ret

000040a6 <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
    40a6:	df 93       	push	r29
    40a8:	cf 93       	push	r28
    40aa:	cd b7       	in	r28, 0x3d	; 61
    40ac:	de b7       	in	r29, 0x3e	; 62
    40ae:	27 97       	sbiw	r28, 0x07	; 7
    40b0:	0f b6       	in	r0, 0x3f	; 63
    40b2:	f8 94       	cli
    40b4:	de bf       	out	0x3e, r29	; 62
    40b6:	0f be       	out	0x3f, r0	; 63
    40b8:	cd bf       	out	0x3d, r28	; 61
    40ba:	9f 83       	std	Y+7, r25	; 0x07
    40bc:	8e 83       	std	Y+6, r24	; 0x06
BaseType_t xReturn;
size_t xBytesToStoreMessageLength;
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    40be:	8e 81       	ldd	r24, Y+6	; 0x06
    40c0:	9f 81       	ldd	r25, Y+7	; 0x07
    40c2:	9a 83       	std	Y+2, r25	; 0x02
    40c4:	89 83       	std	Y+1, r24	; 0x01

	/* This generic version of the receive function is used by both message
	buffers, which store discrete messages, and stream buffers, which store a
	continuous stream of bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    40c6:	e9 81       	ldd	r30, Y+1	; 0x01
    40c8:	fa 81       	ldd	r31, Y+2	; 0x02
    40ca:	86 85       	ldd	r24, Z+14	; 0x0e
    40cc:	88 2f       	mov	r24, r24
    40ce:	90 e0       	ldi	r25, 0x00	; 0
    40d0:	81 70       	andi	r24, 0x01	; 1
    40d2:	90 70       	andi	r25, 0x00	; 0
    40d4:	88 23       	and	r24, r24
    40d6:	29 f0       	breq	.+10     	; 0x40e2 <xStreamBufferIsFull+0x3c>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    40d8:	82 e0       	ldi	r24, 0x02	; 2
    40da:	90 e0       	ldi	r25, 0x00	; 0
    40dc:	9c 83       	std	Y+4, r25	; 0x04
    40de:	8b 83       	std	Y+3, r24	; 0x03
    40e0:	02 c0       	rjmp	.+4      	; 0x40e6 <xStreamBufferIsFull+0x40>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    40e2:	1c 82       	std	Y+4, r1	; 0x04
    40e4:	1b 82       	std	Y+3, r1	; 0x03
	}

	/* True if the available space equals zero. */
	if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
    40e6:	8e 81       	ldd	r24, Y+6	; 0x06
    40e8:	9f 81       	ldd	r25, Y+7	; 0x07
    40ea:	0e 94 1b 1c 	call	0x3836	; 0x3836 <xStreamBufferSpacesAvailable>
    40ee:	9c 01       	movw	r18, r24
    40f0:	8b 81       	ldd	r24, Y+3	; 0x03
    40f2:	9c 81       	ldd	r25, Y+4	; 0x04
    40f4:	82 17       	cp	r24, r18
    40f6:	93 07       	cpc	r25, r19
    40f8:	18 f0       	brcs	.+6      	; 0x4100 <xStreamBufferIsFull+0x5a>
	{
		xReturn = pdTRUE;
    40fa:	81 e0       	ldi	r24, 0x01	; 1
    40fc:	8d 83       	std	Y+5, r24	; 0x05
    40fe:	01 c0       	rjmp	.+2      	; 0x4102 <xStreamBufferIsFull+0x5c>
	}
	else
	{
		xReturn = pdFALSE;
    4100:	1d 82       	std	Y+5, r1	; 0x05
	}

	return xReturn;
    4102:	8d 81       	ldd	r24, Y+5	; 0x05
}
    4104:	27 96       	adiw	r28, 0x07	; 7
    4106:	0f b6       	in	r0, 0x3f	; 63
    4108:	f8 94       	cli
    410a:	de bf       	out	0x3e, r29	; 62
    410c:	0f be       	out	0x3f, r0	; 63
    410e:	cd bf       	out	0x3d, r28	; 61
    4110:	cf 91       	pop	r28
    4112:	df 91       	pop	r29
    4114:	08 95       	ret

00004116 <xStreamBufferSendCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    4116:	ef 92       	push	r14
    4118:	ff 92       	push	r15
    411a:	0f 93       	push	r16
    411c:	1f 93       	push	r17
    411e:	df 93       	push	r29
    4120:	cf 93       	push	r28
    4122:	cd b7       	in	r28, 0x3d	; 61
    4124:	de b7       	in	r29, 0x3e	; 62
    4126:	28 97       	sbiw	r28, 0x08	; 8
    4128:	0f b6       	in	r0, 0x3f	; 63
    412a:	f8 94       	cli
    412c:	de bf       	out	0x3e, r29	; 62
    412e:	0f be       	out	0x3f, r0	; 63
    4130:	cd bf       	out	0x3d, r28	; 61
    4132:	9e 83       	std	Y+6, r25	; 0x06
    4134:	8d 83       	std	Y+5, r24	; 0x05
    4136:	78 87       	std	Y+8, r23	; 0x08
    4138:	6f 83       	std	Y+7, r22	; 0x07
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    413a:	8d 81       	ldd	r24, Y+5	; 0x05
    413c:	9e 81       	ldd	r25, Y+6	; 0x06
    413e:	9c 83       	std	Y+4, r25	; 0x04
    4140:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    4142:	19 82       	std	Y+1, r1	; 0x01
	{
		if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
    4144:	eb 81       	ldd	r30, Y+3	; 0x03
    4146:	fc 81       	ldd	r31, Y+4	; 0x04
    4148:	80 85       	ldd	r24, Z+8	; 0x08
    414a:	91 85       	ldd	r25, Z+9	; 0x09
    414c:	00 97       	sbiw	r24, 0x00	; 0
    414e:	b9 f0       	breq	.+46     	; 0x417e <xStreamBufferSendCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
    4150:	eb 81       	ldd	r30, Y+3	; 0x03
    4152:	fc 81       	ldd	r31, Y+4	; 0x04
    4154:	80 85       	ldd	r24, Z+8	; 0x08
    4156:	91 85       	ldd	r25, Z+9	; 0x09
    4158:	ef 81       	ldd	r30, Y+7	; 0x07
    415a:	f8 85       	ldd	r31, Y+8	; 0x08
    415c:	40 e0       	ldi	r20, 0x00	; 0
    415e:	50 e0       	ldi	r21, 0x00	; 0
    4160:	60 e0       	ldi	r22, 0x00	; 0
    4162:	70 e0       	ldi	r23, 0x00	; 0
    4164:	20 e0       	ldi	r18, 0x00	; 0
    4166:	00 e0       	ldi	r16, 0x00	; 0
    4168:	10 e0       	ldi	r17, 0x00	; 0
    416a:	7f 01       	movw	r14, r30
    416c:	0e 94 dc 2f 	call	0x5fb8	; 0x5fb8 <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
    4170:	eb 81       	ldd	r30, Y+3	; 0x03
    4172:	fc 81       	ldd	r31, Y+4	; 0x04
    4174:	11 86       	std	Z+9, r1	; 0x09
    4176:	10 86       	std	Z+8, r1	; 0x08
			xReturn = pdTRUE;
    4178:	81 e0       	ldi	r24, 0x01	; 1
    417a:	8a 83       	std	Y+2, r24	; 0x02
    417c:	01 c0       	rjmp	.+2      	; 0x4180 <xStreamBufferSendCompletedFromISR+0x6a>
		}
		else
		{
			xReturn = pdFALSE;
    417e:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4180:	8a 81       	ldd	r24, Y+2	; 0x02
}
    4182:	28 96       	adiw	r28, 0x08	; 8
    4184:	0f b6       	in	r0, 0x3f	; 63
    4186:	f8 94       	cli
    4188:	de bf       	out	0x3e, r29	; 62
    418a:	0f be       	out	0x3f, r0	; 63
    418c:	cd bf       	out	0x3d, r28	; 61
    418e:	cf 91       	pop	r28
    4190:	df 91       	pop	r29
    4192:	1f 91       	pop	r17
    4194:	0f 91       	pop	r16
    4196:	ff 90       	pop	r15
    4198:	ef 90       	pop	r14
    419a:	08 95       	ret

0000419c <xStreamBufferReceiveCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    419c:	ef 92       	push	r14
    419e:	ff 92       	push	r15
    41a0:	0f 93       	push	r16
    41a2:	1f 93       	push	r17
    41a4:	df 93       	push	r29
    41a6:	cf 93       	push	r28
    41a8:	cd b7       	in	r28, 0x3d	; 61
    41aa:	de b7       	in	r29, 0x3e	; 62
    41ac:	28 97       	sbiw	r28, 0x08	; 8
    41ae:	0f b6       	in	r0, 0x3f	; 63
    41b0:	f8 94       	cli
    41b2:	de bf       	out	0x3e, r29	; 62
    41b4:	0f be       	out	0x3f, r0	; 63
    41b6:	cd bf       	out	0x3d, r28	; 61
    41b8:	9e 83       	std	Y+6, r25	; 0x06
    41ba:	8d 83       	std	Y+5, r24	; 0x05
    41bc:	78 87       	std	Y+8, r23	; 0x08
    41be:	6f 83       	std	Y+7, r22	; 0x07
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    41c0:	8d 81       	ldd	r24, Y+5	; 0x05
    41c2:	9e 81       	ldd	r25, Y+6	; 0x06
    41c4:	9c 83       	std	Y+4, r25	; 0x04
    41c6:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    41c8:	19 82       	std	Y+1, r1	; 0x01
	{
		if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
    41ca:	eb 81       	ldd	r30, Y+3	; 0x03
    41cc:	fc 81       	ldd	r31, Y+4	; 0x04
    41ce:	82 85       	ldd	r24, Z+10	; 0x0a
    41d0:	93 85       	ldd	r25, Z+11	; 0x0b
    41d2:	00 97       	sbiw	r24, 0x00	; 0
    41d4:	b9 f0       	breq	.+46     	; 0x4204 <xStreamBufferReceiveCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
    41d6:	eb 81       	ldd	r30, Y+3	; 0x03
    41d8:	fc 81       	ldd	r31, Y+4	; 0x04
    41da:	82 85       	ldd	r24, Z+10	; 0x0a
    41dc:	93 85       	ldd	r25, Z+11	; 0x0b
    41de:	ef 81       	ldd	r30, Y+7	; 0x07
    41e0:	f8 85       	ldd	r31, Y+8	; 0x08
    41e2:	40 e0       	ldi	r20, 0x00	; 0
    41e4:	50 e0       	ldi	r21, 0x00	; 0
    41e6:	60 e0       	ldi	r22, 0x00	; 0
    41e8:	70 e0       	ldi	r23, 0x00	; 0
    41ea:	20 e0       	ldi	r18, 0x00	; 0
    41ec:	00 e0       	ldi	r16, 0x00	; 0
    41ee:	10 e0       	ldi	r17, 0x00	; 0
    41f0:	7f 01       	movw	r14, r30
    41f2:	0e 94 dc 2f 	call	0x5fb8	; 0x5fb8 <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToSend = NULL;
    41f6:	eb 81       	ldd	r30, Y+3	; 0x03
    41f8:	fc 81       	ldd	r31, Y+4	; 0x04
    41fa:	13 86       	std	Z+11, r1	; 0x0b
    41fc:	12 86       	std	Z+10, r1	; 0x0a
			xReturn = pdTRUE;
    41fe:	81 e0       	ldi	r24, 0x01	; 1
    4200:	8a 83       	std	Y+2, r24	; 0x02
    4202:	01 c0       	rjmp	.+2      	; 0x4206 <xStreamBufferReceiveCompletedFromISR+0x6a>
		}
		else
		{
			xReturn = pdFALSE;
    4204:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4206:	8a 81       	ldd	r24, Y+2	; 0x02
}
    4208:	28 96       	adiw	r28, 0x08	; 8
    420a:	0f b6       	in	r0, 0x3f	; 63
    420c:	f8 94       	cli
    420e:	de bf       	out	0x3e, r29	; 62
    4210:	0f be       	out	0x3f, r0	; 63
    4212:	cd bf       	out	0x3d, r28	; 61
    4214:	cf 91       	pop	r28
    4216:	df 91       	pop	r29
    4218:	1f 91       	pop	r17
    421a:	0f 91       	pop	r16
    421c:	ff 90       	pop	r15
    421e:	ef 90       	pop	r14
    4220:	08 95       	ret

00004222 <prvWriteBytesToBuffer>:
/*-----------------------------------------------------------*/

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount )
{
    4222:	df 93       	push	r29
    4224:	cf 93       	push	r28
    4226:	cd b7       	in	r28, 0x3d	; 61
    4228:	de b7       	in	r29, 0x3e	; 62
    422a:	2e 97       	sbiw	r28, 0x0e	; 14
    422c:	0f b6       	in	r0, 0x3f	; 63
    422e:	f8 94       	cli
    4230:	de bf       	out	0x3e, r29	; 62
    4232:	0f be       	out	0x3f, r0	; 63
    4234:	cd bf       	out	0x3d, r28	; 61
    4236:	9e 83       	std	Y+6, r25	; 0x06
    4238:	8d 83       	std	Y+5, r24	; 0x05
    423a:	78 87       	std	Y+8, r23	; 0x08
    423c:	6f 83       	std	Y+7, r22	; 0x07
    423e:	5a 87       	std	Y+10, r21	; 0x0a
    4240:	49 87       	std	Y+9, r20	; 0x09
size_t xNextHead, xFirstLength;

	configASSERT( xCount > ( size_t ) 0 );

	xNextHead = pxStreamBuffer->xHead;
    4242:	ed 81       	ldd	r30, Y+5	; 0x05
    4244:	fe 81       	ldd	r31, Y+6	; 0x06
    4246:	82 81       	ldd	r24, Z+2	; 0x02
    4248:	93 81       	ldd	r25, Z+3	; 0x03
    424a:	9c 83       	std	Y+4, r25	; 0x04
    424c:	8b 83       	std	Y+3, r24	; 0x03

	/* Calculate the number of bytes that can be added in the first write -
	which may be less than the total number of bytes that need to be added if
	the buffer will wrap back to the beginning. */
	xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );
    424e:	ed 81       	ldd	r30, Y+5	; 0x05
    4250:	fe 81       	ldd	r31, Y+6	; 0x06
    4252:	24 81       	ldd	r18, Z+4	; 0x04
    4254:	35 81       	ldd	r19, Z+5	; 0x05
    4256:	8b 81       	ldd	r24, Y+3	; 0x03
    4258:	9c 81       	ldd	r25, Y+4	; 0x04
    425a:	a9 01       	movw	r20, r18
    425c:	48 1b       	sub	r20, r24
    425e:	59 0b       	sbc	r21, r25
    4260:	ca 01       	movw	r24, r20
    4262:	29 85       	ldd	r18, Y+9	; 0x09
    4264:	3a 85       	ldd	r19, Y+10	; 0x0a
    4266:	3e 87       	std	Y+14, r19	; 0x0e
    4268:	2d 87       	std	Y+13, r18	; 0x0d
    426a:	9c 87       	std	Y+12, r25	; 0x0c
    426c:	8b 87       	std	Y+11, r24	; 0x0b
    426e:	4b 85       	ldd	r20, Y+11	; 0x0b
    4270:	5c 85       	ldd	r21, Y+12	; 0x0c
    4272:	8d 85       	ldd	r24, Y+13	; 0x0d
    4274:	9e 85       	ldd	r25, Y+14	; 0x0e
    4276:	84 17       	cp	r24, r20
    4278:	95 07       	cpc	r25, r21
    427a:	20 f4       	brcc	.+8      	; 0x4284 <prvWriteBytesToBuffer+0x62>
    427c:	2d 85       	ldd	r18, Y+13	; 0x0d
    427e:	3e 85       	ldd	r19, Y+14	; 0x0e
    4280:	3c 87       	std	Y+12, r19	; 0x0c
    4282:	2b 87       	std	Y+11, r18	; 0x0b
    4284:	4b 85       	ldd	r20, Y+11	; 0x0b
    4286:	5c 85       	ldd	r21, Y+12	; 0x0c
    4288:	5a 83       	std	Y+2, r21	; 0x02
    428a:	49 83       	std	Y+1, r20	; 0x01

	/* Write as many bytes as can be written in the first write. */
	configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );
	( void ) memcpy( ( void* ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    428c:	ed 81       	ldd	r30, Y+5	; 0x05
    428e:	fe 81       	ldd	r31, Y+6	; 0x06
    4290:	24 85       	ldd	r18, Z+12	; 0x0c
    4292:	35 85       	ldd	r19, Z+13	; 0x0d
    4294:	8b 81       	ldd	r24, Y+3	; 0x03
    4296:	9c 81       	ldd	r25, Y+4	; 0x04
    4298:	82 0f       	add	r24, r18
    429a:	93 1f       	adc	r25, r19
    429c:	2f 81       	ldd	r18, Y+7	; 0x07
    429e:	38 85       	ldd	r19, Y+8	; 0x08
    42a0:	49 81       	ldd	r20, Y+1	; 0x01
    42a2:	5a 81       	ldd	r21, Y+2	; 0x02
    42a4:	b9 01       	movw	r22, r18
    42a6:	0e 94 8d 32 	call	0x651a	; 0x651a <memcpy>

	/* If the number of bytes written was less than the number that could be
	written in the first write... */
	if( xCount > xFirstLength )
    42aa:	29 85       	ldd	r18, Y+9	; 0x09
    42ac:	3a 85       	ldd	r19, Y+10	; 0x0a
    42ae:	89 81       	ldd	r24, Y+1	; 0x01
    42b0:	9a 81       	ldd	r25, Y+2	; 0x02
    42b2:	82 17       	cp	r24, r18
    42b4:	93 07       	cpc	r25, r19
    42b6:	b0 f4       	brcc	.+44     	; 0x42e4 <prvWriteBytesToBuffer+0xc2>
	{
		/* ...then write the remaining bytes to the start of the buffer. */
		configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    42b8:	ed 81       	ldd	r30, Y+5	; 0x05
    42ba:	fe 81       	ldd	r31, Y+6	; 0x06
    42bc:	64 85       	ldd	r22, Z+12	; 0x0c
    42be:	75 85       	ldd	r23, Z+13	; 0x0d
    42c0:	2f 81       	ldd	r18, Y+7	; 0x07
    42c2:	38 85       	ldd	r19, Y+8	; 0x08
    42c4:	89 81       	ldd	r24, Y+1	; 0x01
    42c6:	9a 81       	ldd	r25, Y+2	; 0x02
    42c8:	a9 01       	movw	r20, r18
    42ca:	48 0f       	add	r20, r24
    42cc:	59 1f       	adc	r21, r25
    42ce:	29 85       	ldd	r18, Y+9	; 0x09
    42d0:	3a 85       	ldd	r19, Y+10	; 0x0a
    42d2:	89 81       	ldd	r24, Y+1	; 0x01
    42d4:	9a 81       	ldd	r25, Y+2	; 0x02
    42d6:	28 1b       	sub	r18, r24
    42d8:	39 0b       	sbc	r19, r25
    42da:	cb 01       	movw	r24, r22
    42dc:	ba 01       	movw	r22, r20
    42de:	a9 01       	movw	r20, r18
    42e0:	0e 94 8d 32 	call	0x651a	; 0x651a <memcpy>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xNextHead += xCount;
    42e4:	2b 81       	ldd	r18, Y+3	; 0x03
    42e6:	3c 81       	ldd	r19, Y+4	; 0x04
    42e8:	89 85       	ldd	r24, Y+9	; 0x09
    42ea:	9a 85       	ldd	r25, Y+10	; 0x0a
    42ec:	82 0f       	add	r24, r18
    42ee:	93 1f       	adc	r25, r19
    42f0:	9c 83       	std	Y+4, r25	; 0x04
    42f2:	8b 83       	std	Y+3, r24	; 0x03
	if( xNextHead >= pxStreamBuffer->xLength )
    42f4:	ed 81       	ldd	r30, Y+5	; 0x05
    42f6:	fe 81       	ldd	r31, Y+6	; 0x06
    42f8:	24 81       	ldd	r18, Z+4	; 0x04
    42fa:	35 81       	ldd	r19, Z+5	; 0x05
    42fc:	8b 81       	ldd	r24, Y+3	; 0x03
    42fe:	9c 81       	ldd	r25, Y+4	; 0x04
    4300:	82 17       	cp	r24, r18
    4302:	93 07       	cpc	r25, r19
    4304:	50 f0       	brcs	.+20     	; 0x431a <prvWriteBytesToBuffer+0xf8>
	{
		xNextHead -= pxStreamBuffer->xLength;
    4306:	ed 81       	ldd	r30, Y+5	; 0x05
    4308:	fe 81       	ldd	r31, Y+6	; 0x06
    430a:	24 81       	ldd	r18, Z+4	; 0x04
    430c:	35 81       	ldd	r19, Z+5	; 0x05
    430e:	8b 81       	ldd	r24, Y+3	; 0x03
    4310:	9c 81       	ldd	r25, Y+4	; 0x04
    4312:	82 1b       	sub	r24, r18
    4314:	93 0b       	sbc	r25, r19
    4316:	9c 83       	std	Y+4, r25	; 0x04
    4318:	8b 83       	std	Y+3, r24	; 0x03
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxStreamBuffer->xHead = xNextHead;
    431a:	ed 81       	ldd	r30, Y+5	; 0x05
    431c:	fe 81       	ldd	r31, Y+6	; 0x06
    431e:	8b 81       	ldd	r24, Y+3	; 0x03
    4320:	9c 81       	ldd	r25, Y+4	; 0x04
    4322:	93 83       	std	Z+3, r25	; 0x03
    4324:	82 83       	std	Z+2, r24	; 0x02

	return xCount;
    4326:	89 85       	ldd	r24, Y+9	; 0x09
    4328:	9a 85       	ldd	r25, Y+10	; 0x0a
}
    432a:	2e 96       	adiw	r28, 0x0e	; 14
    432c:	0f b6       	in	r0, 0x3f	; 63
    432e:	f8 94       	cli
    4330:	de bf       	out	0x3e, r29	; 62
    4332:	0f be       	out	0x3f, r0	; 63
    4334:	cd bf       	out	0x3d, r28	; 61
    4336:	cf 91       	pop	r28
    4338:	df 91       	pop	r29
    433a:	08 95       	ret

0000433c <prvReadBytesFromBuffer>:
/*-----------------------------------------------------------*/

static size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer, uint8_t *pucData, size_t xMaxCount, size_t xBytesAvailable )
{
    433c:	df 93       	push	r29
    433e:	cf 93       	push	r28
    4340:	cd b7       	in	r28, 0x3d	; 61
    4342:	de b7       	in	r29, 0x3e	; 62
    4344:	66 97       	sbiw	r28, 0x16	; 22
    4346:	0f b6       	in	r0, 0x3f	; 63
    4348:	f8 94       	cli
    434a:	de bf       	out	0x3e, r29	; 62
    434c:	0f be       	out	0x3f, r0	; 63
    434e:	cd bf       	out	0x3d, r28	; 61
    4350:	98 87       	std	Y+8, r25	; 0x08
    4352:	8f 83       	std	Y+7, r24	; 0x07
    4354:	7a 87       	std	Y+10, r23	; 0x0a
    4356:	69 87       	std	Y+9, r22	; 0x09
    4358:	5c 87       	std	Y+12, r21	; 0x0c
    435a:	4b 87       	std	Y+11, r20	; 0x0b
    435c:	3e 87       	std	Y+14, r19	; 0x0e
    435e:	2d 87       	std	Y+13, r18	; 0x0d
size_t xCount, xFirstLength, xNextTail;

	/* Use the minimum of the wanted bytes and the available bytes. */
	xCount = configMIN( xBytesAvailable, xMaxCount );
    4360:	2d 85       	ldd	r18, Y+13	; 0x0d
    4362:	3e 85       	ldd	r19, Y+14	; 0x0e
    4364:	3a 8b       	std	Y+18, r19	; 0x12
    4366:	29 8b       	std	Y+17, r18	; 0x11
    4368:	4b 85       	ldd	r20, Y+11	; 0x0b
    436a:	5c 85       	ldd	r21, Y+12	; 0x0c
    436c:	58 8b       	std	Y+16, r21	; 0x10
    436e:	4f 87       	std	Y+15, r20	; 0x0f
    4370:	8f 85       	ldd	r24, Y+15	; 0x0f
    4372:	98 89       	ldd	r25, Y+16	; 0x10
    4374:	29 89       	ldd	r18, Y+17	; 0x11
    4376:	3a 89       	ldd	r19, Y+18	; 0x12
    4378:	28 17       	cp	r18, r24
    437a:	39 07       	cpc	r19, r25
    437c:	20 f4       	brcc	.+8      	; 0x4386 <prvReadBytesFromBuffer+0x4a>
    437e:	49 89       	ldd	r20, Y+17	; 0x11
    4380:	5a 89       	ldd	r21, Y+18	; 0x12
    4382:	58 8b       	std	Y+16, r21	; 0x10
    4384:	4f 87       	std	Y+15, r20	; 0x0f
    4386:	8f 85       	ldd	r24, Y+15	; 0x0f
    4388:	98 89       	ldd	r25, Y+16	; 0x10
    438a:	9e 83       	std	Y+6, r25	; 0x06
    438c:	8d 83       	std	Y+5, r24	; 0x05

	if( xCount > ( size_t ) 0 )
    438e:	8d 81       	ldd	r24, Y+5	; 0x05
    4390:	9e 81       	ldd	r25, Y+6	; 0x06
    4392:	00 97       	sbiw	r24, 0x00	; 0
    4394:	09 f4       	brne	.+2      	; 0x4398 <prvReadBytesFromBuffer+0x5c>
    4396:	74 c0       	rjmp	.+232    	; 0x4480 <prvReadBytesFromBuffer+0x144>
	{
		xNextTail = pxStreamBuffer->xTail;
    4398:	ef 81       	ldd	r30, Y+7	; 0x07
    439a:	f8 85       	ldd	r31, Y+8	; 0x08
    439c:	80 81       	ld	r24, Z
    439e:	91 81       	ldd	r25, Z+1	; 0x01
    43a0:	9a 83       	std	Y+2, r25	; 0x02
    43a2:	89 83       	std	Y+1, r24	; 0x01

		/* Calculate the number of bytes that can be read - which may be
		less than the number wanted if the data wraps around to the start of
		the buffer. */
		xFirstLength = configMIN( pxStreamBuffer->xLength - xNextTail, xCount );
    43a4:	ef 81       	ldd	r30, Y+7	; 0x07
    43a6:	f8 85       	ldd	r31, Y+8	; 0x08
    43a8:	24 81       	ldd	r18, Z+4	; 0x04
    43aa:	35 81       	ldd	r19, Z+5	; 0x05
    43ac:	89 81       	ldd	r24, Y+1	; 0x01
    43ae:	9a 81       	ldd	r25, Y+2	; 0x02
    43b0:	a9 01       	movw	r20, r18
    43b2:	48 1b       	sub	r20, r24
    43b4:	59 0b       	sbc	r21, r25
    43b6:	ca 01       	movw	r24, r20
    43b8:	2d 81       	ldd	r18, Y+5	; 0x05
    43ba:	3e 81       	ldd	r19, Y+6	; 0x06
    43bc:	3e 8b       	std	Y+22, r19	; 0x16
    43be:	2d 8b       	std	Y+21, r18	; 0x15
    43c0:	9c 8b       	std	Y+20, r25	; 0x14
    43c2:	8b 8b       	std	Y+19, r24	; 0x13
    43c4:	4b 89       	ldd	r20, Y+19	; 0x13
    43c6:	5c 89       	ldd	r21, Y+20	; 0x14
    43c8:	8d 89       	ldd	r24, Y+21	; 0x15
    43ca:	9e 89       	ldd	r25, Y+22	; 0x16
    43cc:	84 17       	cp	r24, r20
    43ce:	95 07       	cpc	r25, r21
    43d0:	20 f4       	brcc	.+8      	; 0x43da <prvReadBytesFromBuffer+0x9e>
    43d2:	2d 89       	ldd	r18, Y+21	; 0x15
    43d4:	3e 89       	ldd	r19, Y+22	; 0x16
    43d6:	3c 8b       	std	Y+20, r19	; 0x14
    43d8:	2b 8b       	std	Y+19, r18	; 0x13
    43da:	4b 89       	ldd	r20, Y+19	; 0x13
    43dc:	5c 89       	ldd	r21, Y+20	; 0x14
    43de:	5c 83       	std	Y+4, r21	; 0x04
    43e0:	4b 83       	std	Y+3, r20	; 0x03

		/* Obtain the number of bytes it is possible to obtain in the first
		read.  Asserts check bounds of read and write. */
		configASSERT( xFirstLength <= xMaxCount );
		configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    43e2:	ef 81       	ldd	r30, Y+7	; 0x07
    43e4:	f8 85       	ldd	r31, Y+8	; 0x08
    43e6:	24 85       	ldd	r18, Z+12	; 0x0c
    43e8:	35 85       	ldd	r19, Z+13	; 0x0d
    43ea:	89 81       	ldd	r24, Y+1	; 0x01
    43ec:	9a 81       	ldd	r25, Y+2	; 0x02
    43ee:	a9 01       	movw	r20, r18
    43f0:	48 0f       	add	r20, r24
    43f2:	59 1f       	adc	r21, r25
    43f4:	89 85       	ldd	r24, Y+9	; 0x09
    43f6:	9a 85       	ldd	r25, Y+10	; 0x0a
    43f8:	2b 81       	ldd	r18, Y+3	; 0x03
    43fa:	3c 81       	ldd	r19, Y+4	; 0x04
    43fc:	ba 01       	movw	r22, r20
    43fe:	a9 01       	movw	r20, r18
    4400:	0e 94 8d 32 	call	0x651a	; 0x651a <memcpy>

		/* If the total number of wanted bytes is greater than the number
		that could be read in the first read... */
		if( xCount > xFirstLength )
    4404:	2d 81       	ldd	r18, Y+5	; 0x05
    4406:	3e 81       	ldd	r19, Y+6	; 0x06
    4408:	8b 81       	ldd	r24, Y+3	; 0x03
    440a:	9c 81       	ldd	r25, Y+4	; 0x04
    440c:	82 17       	cp	r24, r18
    440e:	93 07       	cpc	r25, r19
    4410:	b0 f4       	brcc	.+44     	; 0x443e <prvReadBytesFromBuffer+0x102>
		{
			/*...then read the remaining bytes from the start of the buffer. */
			configASSERT( xCount <= xMaxCount );
			( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    4412:	29 85       	ldd	r18, Y+9	; 0x09
    4414:	3a 85       	ldd	r19, Y+10	; 0x0a
    4416:	8b 81       	ldd	r24, Y+3	; 0x03
    4418:	9c 81       	ldd	r25, Y+4	; 0x04
    441a:	b9 01       	movw	r22, r18
    441c:	68 0f       	add	r22, r24
    441e:	79 1f       	adc	r23, r25
    4420:	ef 81       	ldd	r30, Y+7	; 0x07
    4422:	f8 85       	ldd	r31, Y+8	; 0x08
    4424:	44 85       	ldd	r20, Z+12	; 0x0c
    4426:	55 85       	ldd	r21, Z+13	; 0x0d
    4428:	2d 81       	ldd	r18, Y+5	; 0x05
    442a:	3e 81       	ldd	r19, Y+6	; 0x06
    442c:	8b 81       	ldd	r24, Y+3	; 0x03
    442e:	9c 81       	ldd	r25, Y+4	; 0x04
    4430:	28 1b       	sub	r18, r24
    4432:	39 0b       	sbc	r19, r25
    4434:	cb 01       	movw	r24, r22
    4436:	ba 01       	movw	r22, r20
    4438:	a9 01       	movw	r20, r18
    443a:	0e 94 8d 32 	call	0x651a	; 0x651a <memcpy>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Move the tail pointer to effectively remove the data read from
		the buffer. */
		xNextTail += xCount;
    443e:	29 81       	ldd	r18, Y+1	; 0x01
    4440:	3a 81       	ldd	r19, Y+2	; 0x02
    4442:	8d 81       	ldd	r24, Y+5	; 0x05
    4444:	9e 81       	ldd	r25, Y+6	; 0x06
    4446:	82 0f       	add	r24, r18
    4448:	93 1f       	adc	r25, r19
    444a:	9a 83       	std	Y+2, r25	; 0x02
    444c:	89 83       	std	Y+1, r24	; 0x01

		if( xNextTail >= pxStreamBuffer->xLength )
    444e:	ef 81       	ldd	r30, Y+7	; 0x07
    4450:	f8 85       	ldd	r31, Y+8	; 0x08
    4452:	24 81       	ldd	r18, Z+4	; 0x04
    4454:	35 81       	ldd	r19, Z+5	; 0x05
    4456:	89 81       	ldd	r24, Y+1	; 0x01
    4458:	9a 81       	ldd	r25, Y+2	; 0x02
    445a:	82 17       	cp	r24, r18
    445c:	93 07       	cpc	r25, r19
    445e:	50 f0       	brcs	.+20     	; 0x4474 <prvReadBytesFromBuffer+0x138>
		{
			xNextTail -= pxStreamBuffer->xLength;
    4460:	ef 81       	ldd	r30, Y+7	; 0x07
    4462:	f8 85       	ldd	r31, Y+8	; 0x08
    4464:	24 81       	ldd	r18, Z+4	; 0x04
    4466:	35 81       	ldd	r19, Z+5	; 0x05
    4468:	89 81       	ldd	r24, Y+1	; 0x01
    446a:	9a 81       	ldd	r25, Y+2	; 0x02
    446c:	82 1b       	sub	r24, r18
    446e:	93 0b       	sbc	r25, r19
    4470:	9a 83       	std	Y+2, r25	; 0x02
    4472:	89 83       	std	Y+1, r24	; 0x01
		}

		pxStreamBuffer->xTail = xNextTail;
    4474:	ef 81       	ldd	r30, Y+7	; 0x07
    4476:	f8 85       	ldd	r31, Y+8	; 0x08
    4478:	89 81       	ldd	r24, Y+1	; 0x01
    447a:	9a 81       	ldd	r25, Y+2	; 0x02
    447c:	91 83       	std	Z+1, r25	; 0x01
    447e:	80 83       	st	Z, r24
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
    4480:	8d 81       	ldd	r24, Y+5	; 0x05
    4482:	9e 81       	ldd	r25, Y+6	; 0x06
}
    4484:	66 96       	adiw	r28, 0x16	; 22
    4486:	0f b6       	in	r0, 0x3f	; 63
    4488:	f8 94       	cli
    448a:	de bf       	out	0x3e, r29	; 62
    448c:	0f be       	out	0x3f, r0	; 63
    448e:	cd bf       	out	0x3d, r28	; 61
    4490:	cf 91       	pop	r28
    4492:	df 91       	pop	r29
    4494:	08 95       	ret

00004496 <prvBytesInBuffer>:
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
    4496:	df 93       	push	r29
    4498:	cf 93       	push	r28
    449a:	00 d0       	rcall	.+0      	; 0x449c <prvBytesInBuffer+0x6>
    449c:	00 d0       	rcall	.+0      	; 0x449e <prvBytesInBuffer+0x8>
    449e:	cd b7       	in	r28, 0x3d	; 61
    44a0:	de b7       	in	r29, 0x3e	; 62
    44a2:	9c 83       	std	Y+4, r25	; 0x04
    44a4:	8b 83       	std	Y+3, r24	; 0x03
/* Returns the distance between xTail and xHead. */
size_t xCount;

	xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    44a6:	eb 81       	ldd	r30, Y+3	; 0x03
    44a8:	fc 81       	ldd	r31, Y+4	; 0x04
    44aa:	24 81       	ldd	r18, Z+4	; 0x04
    44ac:	35 81       	ldd	r19, Z+5	; 0x05
    44ae:	eb 81       	ldd	r30, Y+3	; 0x03
    44b0:	fc 81       	ldd	r31, Y+4	; 0x04
    44b2:	82 81       	ldd	r24, Z+2	; 0x02
    44b4:	93 81       	ldd	r25, Z+3	; 0x03
    44b6:	82 0f       	add	r24, r18
    44b8:	93 1f       	adc	r25, r19
    44ba:	9a 83       	std	Y+2, r25	; 0x02
    44bc:	89 83       	std	Y+1, r24	; 0x01
	xCount -= pxStreamBuffer->xTail;
    44be:	eb 81       	ldd	r30, Y+3	; 0x03
    44c0:	fc 81       	ldd	r31, Y+4	; 0x04
    44c2:	20 81       	ld	r18, Z
    44c4:	31 81       	ldd	r19, Z+1	; 0x01
    44c6:	89 81       	ldd	r24, Y+1	; 0x01
    44c8:	9a 81       	ldd	r25, Y+2	; 0x02
    44ca:	82 1b       	sub	r24, r18
    44cc:	93 0b       	sbc	r25, r19
    44ce:	9a 83       	std	Y+2, r25	; 0x02
    44d0:	89 83       	std	Y+1, r24	; 0x01
	if ( xCount >= pxStreamBuffer->xLength )
    44d2:	eb 81       	ldd	r30, Y+3	; 0x03
    44d4:	fc 81       	ldd	r31, Y+4	; 0x04
    44d6:	24 81       	ldd	r18, Z+4	; 0x04
    44d8:	35 81       	ldd	r19, Z+5	; 0x05
    44da:	89 81       	ldd	r24, Y+1	; 0x01
    44dc:	9a 81       	ldd	r25, Y+2	; 0x02
    44de:	82 17       	cp	r24, r18
    44e0:	93 07       	cpc	r25, r19
    44e2:	50 f0       	brcs	.+20     	; 0x44f8 <prvBytesInBuffer+0x62>
	{
		xCount -= pxStreamBuffer->xLength;
    44e4:	eb 81       	ldd	r30, Y+3	; 0x03
    44e6:	fc 81       	ldd	r31, Y+4	; 0x04
    44e8:	24 81       	ldd	r18, Z+4	; 0x04
    44ea:	35 81       	ldd	r19, Z+5	; 0x05
    44ec:	89 81       	ldd	r24, Y+1	; 0x01
    44ee:	9a 81       	ldd	r25, Y+2	; 0x02
    44f0:	82 1b       	sub	r24, r18
    44f2:	93 0b       	sbc	r25, r19
    44f4:	9a 83       	std	Y+2, r25	; 0x02
    44f6:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
    44f8:	89 81       	ldd	r24, Y+1	; 0x01
    44fa:	9a 81       	ldd	r25, Y+2	; 0x02
}
    44fc:	0f 90       	pop	r0
    44fe:	0f 90       	pop	r0
    4500:	0f 90       	pop	r0
    4502:	0f 90       	pop	r0
    4504:	cf 91       	pop	r28
    4506:	df 91       	pop	r29
    4508:	08 95       	ret

0000450a <prvInitialiseNewStreamBuffer>:
static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
										  uint8_t * const pucBuffer,
										  size_t xBufferSizeBytes,
										  size_t xTriggerLevelBytes,
										  uint8_t ucFlags )
{
    450a:	0f 93       	push	r16
    450c:	df 93       	push	r29
    450e:	cf 93       	push	r28
    4510:	cd b7       	in	r28, 0x3d	; 61
    4512:	de b7       	in	r29, 0x3e	; 62
    4514:	29 97       	sbiw	r28, 0x09	; 9
    4516:	0f b6       	in	r0, 0x3f	; 63
    4518:	f8 94       	cli
    451a:	de bf       	out	0x3e, r29	; 62
    451c:	0f be       	out	0x3f, r0	; 63
    451e:	cd bf       	out	0x3d, r28	; 61
    4520:	9a 83       	std	Y+2, r25	; 0x02
    4522:	89 83       	std	Y+1, r24	; 0x01
    4524:	7c 83       	std	Y+4, r23	; 0x04
    4526:	6b 83       	std	Y+3, r22	; 0x03
    4528:	5e 83       	std	Y+6, r21	; 0x06
    452a:	4d 83       	std	Y+5, r20	; 0x05
    452c:	38 87       	std	Y+8, r19	; 0x08
    452e:	2f 83       	std	Y+7, r18	; 0x07
    4530:	09 87       	std	Y+9, r16	; 0x09
		const BaseType_t xWriteValue = 0x55;
		configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
	} /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
	#endif

	( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
    4532:	89 81       	ldd	r24, Y+1	; 0x01
    4534:	9a 81       	ldd	r25, Y+2	; 0x02
    4536:	60 e0       	ldi	r22, 0x00	; 0
    4538:	70 e0       	ldi	r23, 0x00	; 0
    453a:	4f e0       	ldi	r20, 0x0F	; 15
    453c:	50 e0       	ldi	r21, 0x00	; 0
    453e:	0e 94 96 32 	call	0x652c	; 0x652c <memset>
	pxStreamBuffer->pucBuffer = pucBuffer;
    4542:	e9 81       	ldd	r30, Y+1	; 0x01
    4544:	fa 81       	ldd	r31, Y+2	; 0x02
    4546:	8b 81       	ldd	r24, Y+3	; 0x03
    4548:	9c 81       	ldd	r25, Y+4	; 0x04
    454a:	95 87       	std	Z+13, r25	; 0x0d
    454c:	84 87       	std	Z+12, r24	; 0x0c
	pxStreamBuffer->xLength = xBufferSizeBytes;
    454e:	e9 81       	ldd	r30, Y+1	; 0x01
    4550:	fa 81       	ldd	r31, Y+2	; 0x02
    4552:	8d 81       	ldd	r24, Y+5	; 0x05
    4554:	9e 81       	ldd	r25, Y+6	; 0x06
    4556:	95 83       	std	Z+5, r25	; 0x05
    4558:	84 83       	std	Z+4, r24	; 0x04
	pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
    455a:	e9 81       	ldd	r30, Y+1	; 0x01
    455c:	fa 81       	ldd	r31, Y+2	; 0x02
    455e:	8f 81       	ldd	r24, Y+7	; 0x07
    4560:	98 85       	ldd	r25, Y+8	; 0x08
    4562:	97 83       	std	Z+7, r25	; 0x07
    4564:	86 83       	std	Z+6, r24	; 0x06
	pxStreamBuffer->ucFlags = ucFlags;
    4566:	e9 81       	ldd	r30, Y+1	; 0x01
    4568:	fa 81       	ldd	r31, Y+2	; 0x02
    456a:	89 85       	ldd	r24, Y+9	; 0x09
    456c:	86 87       	std	Z+14, r24	; 0x0e
}
    456e:	29 96       	adiw	r28, 0x09	; 9
    4570:	0f b6       	in	r0, 0x3f	; 63
    4572:	f8 94       	cli
    4574:	de bf       	out	0x3e, r29	; 62
    4576:	0f be       	out	0x3f, r0	; 63
    4578:	cd bf       	out	0x3d, r28	; 61
    457a:	cf 91       	pop	r28
    457c:	df 91       	pop	r29
    457e:	0f 91       	pop	r16
    4580:	08 95       	ret

00004582 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    4582:	8f 92       	push	r8
    4584:	9f 92       	push	r9
    4586:	af 92       	push	r10
    4588:	bf 92       	push	r11
    458a:	cf 92       	push	r12
    458c:	df 92       	push	r13
    458e:	ef 92       	push	r14
    4590:	ff 92       	push	r15
    4592:	0f 93       	push	r16
    4594:	1f 93       	push	r17
    4596:	df 93       	push	r29
    4598:	cf 93       	push	r28
    459a:	cd b7       	in	r28, 0x3d	; 61
    459c:	de b7       	in	r29, 0x3e	; 62
    459e:	60 97       	sbiw	r28, 0x10	; 16
    45a0:	0f b6       	in	r0, 0x3f	; 63
    45a2:	f8 94       	cli
    45a4:	de bf       	out	0x3e, r29	; 62
    45a6:	0f be       	out	0x3f, r0	; 63
    45a8:	cd bf       	out	0x3d, r28	; 61
    45aa:	9f 83       	std	Y+7, r25	; 0x07
    45ac:	8e 83       	std	Y+6, r24	; 0x06
    45ae:	79 87       	std	Y+9, r23	; 0x09
    45b0:	68 87       	std	Y+8, r22	; 0x08
    45b2:	5b 87       	std	Y+11, r21	; 0x0b
    45b4:	4a 87       	std	Y+10, r20	; 0x0a
    45b6:	3d 87       	std	Y+13, r19	; 0x0d
    45b8:	2c 87       	std	Y+12, r18	; 0x0c
    45ba:	0e 87       	std	Y+14, r16	; 0x0e
    45bc:	f8 8a       	std	Y+16, r15	; 0x10
    45be:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    45c0:	8a 85       	ldd	r24, Y+10	; 0x0a
    45c2:	9b 85       	ldd	r25, Y+11	; 0x0b
    45c4:	0e 94 02 09 	call	0x1204	; 0x1204 <pvPortMalloc>
    45c8:	9a 83       	std	Y+2, r25	; 0x02
    45ca:	89 83       	std	Y+1, r24	; 0x01

			if( pxStack != NULL )
    45cc:	89 81       	ldd	r24, Y+1	; 0x01
    45ce:	9a 81       	ldd	r25, Y+2	; 0x02
    45d0:	00 97       	sbiw	r24, 0x00	; 0
    45d2:	b1 f0       	breq	.+44     	; 0x4600 <xTaskCreate+0x7e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    45d4:	88 e2       	ldi	r24, 0x28	; 40
    45d6:	90 e0       	ldi	r25, 0x00	; 0
    45d8:	0e 94 02 09 	call	0x1204	; 0x1204 <pvPortMalloc>
    45dc:	9d 83       	std	Y+5, r25	; 0x05
    45de:	8c 83       	std	Y+4, r24	; 0x04

				if( pxNewTCB != NULL )
    45e0:	8c 81       	ldd	r24, Y+4	; 0x04
    45e2:	9d 81       	ldd	r25, Y+5	; 0x05
    45e4:	00 97       	sbiw	r24, 0x00	; 0
    45e6:	39 f0       	breq	.+14     	; 0x45f6 <xTaskCreate+0x74>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    45e8:	ec 81       	ldd	r30, Y+4	; 0x04
    45ea:	fd 81       	ldd	r31, Y+5	; 0x05
    45ec:	89 81       	ldd	r24, Y+1	; 0x01
    45ee:	9a 81       	ldd	r25, Y+2	; 0x02
    45f0:	90 8f       	std	Z+24, r25	; 0x18
    45f2:	87 8b       	std	Z+23, r24	; 0x17
    45f4:	07 c0       	rjmp	.+14     	; 0x4604 <xTaskCreate+0x82>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    45f6:	89 81       	ldd	r24, Y+1	; 0x01
    45f8:	9a 81       	ldd	r25, Y+2	; 0x02
    45fa:	0e 94 58 09 	call	0x12b0	; 0x12b0 <vPortFree>
    45fe:	02 c0       	rjmp	.+4      	; 0x4604 <xTaskCreate+0x82>
				}
			}
			else
			{
				pxNewTCB = NULL;
    4600:	1d 82       	std	Y+5, r1	; 0x05
    4602:	1c 82       	std	Y+4, r1	; 0x04
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    4604:	8c 81       	ldd	r24, Y+4	; 0x04
    4606:	9d 81       	ldd	r25, Y+5	; 0x05
    4608:	00 97       	sbiw	r24, 0x00	; 0
    460a:	e9 f0       	breq	.+58     	; 0x4646 <xTaskCreate+0xc4>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    460c:	8a 85       	ldd	r24, Y+10	; 0x0a
    460e:	9b 85       	ldd	r25, Y+11	; 0x0b
    4610:	9c 01       	movw	r18, r24
    4612:	40 e0       	ldi	r20, 0x00	; 0
    4614:	50 e0       	ldi	r21, 0x00	; 0
    4616:	8e 81       	ldd	r24, Y+6	; 0x06
    4618:	9f 81       	ldd	r25, Y+7	; 0x07
    461a:	68 85       	ldd	r22, Y+8	; 0x08
    461c:	79 85       	ldd	r23, Y+9	; 0x09
    461e:	ec 85       	ldd	r30, Y+12	; 0x0c
    4620:	fd 85       	ldd	r31, Y+13	; 0x0d
    4622:	af 85       	ldd	r26, Y+15	; 0x0f
    4624:	b8 89       	ldd	r27, Y+16	; 0x10
    4626:	ac 80       	ldd	r10, Y+4	; 0x04
    4628:	bd 80       	ldd	r11, Y+5	; 0x05
    462a:	8f 01       	movw	r16, r30
    462c:	ee 84       	ldd	r14, Y+14	; 0x0e
    462e:	6d 01       	movw	r12, r26
    4630:	88 24       	eor	r8, r8
    4632:	99 24       	eor	r9, r9
    4634:	0e 94 39 23 	call	0x4672	; 0x4672 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    4638:	8c 81       	ldd	r24, Y+4	; 0x04
    463a:	9d 81       	ldd	r25, Y+5	; 0x05
    463c:	0e 94 fc 23 	call	0x47f8	; 0x47f8 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    4640:	81 e0       	ldi	r24, 0x01	; 1
    4642:	8b 83       	std	Y+3, r24	; 0x03
    4644:	02 c0       	rjmp	.+4      	; 0x464a <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    4646:	8f ef       	ldi	r24, 0xFF	; 255
    4648:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    464a:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    464c:	60 96       	adiw	r28, 0x10	; 16
    464e:	0f b6       	in	r0, 0x3f	; 63
    4650:	f8 94       	cli
    4652:	de bf       	out	0x3e, r29	; 62
    4654:	0f be       	out	0x3f, r0	; 63
    4656:	cd bf       	out	0x3d, r28	; 61
    4658:	cf 91       	pop	r28
    465a:	df 91       	pop	r29
    465c:	1f 91       	pop	r17
    465e:	0f 91       	pop	r16
    4660:	ff 90       	pop	r15
    4662:	ef 90       	pop	r14
    4664:	df 90       	pop	r13
    4666:	cf 90       	pop	r12
    4668:	bf 90       	pop	r11
    466a:	af 90       	pop	r10
    466c:	9f 90       	pop	r9
    466e:	8f 90       	pop	r8
    4670:	08 95       	ret

00004672 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
    4672:	8f 92       	push	r8
    4674:	9f 92       	push	r9
    4676:	af 92       	push	r10
    4678:	bf 92       	push	r11
    467a:	cf 92       	push	r12
    467c:	df 92       	push	r13
    467e:	ef 92       	push	r14
    4680:	0f 93       	push	r16
    4682:	1f 93       	push	r17
    4684:	df 93       	push	r29
    4686:	cf 93       	push	r28
    4688:	cd b7       	in	r28, 0x3d	; 61
    468a:	de b7       	in	r29, 0x3e	; 62
    468c:	64 97       	sbiw	r28, 0x14	; 20
    468e:	0f b6       	in	r0, 0x3f	; 63
    4690:	f8 94       	cli
    4692:	de bf       	out	0x3e, r29	; 62
    4694:	0f be       	out	0x3f, r0	; 63
    4696:	cd bf       	out	0x3d, r28	; 61
    4698:	9d 83       	std	Y+5, r25	; 0x05
    469a:	8c 83       	std	Y+4, r24	; 0x04
    469c:	7f 83       	std	Y+7, r23	; 0x07
    469e:	6e 83       	std	Y+6, r22	; 0x06
    46a0:	28 87       	std	Y+8, r18	; 0x08
    46a2:	39 87       	std	Y+9, r19	; 0x09
    46a4:	4a 87       	std	Y+10, r20	; 0x0a
    46a6:	5b 87       	std	Y+11, r21	; 0x0b
    46a8:	1d 87       	std	Y+13, r17	; 0x0d
    46aa:	0c 87       	std	Y+12, r16	; 0x0c
    46ac:	ee 86       	std	Y+14, r14	; 0x0e
    46ae:	d8 8a       	std	Y+16, r13	; 0x10
    46b0:	cf 86       	std	Y+15, r12	; 0x0f
    46b2:	ba 8a       	std	Y+18, r11	; 0x12
    46b4:	a9 8a       	std	Y+17, r10	; 0x11
    46b6:	9c 8a       	std	Y+20, r9	; 0x14
    46b8:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    46ba:	e9 89       	ldd	r30, Y+17	; 0x11
    46bc:	fa 89       	ldd	r31, Y+18	; 0x12
    46be:	27 89       	ldd	r18, Z+23	; 0x17
    46c0:	30 8d       	ldd	r19, Z+24	; 0x18
    46c2:	88 85       	ldd	r24, Y+8	; 0x08
    46c4:	99 85       	ldd	r25, Y+9	; 0x09
    46c6:	01 97       	sbiw	r24, 0x01	; 1
    46c8:	82 0f       	add	r24, r18
    46ca:	93 1f       	adc	r25, r19
    46cc:	9b 83       	std	Y+3, r25	; 0x03
    46ce:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    46d0:	8e 81       	ldd	r24, Y+6	; 0x06
    46d2:	9f 81       	ldd	r25, Y+7	; 0x07
    46d4:	00 97       	sbiw	r24, 0x00	; 0
    46d6:	51 f1       	breq	.+84     	; 0x472c <prvInitialiseNewTask+0xba>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    46d8:	19 82       	std	Y+1, r1	; 0x01
    46da:	21 c0       	rjmp	.+66     	; 0x471e <prvInitialiseNewTask+0xac>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    46dc:	89 81       	ldd	r24, Y+1	; 0x01
    46de:	48 2f       	mov	r20, r24
    46e0:	50 e0       	ldi	r21, 0x00	; 0
    46e2:	89 81       	ldd	r24, Y+1	; 0x01
    46e4:	28 2f       	mov	r18, r24
    46e6:	30 e0       	ldi	r19, 0x00	; 0
    46e8:	8e 81       	ldd	r24, Y+6	; 0x06
    46ea:	9f 81       	ldd	r25, Y+7	; 0x07
    46ec:	fc 01       	movw	r30, r24
    46ee:	e2 0f       	add	r30, r18
    46f0:	f3 1f       	adc	r31, r19
    46f2:	20 81       	ld	r18, Z
    46f4:	89 89       	ldd	r24, Y+17	; 0x11
    46f6:	9a 89       	ldd	r25, Y+18	; 0x12
    46f8:	84 0f       	add	r24, r20
    46fa:	95 1f       	adc	r25, r21
    46fc:	fc 01       	movw	r30, r24
    46fe:	79 96       	adiw	r30, 0x19	; 25
    4700:	20 83       	st	Z, r18

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    4702:	89 81       	ldd	r24, Y+1	; 0x01
    4704:	28 2f       	mov	r18, r24
    4706:	30 e0       	ldi	r19, 0x00	; 0
    4708:	8e 81       	ldd	r24, Y+6	; 0x06
    470a:	9f 81       	ldd	r25, Y+7	; 0x07
    470c:	fc 01       	movw	r30, r24
    470e:	e2 0f       	add	r30, r18
    4710:	f3 1f       	adc	r31, r19
    4712:	80 81       	ld	r24, Z
    4714:	88 23       	and	r24, r24
    4716:	31 f0       	breq	.+12     	; 0x4724 <prvInitialiseNewTask+0xb2>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    4718:	89 81       	ldd	r24, Y+1	; 0x01
    471a:	8f 5f       	subi	r24, 0xFF	; 255
    471c:	89 83       	std	Y+1, r24	; 0x01
    471e:	89 81       	ldd	r24, Y+1	; 0x01
    4720:	88 30       	cpi	r24, 0x08	; 8
    4722:	e0 f2       	brcs	.-72     	; 0x46dc <prvInitialiseNewTask+0x6a>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    4724:	e9 89       	ldd	r30, Y+17	; 0x11
    4726:	fa 89       	ldd	r31, Y+18	; 0x12
    4728:	10 a2       	std	Z+32, r1	; 0x20
    472a:	03 c0       	rjmp	.+6      	; 0x4732 <prvInitialiseNewTask+0xc0>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    472c:	e9 89       	ldd	r30, Y+17	; 0x11
    472e:	fa 89       	ldd	r31, Y+18	; 0x12
    4730:	11 8e       	std	Z+25, r1	; 0x19
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    4732:	8e 85       	ldd	r24, Y+14	; 0x0e
    4734:	8a 30       	cpi	r24, 0x0A	; 10
    4736:	10 f0       	brcs	.+4      	; 0x473c <prvInitialiseNewTask+0xca>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    4738:	89 e0       	ldi	r24, 0x09	; 9
    473a:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    473c:	e9 89       	ldd	r30, Y+17	; 0x11
    473e:	fa 89       	ldd	r31, Y+18	; 0x12
    4740:	8e 85       	ldd	r24, Y+14	; 0x0e
    4742:	86 8b       	std	Z+22, r24	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
    4744:	e9 89       	ldd	r30, Y+17	; 0x11
    4746:	fa 89       	ldd	r31, Y+18	; 0x12
    4748:	8e 85       	ldd	r24, Y+14	; 0x0e
    474a:	81 a3       	std	Z+33, r24	; 0x21
		pxNewTCB->uxMutexesHeld = 0;
    474c:	e9 89       	ldd	r30, Y+17	; 0x11
    474e:	fa 89       	ldd	r31, Y+18	; 0x12
    4750:	12 a2       	std	Z+34, r1	; 0x22
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    4752:	89 89       	ldd	r24, Y+17	; 0x11
    4754:	9a 89       	ldd	r25, Y+18	; 0x12
    4756:	02 96       	adiw	r24, 0x02	; 2
    4758:	0e 94 a8 09 	call	0x1350	; 0x1350 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    475c:	89 89       	ldd	r24, Y+17	; 0x11
    475e:	9a 89       	ldd	r25, Y+18	; 0x12
    4760:	0c 96       	adiw	r24, 0x0c	; 12
    4762:	0e 94 a8 09 	call	0x1350	; 0x1350 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    4766:	e9 89       	ldd	r30, Y+17	; 0x11
    4768:	fa 89       	ldd	r31, Y+18	; 0x12
    476a:	89 89       	ldd	r24, Y+17	; 0x11
    476c:	9a 89       	ldd	r25, Y+18	; 0x12
    476e:	91 87       	std	Z+9, r25	; 0x09
    4770:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4772:	8e 85       	ldd	r24, Y+14	; 0x0e
    4774:	28 2f       	mov	r18, r24
    4776:	30 e0       	ldi	r19, 0x00	; 0
    4778:	8a e0       	ldi	r24, 0x0A	; 10
    477a:	90 e0       	ldi	r25, 0x00	; 0
    477c:	82 1b       	sub	r24, r18
    477e:	93 0b       	sbc	r25, r19
    4780:	e9 89       	ldd	r30, Y+17	; 0x11
    4782:	fa 89       	ldd	r31, Y+18	; 0x12
    4784:	95 87       	std	Z+13, r25	; 0x0d
    4786:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    4788:	e9 89       	ldd	r30, Y+17	; 0x11
    478a:	fa 89       	ldd	r31, Y+18	; 0x12
    478c:	89 89       	ldd	r24, Y+17	; 0x11
    478e:	9a 89       	ldd	r25, Y+18	; 0x12
    4790:	93 8b       	std	Z+19, r25	; 0x13
    4792:	82 8b       	std	Z+18, r24	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    4794:	e9 89       	ldd	r30, Y+17	; 0x11
    4796:	fa 89       	ldd	r31, Y+18	; 0x12
    4798:	13 a2       	std	Z+35, r1	; 0x23
    479a:	14 a2       	std	Z+36, r1	; 0x24
    479c:	15 a2       	std	Z+37, r1	; 0x25
    479e:	16 a2       	std	Z+38, r1	; 0x26
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    47a0:	e9 89       	ldd	r30, Y+17	; 0x11
    47a2:	fa 89       	ldd	r31, Y+18	; 0x12
    47a4:	17 a2       	std	Z+39, r1	; 0x27
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    47a6:	8a 81       	ldd	r24, Y+2	; 0x02
    47a8:	9b 81       	ldd	r25, Y+3	; 0x03
    47aa:	2c 81       	ldd	r18, Y+4	; 0x04
    47ac:	3d 81       	ldd	r19, Y+5	; 0x05
    47ae:	4c 85       	ldd	r20, Y+12	; 0x0c
    47b0:	5d 85       	ldd	r21, Y+13	; 0x0d
    47b2:	b9 01       	movw	r22, r18
    47b4:	0e 94 23 10 	call	0x2046	; 0x2046 <pxPortInitialiseStack>
    47b8:	e9 89       	ldd	r30, Y+17	; 0x11
    47ba:	fa 89       	ldd	r31, Y+18	; 0x12
    47bc:	91 83       	std	Z+1, r25	; 0x01
    47be:	80 83       	st	Z, r24
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    47c0:	8f 85       	ldd	r24, Y+15	; 0x0f
    47c2:	98 89       	ldd	r25, Y+16	; 0x10
    47c4:	00 97       	sbiw	r24, 0x00	; 0
    47c6:	31 f0       	breq	.+12     	; 0x47d4 <prvInitialiseNewTask+0x162>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    47c8:	ef 85       	ldd	r30, Y+15	; 0x0f
    47ca:	f8 89       	ldd	r31, Y+16	; 0x10
    47cc:	89 89       	ldd	r24, Y+17	; 0x11
    47ce:	9a 89       	ldd	r25, Y+18	; 0x12
    47d0:	91 83       	std	Z+1, r25	; 0x01
    47d2:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    47d4:	64 96       	adiw	r28, 0x14	; 20
    47d6:	0f b6       	in	r0, 0x3f	; 63
    47d8:	f8 94       	cli
    47da:	de bf       	out	0x3e, r29	; 62
    47dc:	0f be       	out	0x3f, r0	; 63
    47de:	cd bf       	out	0x3d, r28	; 61
    47e0:	cf 91       	pop	r28
    47e2:	df 91       	pop	r29
    47e4:	1f 91       	pop	r17
    47e6:	0f 91       	pop	r16
    47e8:	ef 90       	pop	r14
    47ea:	df 90       	pop	r13
    47ec:	cf 90       	pop	r12
    47ee:	bf 90       	pop	r11
    47f0:	af 90       	pop	r10
    47f2:	9f 90       	pop	r9
    47f4:	8f 90       	pop	r8
    47f6:	08 95       	ret

000047f8 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    47f8:	df 93       	push	r29
    47fa:	cf 93       	push	r28
    47fc:	00 d0       	rcall	.+0      	; 0x47fe <prvAddNewTaskToReadyList+0x6>
    47fe:	cd b7       	in	r28, 0x3d	; 61
    4800:	de b7       	in	r29, 0x3e	; 62
    4802:	9a 83       	std	Y+2, r25	; 0x02
    4804:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    4806:	0f b6       	in	r0, 0x3f	; 63
    4808:	f8 94       	cli
    480a:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    480c:	80 91 85 07 	lds	r24, 0x0785
    4810:	8f 5f       	subi	r24, 0xFF	; 255
    4812:	80 93 85 07 	sts	0x0785, r24
		if( pxCurrentTCB == NULL )
    4816:	80 91 82 07 	lds	r24, 0x0782
    481a:	90 91 83 07 	lds	r25, 0x0783
    481e:	00 97       	sbiw	r24, 0x00	; 0
    4820:	69 f4       	brne	.+26     	; 0x483c <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    4822:	89 81       	ldd	r24, Y+1	; 0x01
    4824:	9a 81       	ldd	r25, Y+2	; 0x02
    4826:	90 93 83 07 	sts	0x0783, r25
    482a:	80 93 82 07 	sts	0x0782, r24

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    482e:	80 91 85 07 	lds	r24, 0x0785
    4832:	81 30       	cpi	r24, 0x01	; 1
    4834:	b9 f4       	brne	.+46     	; 0x4864 <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    4836:	0e 94 45 2b 	call	0x568a	; 0x568a <prvInitialiseTaskLists>
    483a:	14 c0       	rjmp	.+40     	; 0x4864 <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    483c:	80 91 89 07 	lds	r24, 0x0789
    4840:	88 23       	and	r24, r24
    4842:	81 f4       	brne	.+32     	; 0x4864 <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    4844:	e0 91 82 07 	lds	r30, 0x0782
    4848:	f0 91 83 07 	lds	r31, 0x0783
    484c:	96 89       	ldd	r25, Z+22	; 0x16
    484e:	e9 81       	ldd	r30, Y+1	; 0x01
    4850:	fa 81       	ldd	r31, Y+2	; 0x02
    4852:	86 89       	ldd	r24, Z+22	; 0x16
    4854:	89 17       	cp	r24, r25
    4856:	30 f0       	brcs	.+12     	; 0x4864 <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
    4858:	89 81       	ldd	r24, Y+1	; 0x01
    485a:	9a 81       	ldd	r25, Y+2	; 0x02
    485c:	90 93 83 07 	sts	0x0783, r25
    4860:	80 93 82 07 	sts	0x0782, r24
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    4864:	80 91 8d 07 	lds	r24, 0x078D
    4868:	8f 5f       	subi	r24, 0xFF	; 255
    486a:	80 93 8d 07 	sts	0x078D, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    486e:	e9 81       	ldd	r30, Y+1	; 0x01
    4870:	fa 81       	ldd	r31, Y+2	; 0x02
    4872:	96 89       	ldd	r25, Z+22	; 0x16
    4874:	80 91 88 07 	lds	r24, 0x0788
    4878:	89 17       	cp	r24, r25
    487a:	28 f4       	brcc	.+10     	; 0x4886 <prvAddNewTaskToReadyList+0x8e>
    487c:	e9 81       	ldd	r30, Y+1	; 0x01
    487e:	fa 81       	ldd	r31, Y+2	; 0x02
    4880:	86 89       	ldd	r24, Z+22	; 0x16
    4882:	80 93 88 07 	sts	0x0788, r24
    4886:	e9 81       	ldd	r30, Y+1	; 0x01
    4888:	fa 81       	ldd	r31, Y+2	; 0x02
    488a:	86 89       	ldd	r24, Z+22	; 0x16
    488c:	28 2f       	mov	r18, r24
    488e:	30 e0       	ldi	r19, 0x00	; 0
    4890:	c9 01       	movw	r24, r18
    4892:	88 0f       	add	r24, r24
    4894:	99 1f       	adc	r25, r25
    4896:	88 0f       	add	r24, r24
    4898:	99 1f       	adc	r25, r25
    489a:	88 0f       	add	r24, r24
    489c:	99 1f       	adc	r25, r25
    489e:	82 0f       	add	r24, r18
    48a0:	93 1f       	adc	r25, r19
    48a2:	ac 01       	movw	r20, r24
    48a4:	4d 56       	subi	r20, 0x6D	; 109
    48a6:	58 4f       	sbci	r21, 0xF8	; 248
    48a8:	89 81       	ldd	r24, Y+1	; 0x01
    48aa:	9a 81       	ldd	r25, Y+2	; 0x02
    48ac:	9c 01       	movw	r18, r24
    48ae:	2e 5f       	subi	r18, 0xFE	; 254
    48b0:	3f 4f       	sbci	r19, 0xFF	; 255
    48b2:	ca 01       	movw	r24, r20
    48b4:	b9 01       	movw	r22, r18
    48b6:	0e 94 b8 09 	call	0x1370	; 0x1370 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    48ba:	0f 90       	pop	r0
    48bc:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    48be:	80 91 89 07 	lds	r24, 0x0789
    48c2:	88 23       	and	r24, r24
    48c4:	61 f0       	breq	.+24     	; 0x48de <prvAddNewTaskToReadyList+0xe6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    48c6:	e0 91 82 07 	lds	r30, 0x0782
    48ca:	f0 91 83 07 	lds	r31, 0x0783
    48ce:	96 89       	ldd	r25, Z+22	; 0x16
    48d0:	e9 81       	ldd	r30, Y+1	; 0x01
    48d2:	fa 81       	ldd	r31, Y+2	; 0x02
    48d4:	86 89       	ldd	r24, Z+22	; 0x16
    48d6:	98 17       	cp	r25, r24
    48d8:	10 f4       	brcc	.+4      	; 0x48de <prvAddNewTaskToReadyList+0xe6>
		{
			taskYIELD_IF_USING_PREEMPTION();
    48da:	0e 94 e2 11 	call	0x23c4	; 0x23c4 <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    48de:	0f 90       	pop	r0
    48e0:	0f 90       	pop	r0
    48e2:	cf 91       	pop	r28
    48e4:	df 91       	pop	r29
    48e6:	08 95       	ret

000048e8 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    48e8:	df 93       	push	r29
    48ea:	cf 93       	push	r28
    48ec:	00 d0       	rcall	.+0      	; 0x48ee <vTaskDelete+0x6>
    48ee:	00 d0       	rcall	.+0      	; 0x48f0 <vTaskDelete+0x8>
    48f0:	00 d0       	rcall	.+0      	; 0x48f2 <vTaskDelete+0xa>
    48f2:	cd b7       	in	r28, 0x3d	; 61
    48f4:	de b7       	in	r29, 0x3e	; 62
    48f6:	9c 83       	std	Y+4, r25	; 0x04
    48f8:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    48fa:	0f b6       	in	r0, 0x3f	; 63
    48fc:	f8 94       	cli
    48fe:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    4900:	8b 81       	ldd	r24, Y+3	; 0x03
    4902:	9c 81       	ldd	r25, Y+4	; 0x04
    4904:	00 97       	sbiw	r24, 0x00	; 0
    4906:	39 f4       	brne	.+14     	; 0x4916 <vTaskDelete+0x2e>
    4908:	80 91 82 07 	lds	r24, 0x0782
    490c:	90 91 83 07 	lds	r25, 0x0783
    4910:	9e 83       	std	Y+6, r25	; 0x06
    4912:	8d 83       	std	Y+5, r24	; 0x05
    4914:	04 c0       	rjmp	.+8      	; 0x491e <vTaskDelete+0x36>
    4916:	8b 81       	ldd	r24, Y+3	; 0x03
    4918:	9c 81       	ldd	r25, Y+4	; 0x04
    491a:	9e 83       	std	Y+6, r25	; 0x06
    491c:	8d 83       	std	Y+5, r24	; 0x05
    491e:	8d 81       	ldd	r24, Y+5	; 0x05
    4920:	9e 81       	ldd	r25, Y+6	; 0x06
    4922:	9a 83       	std	Y+2, r25	; 0x02
    4924:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    4926:	89 81       	ldd	r24, Y+1	; 0x01
    4928:	9a 81       	ldd	r25, Y+2	; 0x02
    492a:	02 96       	adiw	r24, 0x02	; 2
    492c:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    4930:	e9 81       	ldd	r30, Y+1	; 0x01
    4932:	fa 81       	ldd	r31, Y+2	; 0x02
    4934:	84 89       	ldd	r24, Z+20	; 0x14
    4936:	95 89       	ldd	r25, Z+21	; 0x15
    4938:	00 97       	sbiw	r24, 0x00	; 0
    493a:	29 f0       	breq	.+10     	; 0x4946 <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    493c:	89 81       	ldd	r24, Y+1	; 0x01
    493e:	9a 81       	ldd	r25, Y+2	; 0x02
    4940:	0c 96       	adiw	r24, 0x0c	; 12
    4942:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    4946:	80 91 8d 07 	lds	r24, 0x078D
    494a:	8f 5f       	subi	r24, 0xFF	; 255
    494c:	80 93 8d 07 	sts	0x078D, r24

			if( pxTCB == pxCurrentTCB )
    4950:	20 91 82 07 	lds	r18, 0x0782
    4954:	30 91 83 07 	lds	r19, 0x0783
    4958:	89 81       	ldd	r24, Y+1	; 0x01
    495a:	9a 81       	ldd	r25, Y+2	; 0x02
    495c:	82 17       	cp	r24, r18
    495e:	93 07       	cpc	r25, r19
    4960:	81 f4       	brne	.+32     	; 0x4982 <vTaskDelete+0x9a>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    4962:	89 81       	ldd	r24, Y+1	; 0x01
    4964:	9a 81       	ldd	r25, Y+2	; 0x02
    4966:	9c 01       	movw	r18, r24
    4968:	2e 5f       	subi	r18, 0xFE	; 254
    496a:	3f 4f       	sbci	r19, 0xFF	; 255
    496c:	8c e0       	ldi	r24, 0x0C	; 12
    496e:	98 e0       	ldi	r25, 0x08	; 8
    4970:	b9 01       	movw	r22, r18
    4972:	0e 94 b8 09 	call	0x1370	; 0x1370 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    4976:	80 91 84 07 	lds	r24, 0x0784
    497a:	8f 5f       	subi	r24, 0xFF	; 255
    497c:	80 93 84 07 	sts	0x0784, r24
    4980:	0b c0       	rjmp	.+22     	; 0x4998 <vTaskDelete+0xb0>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    4982:	80 91 85 07 	lds	r24, 0x0785
    4986:	81 50       	subi	r24, 0x01	; 1
    4988:	80 93 85 07 	sts	0x0785, r24
				prvDeleteTCB( pxTCB );
    498c:	89 81       	ldd	r24, Y+1	; 0x01
    498e:	9a 81       	ldd	r25, Y+2	; 0x02
    4990:	0e 94 b5 2b 	call	0x576a	; 0x576a <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    4994:	0e 94 cb 2b 	call	0x5796	; 0x5796 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    4998:	0f 90       	pop	r0
    499a:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    499c:	80 91 89 07 	lds	r24, 0x0789
    49a0:	88 23       	and	r24, r24
    49a2:	59 f0       	breq	.+22     	; 0x49ba <vTaskDelete+0xd2>
		{
			if( pxTCB == pxCurrentTCB )
    49a4:	20 91 82 07 	lds	r18, 0x0782
    49a8:	30 91 83 07 	lds	r19, 0x0783
    49ac:	89 81       	ldd	r24, Y+1	; 0x01
    49ae:	9a 81       	ldd	r25, Y+2	; 0x02
    49b0:	82 17       	cp	r24, r18
    49b2:	93 07       	cpc	r25, r19
    49b4:	11 f4       	brne	.+4      	; 0x49ba <vTaskDelete+0xd2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    49b6:	0e 94 e2 11 	call	0x23c4	; 0x23c4 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    49ba:	26 96       	adiw	r28, 0x06	; 6
    49bc:	0f b6       	in	r0, 0x3f	; 63
    49be:	f8 94       	cli
    49c0:	de bf       	out	0x3e, r29	; 62
    49c2:	0f be       	out	0x3f, r0	; 63
    49c4:	cd bf       	out	0x3d, r28	; 61
    49c6:	cf 91       	pop	r28
    49c8:	df 91       	pop	r29
    49ca:	08 95       	ret

000049cc <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    49cc:	df 93       	push	r29
    49ce:	cf 93       	push	r28
    49d0:	cd b7       	in	r28, 0x3d	; 61
    49d2:	de b7       	in	r29, 0x3e	; 62
    49d4:	2a 97       	sbiw	r28, 0x0a	; 10
    49d6:	0f b6       	in	r0, 0x3f	; 63
    49d8:	f8 94       	cli
    49da:	de bf       	out	0x3e, r29	; 62
    49dc:	0f be       	out	0x3f, r0	; 63
    49de:	cd bf       	out	0x3d, r28	; 61
    49e0:	98 87       	std	Y+8, r25	; 0x08
    49e2:	8f 83       	std	Y+7, r24	; 0x07
    49e4:	7a 87       	std	Y+10, r23	; 0x0a
    49e6:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    49e8:	1b 82       	std	Y+3, r1	; 0x03

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    49ea:	0e 94 25 27 	call	0x4e4a	; 0x4e4a <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    49ee:	80 91 86 07 	lds	r24, 0x0786
    49f2:	90 91 87 07 	lds	r25, 0x0787
    49f6:	9a 83       	std	Y+2, r25	; 0x02
    49f8:	89 83       	std	Y+1, r24	; 0x01

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    49fa:	ef 81       	ldd	r30, Y+7	; 0x07
    49fc:	f8 85       	ldd	r31, Y+8	; 0x08
    49fe:	20 81       	ld	r18, Z
    4a00:	31 81       	ldd	r19, Z+1	; 0x01
    4a02:	89 85       	ldd	r24, Y+9	; 0x09
    4a04:	9a 85       	ldd	r25, Y+10	; 0x0a
    4a06:	82 0f       	add	r24, r18
    4a08:	93 1f       	adc	r25, r19
    4a0a:	9e 83       	std	Y+6, r25	; 0x06
    4a0c:	8d 83       	std	Y+5, r24	; 0x05

			if( xConstTickCount < *pxPreviousWakeTime )
    4a0e:	ef 81       	ldd	r30, Y+7	; 0x07
    4a10:	f8 85       	ldd	r31, Y+8	; 0x08
    4a12:	20 81       	ld	r18, Z
    4a14:	31 81       	ldd	r19, Z+1	; 0x01
    4a16:	89 81       	ldd	r24, Y+1	; 0x01
    4a18:	9a 81       	ldd	r25, Y+2	; 0x02
    4a1a:	82 17       	cp	r24, r18
    4a1c:	93 07       	cpc	r25, r19
    4a1e:	98 f4       	brcc	.+38     	; 0x4a46 <vTaskDelayUntil+0x7a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    4a20:	ef 81       	ldd	r30, Y+7	; 0x07
    4a22:	f8 85       	ldd	r31, Y+8	; 0x08
    4a24:	20 81       	ld	r18, Z
    4a26:	31 81       	ldd	r19, Z+1	; 0x01
    4a28:	8d 81       	ldd	r24, Y+5	; 0x05
    4a2a:	9e 81       	ldd	r25, Y+6	; 0x06
    4a2c:	82 17       	cp	r24, r18
    4a2e:	93 07       	cpc	r25, r19
    4a30:	e0 f4       	brcc	.+56     	; 0x4a6a <vTaskDelayUntil+0x9e>
    4a32:	2d 81       	ldd	r18, Y+5	; 0x05
    4a34:	3e 81       	ldd	r19, Y+6	; 0x06
    4a36:	89 81       	ldd	r24, Y+1	; 0x01
    4a38:	9a 81       	ldd	r25, Y+2	; 0x02
    4a3a:	82 17       	cp	r24, r18
    4a3c:	93 07       	cpc	r25, r19
    4a3e:	a8 f4       	brcc	.+42     	; 0x4a6a <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    4a40:	81 e0       	ldi	r24, 0x01	; 1
    4a42:	8b 83       	std	Y+3, r24	; 0x03
    4a44:	12 c0       	rjmp	.+36     	; 0x4a6a <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    4a46:	ef 81       	ldd	r30, Y+7	; 0x07
    4a48:	f8 85       	ldd	r31, Y+8	; 0x08
    4a4a:	20 81       	ld	r18, Z
    4a4c:	31 81       	ldd	r19, Z+1	; 0x01
    4a4e:	8d 81       	ldd	r24, Y+5	; 0x05
    4a50:	9e 81       	ldd	r25, Y+6	; 0x06
    4a52:	82 17       	cp	r24, r18
    4a54:	93 07       	cpc	r25, r19
    4a56:	38 f0       	brcs	.+14     	; 0x4a66 <vTaskDelayUntil+0x9a>
    4a58:	2d 81       	ldd	r18, Y+5	; 0x05
    4a5a:	3e 81       	ldd	r19, Y+6	; 0x06
    4a5c:	89 81       	ldd	r24, Y+1	; 0x01
    4a5e:	9a 81       	ldd	r25, Y+2	; 0x02
    4a60:	82 17       	cp	r24, r18
    4a62:	93 07       	cpc	r25, r19
    4a64:	10 f4       	brcc	.+4      	; 0x4a6a <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    4a66:	81 e0       	ldi	r24, 0x01	; 1
    4a68:	8b 83       	std	Y+3, r24	; 0x03
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    4a6a:	ef 81       	ldd	r30, Y+7	; 0x07
    4a6c:	f8 85       	ldd	r31, Y+8	; 0x08
    4a6e:	8d 81       	ldd	r24, Y+5	; 0x05
    4a70:	9e 81       	ldd	r25, Y+6	; 0x06
    4a72:	91 83       	std	Z+1, r25	; 0x01
    4a74:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    4a76:	8b 81       	ldd	r24, Y+3	; 0x03
    4a78:	88 23       	and	r24, r24
    4a7a:	49 f0       	breq	.+18     	; 0x4a8e <vTaskDelayUntil+0xc2>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    4a7c:	8d 81       	ldd	r24, Y+5	; 0x05
    4a7e:	9e 81       	ldd	r25, Y+6	; 0x06
    4a80:	29 81       	ldd	r18, Y+1	; 0x01
    4a82:	3a 81       	ldd	r19, Y+2	; 0x02
    4a84:	82 1b       	sub	r24, r18
    4a86:	93 0b       	sbc	r25, r19
    4a88:	60 e0       	ldi	r22, 0x00	; 0
    4a8a:	0e 94 94 31 	call	0x6328	; 0x6328 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    4a8e:	0e 94 31 27 	call	0x4e62	; 0x4e62 <xTaskResumeAll>
    4a92:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    4a94:	8c 81       	ldd	r24, Y+4	; 0x04
    4a96:	88 23       	and	r24, r24
    4a98:	11 f4       	brne	.+4      	; 0x4a9e <vTaskDelayUntil+0xd2>
		{
			portYIELD_WITHIN_API();
    4a9a:	0e 94 e2 11 	call	0x23c4	; 0x23c4 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    4a9e:	2a 96       	adiw	r28, 0x0a	; 10
    4aa0:	0f b6       	in	r0, 0x3f	; 63
    4aa2:	f8 94       	cli
    4aa4:	de bf       	out	0x3e, r29	; 62
    4aa6:	0f be       	out	0x3f, r0	; 63
    4aa8:	cd bf       	out	0x3d, r28	; 61
    4aaa:	cf 91       	pop	r28
    4aac:	df 91       	pop	r29
    4aae:	08 95       	ret

00004ab0 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    4ab0:	df 93       	push	r29
    4ab2:	cf 93       	push	r28
    4ab4:	00 d0       	rcall	.+0      	; 0x4ab6 <vTaskDelay+0x6>
    4ab6:	0f 92       	push	r0
    4ab8:	cd b7       	in	r28, 0x3d	; 61
    4aba:	de b7       	in	r29, 0x3e	; 62
    4abc:	9b 83       	std	Y+3, r25	; 0x03
    4abe:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    4ac0:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    4ac2:	8a 81       	ldd	r24, Y+2	; 0x02
    4ac4:	9b 81       	ldd	r25, Y+3	; 0x03
    4ac6:	00 97       	sbiw	r24, 0x00	; 0
    4ac8:	51 f0       	breq	.+20     	; 0x4ade <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    4aca:	0e 94 25 27 	call	0x4e4a	; 0x4e4a <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    4ace:	8a 81       	ldd	r24, Y+2	; 0x02
    4ad0:	9b 81       	ldd	r25, Y+3	; 0x03
    4ad2:	60 e0       	ldi	r22, 0x00	; 0
    4ad4:	0e 94 94 31 	call	0x6328	; 0x6328 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    4ad8:	0e 94 31 27 	call	0x4e62	; 0x4e62 <xTaskResumeAll>
    4adc:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    4ade:	89 81       	ldd	r24, Y+1	; 0x01
    4ae0:	88 23       	and	r24, r24
    4ae2:	11 f4       	brne	.+4      	; 0x4ae8 <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    4ae4:	0e 94 e2 11 	call	0x23c4	; 0x23c4 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    4ae8:	0f 90       	pop	r0
    4aea:	0f 90       	pop	r0
    4aec:	0f 90       	pop	r0
    4aee:	cf 91       	pop	r28
    4af0:	df 91       	pop	r29
    4af2:	08 95       	ret

00004af4 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    4af4:	df 93       	push	r29
    4af6:	cf 93       	push	r28
    4af8:	00 d0       	rcall	.+0      	; 0x4afa <vTaskSuspend+0x6>
    4afa:	00 d0       	rcall	.+0      	; 0x4afc <vTaskSuspend+0x8>
    4afc:	00 d0       	rcall	.+0      	; 0x4afe <vTaskSuspend+0xa>
    4afe:	cd b7       	in	r28, 0x3d	; 61
    4b00:	de b7       	in	r29, 0x3e	; 62
    4b02:	9c 83       	std	Y+4, r25	; 0x04
    4b04:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    4b06:	0f b6       	in	r0, 0x3f	; 63
    4b08:	f8 94       	cli
    4b0a:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    4b0c:	8b 81       	ldd	r24, Y+3	; 0x03
    4b0e:	9c 81       	ldd	r25, Y+4	; 0x04
    4b10:	00 97       	sbiw	r24, 0x00	; 0
    4b12:	39 f4       	brne	.+14     	; 0x4b22 <vTaskSuspend+0x2e>
    4b14:	80 91 82 07 	lds	r24, 0x0782
    4b18:	90 91 83 07 	lds	r25, 0x0783
    4b1c:	9e 83       	std	Y+6, r25	; 0x06
    4b1e:	8d 83       	std	Y+5, r24	; 0x05
    4b20:	04 c0       	rjmp	.+8      	; 0x4b2a <vTaskSuspend+0x36>
    4b22:	8b 81       	ldd	r24, Y+3	; 0x03
    4b24:	9c 81       	ldd	r25, Y+4	; 0x04
    4b26:	9e 83       	std	Y+6, r25	; 0x06
    4b28:	8d 83       	std	Y+5, r24	; 0x05
    4b2a:	8d 81       	ldd	r24, Y+5	; 0x05
    4b2c:	9e 81       	ldd	r25, Y+6	; 0x06
    4b2e:	9a 83       	std	Y+2, r25	; 0x02
    4b30:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    4b32:	89 81       	ldd	r24, Y+1	; 0x01
    4b34:	9a 81       	ldd	r25, Y+2	; 0x02
    4b36:	02 96       	adiw	r24, 0x02	; 2
    4b38:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    4b3c:	e9 81       	ldd	r30, Y+1	; 0x01
    4b3e:	fa 81       	ldd	r31, Y+2	; 0x02
    4b40:	84 89       	ldd	r24, Z+20	; 0x14
    4b42:	95 89       	ldd	r25, Z+21	; 0x15
    4b44:	00 97       	sbiw	r24, 0x00	; 0
    4b46:	29 f0       	breq	.+10     	; 0x4b52 <vTaskSuspend+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4b48:	89 81       	ldd	r24, Y+1	; 0x01
    4b4a:	9a 81       	ldd	r25, Y+2	; 0x02
    4b4c:	0c 96       	adiw	r24, 0x0c	; 12
    4b4e:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    4b52:	89 81       	ldd	r24, Y+1	; 0x01
    4b54:	9a 81       	ldd	r25, Y+2	; 0x02
    4b56:	9c 01       	movw	r18, r24
    4b58:	2e 5f       	subi	r18, 0xFE	; 254
    4b5a:	3f 4f       	sbci	r19, 0xFF	; 255
    4b5c:	85 e1       	ldi	r24, 0x15	; 21
    4b5e:	98 e0       	ldi	r25, 0x08	; 8
    4b60:	b9 01       	movw	r22, r18
    4b62:	0e 94 b8 09 	call	0x1370	; 0x1370 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    4b66:	e9 81       	ldd	r30, Y+1	; 0x01
    4b68:	fa 81       	ldd	r31, Y+2	; 0x02
    4b6a:	87 a1       	ldd	r24, Z+39	; 0x27
    4b6c:	81 30       	cpi	r24, 0x01	; 1
    4b6e:	19 f4       	brne	.+6      	; 0x4b76 <vTaskSuspend+0x82>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4b70:	e9 81       	ldd	r30, Y+1	; 0x01
    4b72:	fa 81       	ldd	r31, Y+2	; 0x02
    4b74:	17 a2       	std	Z+39, r1	; 0x27
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
    4b76:	0f 90       	pop	r0
    4b78:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    4b7a:	80 91 89 07 	lds	r24, 0x0789
    4b7e:	88 23       	and	r24, r24
    4b80:	39 f0       	breq	.+14     	; 0x4b90 <vTaskSuspend+0x9c>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    4b82:	0f b6       	in	r0, 0x3f	; 63
    4b84:	f8 94       	cli
    4b86:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    4b88:	0e 94 cb 2b 	call	0x5796	; 0x5796 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    4b8c:	0f 90       	pop	r0
    4b8e:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    4b90:	20 91 82 07 	lds	r18, 0x0782
    4b94:	30 91 83 07 	lds	r19, 0x0783
    4b98:	89 81       	ldd	r24, Y+1	; 0x01
    4b9a:	9a 81       	ldd	r25, Y+2	; 0x02
    4b9c:	82 17       	cp	r24, r18
    4b9e:	93 07       	cpc	r25, r19
    4ba0:	a1 f4       	brne	.+40     	; 0x4bca <vTaskSuspend+0xd6>
		{
			if( xSchedulerRunning != pdFALSE )
    4ba2:	80 91 89 07 	lds	r24, 0x0789
    4ba6:	88 23       	and	r24, r24
    4ba8:	19 f0       	breq	.+6      	; 0x4bb0 <vTaskSuspend+0xbc>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    4baa:	0e 94 e2 11 	call	0x23c4	; 0x23c4 <vPortYield>
    4bae:	0d c0       	rjmp	.+26     	; 0x4bca <vTaskSuspend+0xd6>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    4bb0:	90 91 15 08 	lds	r25, 0x0815
    4bb4:	80 91 85 07 	lds	r24, 0x0785
    4bb8:	98 17       	cp	r25, r24
    4bba:	29 f4       	brne	.+10     	; 0x4bc6 <vTaskSuspend+0xd2>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    4bbc:	10 92 83 07 	sts	0x0783, r1
    4bc0:	10 92 82 07 	sts	0x0782, r1
    4bc4:	02 c0       	rjmp	.+4      	; 0x4bca <vTaskSuspend+0xd6>
				}
				else
				{
					vTaskSwitchContext();
    4bc6:	0e 94 06 29 	call	0x520c	; 0x520c <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    4bca:	26 96       	adiw	r28, 0x06	; 6
    4bcc:	0f b6       	in	r0, 0x3f	; 63
    4bce:	f8 94       	cli
    4bd0:	de bf       	out	0x3e, r29	; 62
    4bd2:	0f be       	out	0x3f, r0	; 63
    4bd4:	cd bf       	out	0x3d, r28	; 61
    4bd6:	cf 91       	pop	r28
    4bd8:	df 91       	pop	r29
    4bda:	08 95       	ret

00004bdc <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    4bdc:	df 93       	push	r29
    4bde:	cf 93       	push	r28
    4be0:	00 d0       	rcall	.+0      	; 0x4be2 <prvTaskIsTaskSuspended+0x6>
    4be2:	00 d0       	rcall	.+0      	; 0x4be4 <prvTaskIsTaskSuspended+0x8>
    4be4:	0f 92       	push	r0
    4be6:	cd b7       	in	r28, 0x3d	; 61
    4be8:	de b7       	in	r29, 0x3e	; 62
    4bea:	9d 83       	std	Y+5, r25	; 0x05
    4bec:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    4bee:	1b 82       	std	Y+3, r1	; 0x03
	const TCB_t * const pxTCB = xTask;
    4bf0:	8c 81       	ldd	r24, Y+4	; 0x04
    4bf2:	9d 81       	ldd	r25, Y+5	; 0x05
    4bf4:	9a 83       	std	Y+2, r25	; 0x02
    4bf6:	89 83       	std	Y+1, r24	; 0x01

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    4bf8:	e9 81       	ldd	r30, Y+1	; 0x01
    4bfa:	fa 81       	ldd	r31, Y+2	; 0x02
    4bfc:	82 85       	ldd	r24, Z+10	; 0x0a
    4bfe:	93 85       	ldd	r25, Z+11	; 0x0b
    4c00:	28 e0       	ldi	r18, 0x08	; 8
    4c02:	85 31       	cpi	r24, 0x15	; 21
    4c04:	92 07       	cpc	r25, r18
    4c06:	81 f4       	brne	.+32     	; 0x4c28 <prvTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    4c08:	e9 81       	ldd	r30, Y+1	; 0x01
    4c0a:	fa 81       	ldd	r31, Y+2	; 0x02
    4c0c:	84 89       	ldd	r24, Z+20	; 0x14
    4c0e:	95 89       	ldd	r25, Z+21	; 0x15
    4c10:	28 e0       	ldi	r18, 0x08	; 8
    4c12:	83 30       	cpi	r24, 0x03	; 3
    4c14:	92 07       	cpc	r25, r18
    4c16:	41 f0       	breq	.+16     	; 0x4c28 <prvTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
    4c18:	e9 81       	ldd	r30, Y+1	; 0x01
    4c1a:	fa 81       	ldd	r31, Y+2	; 0x02
    4c1c:	84 89       	ldd	r24, Z+20	; 0x14
    4c1e:	95 89       	ldd	r25, Z+21	; 0x15
    4c20:	00 97       	sbiw	r24, 0x00	; 0
    4c22:	11 f4       	brne	.+4      	; 0x4c28 <prvTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    4c24:	81 e0       	ldi	r24, 0x01	; 1
    4c26:	8b 83       	std	Y+3, r24	; 0x03
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    4c28:	8b 81       	ldd	r24, Y+3	; 0x03
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    4c2a:	0f 90       	pop	r0
    4c2c:	0f 90       	pop	r0
    4c2e:	0f 90       	pop	r0
    4c30:	0f 90       	pop	r0
    4c32:	0f 90       	pop	r0
    4c34:	cf 91       	pop	r28
    4c36:	df 91       	pop	r29
    4c38:	08 95       	ret

00004c3a <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    4c3a:	df 93       	push	r29
    4c3c:	cf 93       	push	r28
    4c3e:	00 d0       	rcall	.+0      	; 0x4c40 <vTaskResume+0x6>
    4c40:	00 d0       	rcall	.+0      	; 0x4c42 <vTaskResume+0x8>
    4c42:	cd b7       	in	r28, 0x3d	; 61
    4c44:	de b7       	in	r29, 0x3e	; 62
    4c46:	9c 83       	std	Y+4, r25	; 0x04
    4c48:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = xTaskToResume;
    4c4a:	8b 81       	ldd	r24, Y+3	; 0x03
    4c4c:	9c 81       	ldd	r25, Y+4	; 0x04
    4c4e:	9a 83       	std	Y+2, r25	; 0x02
    4c50:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
    4c52:	20 91 82 07 	lds	r18, 0x0782
    4c56:	30 91 83 07 	lds	r19, 0x0783
    4c5a:	89 81       	ldd	r24, Y+1	; 0x01
    4c5c:	9a 81       	ldd	r25, Y+2	; 0x02
    4c5e:	82 17       	cp	r24, r18
    4c60:	93 07       	cpc	r25, r19
    4c62:	09 f4       	brne	.+2      	; 0x4c66 <vTaskResume+0x2c>
    4c64:	47 c0       	rjmp	.+142    	; 0x4cf4 <vTaskResume+0xba>
    4c66:	89 81       	ldd	r24, Y+1	; 0x01
    4c68:	9a 81       	ldd	r25, Y+2	; 0x02
    4c6a:	00 97       	sbiw	r24, 0x00	; 0
    4c6c:	09 f4       	brne	.+2      	; 0x4c70 <vTaskResume+0x36>
    4c6e:	42 c0       	rjmp	.+132    	; 0x4cf4 <vTaskResume+0xba>
		{
			taskENTER_CRITICAL();
    4c70:	0f b6       	in	r0, 0x3f	; 63
    4c72:	f8 94       	cli
    4c74:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    4c76:	89 81       	ldd	r24, Y+1	; 0x01
    4c78:	9a 81       	ldd	r25, Y+2	; 0x02
    4c7a:	0e 94 ee 25 	call	0x4bdc	; 0x4bdc <prvTaskIsTaskSuspended>
    4c7e:	88 23       	and	r24, r24
    4c80:	b9 f1       	breq	.+110    	; 0x4cf0 <vTaskResume+0xb6>
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    4c82:	89 81       	ldd	r24, Y+1	; 0x01
    4c84:	9a 81       	ldd	r25, Y+2	; 0x02
    4c86:	02 96       	adiw	r24, 0x02	; 2
    4c88:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4c8c:	e9 81       	ldd	r30, Y+1	; 0x01
    4c8e:	fa 81       	ldd	r31, Y+2	; 0x02
    4c90:	96 89       	ldd	r25, Z+22	; 0x16
    4c92:	80 91 88 07 	lds	r24, 0x0788
    4c96:	89 17       	cp	r24, r25
    4c98:	28 f4       	brcc	.+10     	; 0x4ca4 <vTaskResume+0x6a>
    4c9a:	e9 81       	ldd	r30, Y+1	; 0x01
    4c9c:	fa 81       	ldd	r31, Y+2	; 0x02
    4c9e:	86 89       	ldd	r24, Z+22	; 0x16
    4ca0:	80 93 88 07 	sts	0x0788, r24
    4ca4:	e9 81       	ldd	r30, Y+1	; 0x01
    4ca6:	fa 81       	ldd	r31, Y+2	; 0x02
    4ca8:	86 89       	ldd	r24, Z+22	; 0x16
    4caa:	28 2f       	mov	r18, r24
    4cac:	30 e0       	ldi	r19, 0x00	; 0
    4cae:	c9 01       	movw	r24, r18
    4cb0:	88 0f       	add	r24, r24
    4cb2:	99 1f       	adc	r25, r25
    4cb4:	88 0f       	add	r24, r24
    4cb6:	99 1f       	adc	r25, r25
    4cb8:	88 0f       	add	r24, r24
    4cba:	99 1f       	adc	r25, r25
    4cbc:	82 0f       	add	r24, r18
    4cbe:	93 1f       	adc	r25, r19
    4cc0:	ac 01       	movw	r20, r24
    4cc2:	4d 56       	subi	r20, 0x6D	; 109
    4cc4:	58 4f       	sbci	r21, 0xF8	; 248
    4cc6:	89 81       	ldd	r24, Y+1	; 0x01
    4cc8:	9a 81       	ldd	r25, Y+2	; 0x02
    4cca:	9c 01       	movw	r18, r24
    4ccc:	2e 5f       	subi	r18, 0xFE	; 254
    4cce:	3f 4f       	sbci	r19, 0xFF	; 255
    4cd0:	ca 01       	movw	r24, r20
    4cd2:	b9 01       	movw	r22, r18
    4cd4:	0e 94 b8 09 	call	0x1370	; 0x1370 <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4cd8:	e9 81       	ldd	r30, Y+1	; 0x01
    4cda:	fa 81       	ldd	r31, Y+2	; 0x02
    4cdc:	96 89       	ldd	r25, Z+22	; 0x16
    4cde:	e0 91 82 07 	lds	r30, 0x0782
    4ce2:	f0 91 83 07 	lds	r31, 0x0783
    4ce6:	86 89       	ldd	r24, Z+22	; 0x16
    4ce8:	98 17       	cp	r25, r24
    4cea:	10 f0       	brcs	.+4      	; 0x4cf0 <vTaskResume+0xb6>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    4cec:	0e 94 e2 11 	call	0x23c4	; 0x23c4 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    4cf0:	0f 90       	pop	r0
    4cf2:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    4cf4:	0f 90       	pop	r0
    4cf6:	0f 90       	pop	r0
    4cf8:	0f 90       	pop	r0
    4cfa:	0f 90       	pop	r0
    4cfc:	cf 91       	pop	r28
    4cfe:	df 91       	pop	r29
    4d00:	08 95       	ret

00004d02 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    4d02:	df 93       	push	r29
    4d04:	cf 93       	push	r28
    4d06:	00 d0       	rcall	.+0      	; 0x4d08 <xTaskResumeFromISR+0x6>
    4d08:	00 d0       	rcall	.+0      	; 0x4d0a <xTaskResumeFromISR+0x8>
    4d0a:	00 d0       	rcall	.+0      	; 0x4d0c <xTaskResumeFromISR+0xa>
    4d0c:	cd b7       	in	r28, 0x3d	; 61
    4d0e:	de b7       	in	r29, 0x3e	; 62
    4d10:	9e 83       	std	Y+6, r25	; 0x06
    4d12:	8d 83       	std	Y+5, r24	; 0x05
	BaseType_t xYieldRequired = pdFALSE;
    4d14:	1c 82       	std	Y+4, r1	; 0x04
	TCB_t * const pxTCB = xTaskToResume;
    4d16:	8d 81       	ldd	r24, Y+5	; 0x05
    4d18:	9e 81       	ldd	r25, Y+6	; 0x06
    4d1a:	9b 83       	std	Y+3, r25	; 0x03
    4d1c:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4d1e:	19 82       	std	Y+1, r1	; 0x01
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    4d20:	8a 81       	ldd	r24, Y+2	; 0x02
    4d22:	9b 81       	ldd	r25, Y+3	; 0x03
    4d24:	0e 94 ee 25 	call	0x4bdc	; 0x4bdc <prvTaskIsTaskSuspended>
    4d28:	88 23       	and	r24, r24
    4d2a:	09 f4       	brne	.+2      	; 0x4d2e <xTaskResumeFromISR+0x2c>
    4d2c:	46 c0       	rjmp	.+140    	; 0x4dba <xTaskResumeFromISR+0xb8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4d2e:	80 91 92 07 	lds	r24, 0x0792
    4d32:	88 23       	and	r24, r24
    4d34:	c1 f5       	brne	.+112    	; 0x4da6 <xTaskResumeFromISR+0xa4>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4d36:	ea 81       	ldd	r30, Y+2	; 0x02
    4d38:	fb 81       	ldd	r31, Y+3	; 0x03
    4d3a:	96 89       	ldd	r25, Z+22	; 0x16
    4d3c:	e0 91 82 07 	lds	r30, 0x0782
    4d40:	f0 91 83 07 	lds	r31, 0x0783
    4d44:	86 89       	ldd	r24, Z+22	; 0x16
    4d46:	98 17       	cp	r25, r24
    4d48:	10 f0       	brcs	.+4      	; 0x4d4e <xTaskResumeFromISR+0x4c>
					{
						xYieldRequired = pdTRUE;
    4d4a:	81 e0       	ldi	r24, 0x01	; 1
    4d4c:	8c 83       	std	Y+4, r24	; 0x04
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4d4e:	8a 81       	ldd	r24, Y+2	; 0x02
    4d50:	9b 81       	ldd	r25, Y+3	; 0x03
    4d52:	02 96       	adiw	r24, 0x02	; 2
    4d54:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4d58:	ea 81       	ldd	r30, Y+2	; 0x02
    4d5a:	fb 81       	ldd	r31, Y+3	; 0x03
    4d5c:	96 89       	ldd	r25, Z+22	; 0x16
    4d5e:	80 91 88 07 	lds	r24, 0x0788
    4d62:	89 17       	cp	r24, r25
    4d64:	28 f4       	brcc	.+10     	; 0x4d70 <xTaskResumeFromISR+0x6e>
    4d66:	ea 81       	ldd	r30, Y+2	; 0x02
    4d68:	fb 81       	ldd	r31, Y+3	; 0x03
    4d6a:	86 89       	ldd	r24, Z+22	; 0x16
    4d6c:	80 93 88 07 	sts	0x0788, r24
    4d70:	ea 81       	ldd	r30, Y+2	; 0x02
    4d72:	fb 81       	ldd	r31, Y+3	; 0x03
    4d74:	86 89       	ldd	r24, Z+22	; 0x16
    4d76:	28 2f       	mov	r18, r24
    4d78:	30 e0       	ldi	r19, 0x00	; 0
    4d7a:	c9 01       	movw	r24, r18
    4d7c:	88 0f       	add	r24, r24
    4d7e:	99 1f       	adc	r25, r25
    4d80:	88 0f       	add	r24, r24
    4d82:	99 1f       	adc	r25, r25
    4d84:	88 0f       	add	r24, r24
    4d86:	99 1f       	adc	r25, r25
    4d88:	82 0f       	add	r24, r18
    4d8a:	93 1f       	adc	r25, r19
    4d8c:	ac 01       	movw	r20, r24
    4d8e:	4d 56       	subi	r20, 0x6D	; 109
    4d90:	58 4f       	sbci	r21, 0xF8	; 248
    4d92:	8a 81       	ldd	r24, Y+2	; 0x02
    4d94:	9b 81       	ldd	r25, Y+3	; 0x03
    4d96:	9c 01       	movw	r18, r24
    4d98:	2e 5f       	subi	r18, 0xFE	; 254
    4d9a:	3f 4f       	sbci	r19, 0xFF	; 255
    4d9c:	ca 01       	movw	r24, r20
    4d9e:	b9 01       	movw	r22, r18
    4da0:	0e 94 b8 09 	call	0x1370	; 0x1370 <vListInsertEnd>
    4da4:	0a c0       	rjmp	.+20     	; 0x4dba <xTaskResumeFromISR+0xb8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    4da6:	8a 81       	ldd	r24, Y+2	; 0x02
    4da8:	9b 81       	ldd	r25, Y+3	; 0x03
    4daa:	9c 01       	movw	r18, r24
    4dac:	24 5f       	subi	r18, 0xF4	; 244
    4dae:	3f 4f       	sbci	r19, 0xFF	; 255
    4db0:	83 e0       	ldi	r24, 0x03	; 3
    4db2:	98 e0       	ldi	r25, 0x08	; 8
    4db4:	b9 01       	movw	r22, r18
    4db6:	0e 94 b8 09 	call	0x1370	; 0x1370 <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    4dba:	8c 81       	ldd	r24, Y+4	; 0x04
	}
    4dbc:	26 96       	adiw	r28, 0x06	; 6
    4dbe:	0f b6       	in	r0, 0x3f	; 63
    4dc0:	f8 94       	cli
    4dc2:	de bf       	out	0x3e, r29	; 62
    4dc4:	0f be       	out	0x3f, r0	; 63
    4dc6:	cd bf       	out	0x3d, r28	; 61
    4dc8:	cf 91       	pop	r28
    4dca:	df 91       	pop	r29
    4dcc:	08 95       	ret

00004dce <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    4dce:	ef 92       	push	r14
    4dd0:	ff 92       	push	r15
    4dd2:	0f 93       	push	r16
    4dd4:	df 93       	push	r29
    4dd6:	cf 93       	push	r28
    4dd8:	0f 92       	push	r0
    4dda:	cd b7       	in	r28, 0x3d	; 61
    4ddc:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    4dde:	8b e3       	ldi	r24, 0x3B	; 59
    4de0:	9b e2       	ldi	r25, 0x2B	; 43
    4de2:	2b e8       	ldi	r18, 0x8B	; 139
    4de4:	30 e0       	ldi	r19, 0x00	; 0
    4de6:	e0 e9       	ldi	r30, 0x90	; 144
    4de8:	f7 e0       	ldi	r31, 0x07	; 7
    4dea:	b9 01       	movw	r22, r18
    4dec:	40 e5       	ldi	r20, 0x50	; 80
    4dee:	50 e0       	ldi	r21, 0x00	; 0
    4df0:	20 e0       	ldi	r18, 0x00	; 0
    4df2:	30 e0       	ldi	r19, 0x00	; 0
    4df4:	00 e0       	ldi	r16, 0x00	; 0
    4df6:	7f 01       	movw	r14, r30
    4df8:	0e 94 c1 22 	call	0x4582	; 0x4582 <xTaskCreate>
    4dfc:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    4dfe:	89 81       	ldd	r24, Y+1	; 0x01
    4e00:	81 30       	cpi	r24, 0x01	; 1
    4e02:	81 f4       	brne	.+32     	; 0x4e24 <vTaskStartScheduler+0x56>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    4e04:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    4e06:	8f ef       	ldi	r24, 0xFF	; 255
    4e08:	9f ef       	ldi	r25, 0xFF	; 255
    4e0a:	90 93 8f 07 	sts	0x078F, r25
    4e0e:	80 93 8e 07 	sts	0x078E, r24
		xSchedulerRunning = pdTRUE;
    4e12:	81 e0       	ldi	r24, 0x01	; 1
    4e14:	80 93 89 07 	sts	0x0789, r24
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    4e18:	10 92 87 07 	sts	0x0787, r1
    4e1c:	10 92 86 07 	sts	0x0786, r1

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    4e20:	0e 94 a6 11 	call	0x234c	; 0x234c <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    4e24:	0f 90       	pop	r0
    4e26:	cf 91       	pop	r28
    4e28:	df 91       	pop	r29
    4e2a:	0f 91       	pop	r16
    4e2c:	ff 90       	pop	r15
    4e2e:	ef 90       	pop	r14
    4e30:	08 95       	ret

00004e32 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    4e32:	df 93       	push	r29
    4e34:	cf 93       	push	r28
    4e36:	cd b7       	in	r28, 0x3d	; 61
    4e38:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    4e3a:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    4e3c:	10 92 89 07 	sts	0x0789, r1
	vPortEndScheduler();
    4e40:	0e 94 db 11 	call	0x23b6	; 0x23b6 <vPortEndScheduler>
}
    4e44:	cf 91       	pop	r28
    4e46:	df 91       	pop	r29
    4e48:	08 95       	ret

00004e4a <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    4e4a:	df 93       	push	r29
    4e4c:	cf 93       	push	r28
    4e4e:	cd b7       	in	r28, 0x3d	; 61
    4e50:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    4e52:	80 91 92 07 	lds	r24, 0x0792
    4e56:	8f 5f       	subi	r24, 0xFF	; 255
    4e58:	80 93 92 07 	sts	0x0792, r24
}
    4e5c:	cf 91       	pop	r28
    4e5e:	df 91       	pop	r29
    4e60:	08 95       	ret

00004e62 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    4e62:	df 93       	push	r29
    4e64:	cf 93       	push	r28
    4e66:	00 d0       	rcall	.+0      	; 0x4e68 <xTaskResumeAll+0x6>
    4e68:	00 d0       	rcall	.+0      	; 0x4e6a <xTaskResumeAll+0x8>
    4e6a:	cd b7       	in	r28, 0x3d	; 61
    4e6c:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    4e6e:	1c 82       	std	Y+4, r1	; 0x04
    4e70:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xAlreadyYielded = pdFALSE;
    4e72:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    4e74:	0f b6       	in	r0, 0x3f	; 63
    4e76:	f8 94       	cli
    4e78:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    4e7a:	80 91 92 07 	lds	r24, 0x0792
    4e7e:	81 50       	subi	r24, 0x01	; 1
    4e80:	80 93 92 07 	sts	0x0792, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4e84:	80 91 92 07 	lds	r24, 0x0792
    4e88:	88 23       	and	r24, r24
    4e8a:	09 f0       	breq	.+2      	; 0x4e8e <xTaskResumeAll+0x2c>
    4e8c:	73 c0       	rjmp	.+230    	; 0x4f74 <xTaskResumeAll+0x112>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    4e8e:	80 91 85 07 	lds	r24, 0x0785
    4e92:	88 23       	and	r24, r24
    4e94:	09 f4       	brne	.+2      	; 0x4e98 <xTaskResumeAll+0x36>
    4e96:	6e c0       	rjmp	.+220    	; 0x4f74 <xTaskResumeAll+0x112>
    4e98:	45 c0       	rjmp	.+138    	; 0x4f24 <xTaskResumeAll+0xc2>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4e9a:	e0 91 08 08 	lds	r30, 0x0808
    4e9e:	f0 91 09 08 	lds	r31, 0x0809
    4ea2:	86 81       	ldd	r24, Z+6	; 0x06
    4ea4:	97 81       	ldd	r25, Z+7	; 0x07
    4ea6:	9c 83       	std	Y+4, r25	; 0x04
    4ea8:	8b 83       	std	Y+3, r24	; 0x03
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4eaa:	8b 81       	ldd	r24, Y+3	; 0x03
    4eac:	9c 81       	ldd	r25, Y+4	; 0x04
    4eae:	0c 96       	adiw	r24, 0x0c	; 12
    4eb0:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4eb4:	8b 81       	ldd	r24, Y+3	; 0x03
    4eb6:	9c 81       	ldd	r25, Y+4	; 0x04
    4eb8:	02 96       	adiw	r24, 0x02	; 2
    4eba:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4ebe:	eb 81       	ldd	r30, Y+3	; 0x03
    4ec0:	fc 81       	ldd	r31, Y+4	; 0x04
    4ec2:	96 89       	ldd	r25, Z+22	; 0x16
    4ec4:	80 91 88 07 	lds	r24, 0x0788
    4ec8:	89 17       	cp	r24, r25
    4eca:	28 f4       	brcc	.+10     	; 0x4ed6 <xTaskResumeAll+0x74>
    4ecc:	eb 81       	ldd	r30, Y+3	; 0x03
    4ece:	fc 81       	ldd	r31, Y+4	; 0x04
    4ed0:	86 89       	ldd	r24, Z+22	; 0x16
    4ed2:	80 93 88 07 	sts	0x0788, r24
    4ed6:	eb 81       	ldd	r30, Y+3	; 0x03
    4ed8:	fc 81       	ldd	r31, Y+4	; 0x04
    4eda:	86 89       	ldd	r24, Z+22	; 0x16
    4edc:	28 2f       	mov	r18, r24
    4ede:	30 e0       	ldi	r19, 0x00	; 0
    4ee0:	c9 01       	movw	r24, r18
    4ee2:	88 0f       	add	r24, r24
    4ee4:	99 1f       	adc	r25, r25
    4ee6:	88 0f       	add	r24, r24
    4ee8:	99 1f       	adc	r25, r25
    4eea:	88 0f       	add	r24, r24
    4eec:	99 1f       	adc	r25, r25
    4eee:	82 0f       	add	r24, r18
    4ef0:	93 1f       	adc	r25, r19
    4ef2:	ac 01       	movw	r20, r24
    4ef4:	4d 56       	subi	r20, 0x6D	; 109
    4ef6:	58 4f       	sbci	r21, 0xF8	; 248
    4ef8:	8b 81       	ldd	r24, Y+3	; 0x03
    4efa:	9c 81       	ldd	r25, Y+4	; 0x04
    4efc:	9c 01       	movw	r18, r24
    4efe:	2e 5f       	subi	r18, 0xFE	; 254
    4f00:	3f 4f       	sbci	r19, 0xFF	; 255
    4f02:	ca 01       	movw	r24, r20
    4f04:	b9 01       	movw	r22, r18
    4f06:	0e 94 b8 09 	call	0x1370	; 0x1370 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4f0a:	eb 81       	ldd	r30, Y+3	; 0x03
    4f0c:	fc 81       	ldd	r31, Y+4	; 0x04
    4f0e:	96 89       	ldd	r25, Z+22	; 0x16
    4f10:	e0 91 82 07 	lds	r30, 0x0782
    4f14:	f0 91 83 07 	lds	r31, 0x0783
    4f18:	86 89       	ldd	r24, Z+22	; 0x16
    4f1a:	98 17       	cp	r25, r24
    4f1c:	18 f0       	brcs	.+6      	; 0x4f24 <xTaskResumeAll+0xc2>
					{
						xYieldPending = pdTRUE;
    4f1e:	81 e0       	ldi	r24, 0x01	; 1
    4f20:	80 93 8b 07 	sts	0x078B, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    4f24:	80 91 03 08 	lds	r24, 0x0803
    4f28:	88 23       	and	r24, r24
    4f2a:	09 f0       	breq	.+2      	; 0x4f2e <xTaskResumeAll+0xcc>
    4f2c:	b6 cf       	rjmp	.-148    	; 0x4e9a <xTaskResumeAll+0x38>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    4f2e:	8b 81       	ldd	r24, Y+3	; 0x03
    4f30:	9c 81       	ldd	r25, Y+4	; 0x04
    4f32:	00 97       	sbiw	r24, 0x00	; 0
    4f34:	11 f0       	breq	.+4      	; 0x4f3a <xTaskResumeAll+0xd8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    4f36:	0e 94 cb 2b 	call	0x5796	; 0x5796 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    4f3a:	80 91 8a 07 	lds	r24, 0x078A
    4f3e:	89 83       	std	Y+1, r24	; 0x01

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    4f40:	89 81       	ldd	r24, Y+1	; 0x01
    4f42:	88 23       	and	r24, r24
    4f44:	79 f0       	breq	.+30     	; 0x4f64 <xTaskResumeAll+0x102>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    4f46:	0e 94 21 28 	call	0x5042	; 0x5042 <xTaskIncrementTick>
    4f4a:	88 23       	and	r24, r24
    4f4c:	19 f0       	breq	.+6      	; 0x4f54 <xTaskResumeAll+0xf2>
							{
								xYieldPending = pdTRUE;
    4f4e:	81 e0       	ldi	r24, 0x01	; 1
    4f50:	80 93 8b 07 	sts	0x078B, r24
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    4f54:	89 81       	ldd	r24, Y+1	; 0x01
    4f56:	81 50       	subi	r24, 0x01	; 1
    4f58:	89 83       	std	Y+1, r24	; 0x01
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    4f5a:	89 81       	ldd	r24, Y+1	; 0x01
    4f5c:	88 23       	and	r24, r24
    4f5e:	99 f7       	brne	.-26     	; 0x4f46 <xTaskResumeAll+0xe4>

						uxPendedTicks = 0;
    4f60:	10 92 8a 07 	sts	0x078A, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    4f64:	80 91 8b 07 	lds	r24, 0x078B
    4f68:	88 23       	and	r24, r24
    4f6a:	21 f0       	breq	.+8      	; 0x4f74 <xTaskResumeAll+0x112>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    4f6c:	81 e0       	ldi	r24, 0x01	; 1
    4f6e:	8a 83       	std	Y+2, r24	; 0x02
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    4f70:	0e 94 e2 11 	call	0x23c4	; 0x23c4 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    4f74:	0f 90       	pop	r0
    4f76:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    4f78:	8a 81       	ldd	r24, Y+2	; 0x02
}
    4f7a:	0f 90       	pop	r0
    4f7c:	0f 90       	pop	r0
    4f7e:	0f 90       	pop	r0
    4f80:	0f 90       	pop	r0
    4f82:	cf 91       	pop	r28
    4f84:	df 91       	pop	r29
    4f86:	08 95       	ret

00004f88 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    4f88:	df 93       	push	r29
    4f8a:	cf 93       	push	r28
    4f8c:	00 d0       	rcall	.+0      	; 0x4f8e <xTaskGetTickCount+0x6>
    4f8e:	cd b7       	in	r28, 0x3d	; 61
    4f90:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    4f92:	0f b6       	in	r0, 0x3f	; 63
    4f94:	f8 94       	cli
    4f96:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    4f98:	80 91 86 07 	lds	r24, 0x0786
    4f9c:	90 91 87 07 	lds	r25, 0x0787
    4fa0:	9a 83       	std	Y+2, r25	; 0x02
    4fa2:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    4fa4:	0f 90       	pop	r0
    4fa6:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    4fa8:	89 81       	ldd	r24, Y+1	; 0x01
    4faa:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4fac:	0f 90       	pop	r0
    4fae:	0f 90       	pop	r0
    4fb0:	cf 91       	pop	r28
    4fb2:	df 91       	pop	r29
    4fb4:	08 95       	ret

00004fb6 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    4fb6:	df 93       	push	r29
    4fb8:	cf 93       	push	r28
    4fba:	00 d0       	rcall	.+0      	; 0x4fbc <xTaskGetTickCountFromISR+0x6>
    4fbc:	0f 92       	push	r0
    4fbe:	cd b7       	in	r28, 0x3d	; 61
    4fc0:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    4fc2:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    4fc4:	80 91 86 07 	lds	r24, 0x0786
    4fc8:	90 91 87 07 	lds	r25, 0x0787
    4fcc:	9b 83       	std	Y+3, r25	; 0x03
    4fce:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4fd0:	8a 81       	ldd	r24, Y+2	; 0x02
    4fd2:	9b 81       	ldd	r25, Y+3	; 0x03
}
    4fd4:	0f 90       	pop	r0
    4fd6:	0f 90       	pop	r0
    4fd8:	0f 90       	pop	r0
    4fda:	cf 91       	pop	r28
    4fdc:	df 91       	pop	r29
    4fde:	08 95       	ret

00004fe0 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    4fe0:	df 93       	push	r29
    4fe2:	cf 93       	push	r28
    4fe4:	cd b7       	in	r28, 0x3d	; 61
    4fe6:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    4fe8:	80 91 85 07 	lds	r24, 0x0785
}
    4fec:	cf 91       	pop	r28
    4fee:	df 91       	pop	r29
    4ff0:	08 95       	ret

00004ff2 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    4ff2:	df 93       	push	r29
    4ff4:	cf 93       	push	r28
    4ff6:	00 d0       	rcall	.+0      	; 0x4ff8 <pcTaskGetName+0x6>
    4ff8:	00 d0       	rcall	.+0      	; 0x4ffa <pcTaskGetName+0x8>
    4ffa:	00 d0       	rcall	.+0      	; 0x4ffc <pcTaskGetName+0xa>
    4ffc:	cd b7       	in	r28, 0x3d	; 61
    4ffe:	de b7       	in	r29, 0x3e	; 62
    5000:	9c 83       	std	Y+4, r25	; 0x04
    5002:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    5004:	8b 81       	ldd	r24, Y+3	; 0x03
    5006:	9c 81       	ldd	r25, Y+4	; 0x04
    5008:	00 97       	sbiw	r24, 0x00	; 0
    500a:	39 f4       	brne	.+14     	; 0x501a <pcTaskGetName+0x28>
    500c:	80 91 82 07 	lds	r24, 0x0782
    5010:	90 91 83 07 	lds	r25, 0x0783
    5014:	9e 83       	std	Y+6, r25	; 0x06
    5016:	8d 83       	std	Y+5, r24	; 0x05
    5018:	04 c0       	rjmp	.+8      	; 0x5022 <pcTaskGetName+0x30>
    501a:	8b 81       	ldd	r24, Y+3	; 0x03
    501c:	9c 81       	ldd	r25, Y+4	; 0x04
    501e:	9e 83       	std	Y+6, r25	; 0x06
    5020:	8d 83       	std	Y+5, r24	; 0x05
    5022:	8d 81       	ldd	r24, Y+5	; 0x05
    5024:	9e 81       	ldd	r25, Y+6	; 0x06
    5026:	9a 83       	std	Y+2, r25	; 0x02
    5028:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    502a:	89 81       	ldd	r24, Y+1	; 0x01
    502c:	9a 81       	ldd	r25, Y+2	; 0x02
    502e:	49 96       	adiw	r24, 0x19	; 25
}
    5030:	26 96       	adiw	r28, 0x06	; 6
    5032:	0f b6       	in	r0, 0x3f	; 63
    5034:	f8 94       	cli
    5036:	de bf       	out	0x3e, r29	; 62
    5038:	0f be       	out	0x3f, r0	; 63
    503a:	cd bf       	out	0x3d, r28	; 61
    503c:	cf 91       	pop	r28
    503e:	df 91       	pop	r29
    5040:	08 95       	ret

00005042 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    5042:	df 93       	push	r29
    5044:	cf 93       	push	r28
    5046:	cd b7       	in	r28, 0x3d	; 61
    5048:	de b7       	in	r29, 0x3e	; 62
    504a:	29 97       	sbiw	r28, 0x09	; 9
    504c:	0f b6       	in	r0, 0x3f	; 63
    504e:	f8 94       	cli
    5050:	de bf       	out	0x3e, r29	; 62
    5052:	0f be       	out	0x3f, r0	; 63
    5054:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    5056:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5058:	80 91 92 07 	lds	r24, 0x0792
    505c:	88 23       	and	r24, r24
    505e:	09 f0       	breq	.+2      	; 0x5062 <xTaskIncrementTick+0x20>
    5060:	c0 c0       	rjmp	.+384    	; 0x51e2 <xTaskIncrementTick+0x1a0>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    5062:	80 91 86 07 	lds	r24, 0x0786
    5066:	90 91 87 07 	lds	r25, 0x0787
    506a:	01 96       	adiw	r24, 0x01	; 1
    506c:	9c 83       	std	Y+4, r25	; 0x04
    506e:	8b 83       	std	Y+3, r24	; 0x03

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    5070:	8b 81       	ldd	r24, Y+3	; 0x03
    5072:	9c 81       	ldd	r25, Y+4	; 0x04
    5074:	90 93 87 07 	sts	0x0787, r25
    5078:	80 93 86 07 	sts	0x0786, r24

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    507c:	8b 81       	ldd	r24, Y+3	; 0x03
    507e:	9c 81       	ldd	r25, Y+4	; 0x04
    5080:	00 97       	sbiw	r24, 0x00	; 0
    5082:	d9 f4       	brne	.+54     	; 0x50ba <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    5084:	80 91 ff 07 	lds	r24, 0x07FF
    5088:	90 91 00 08 	lds	r25, 0x0800
    508c:	9a 83       	std	Y+2, r25	; 0x02
    508e:	89 83       	std	Y+1, r24	; 0x01
    5090:	80 91 01 08 	lds	r24, 0x0801
    5094:	90 91 02 08 	lds	r25, 0x0802
    5098:	90 93 00 08 	sts	0x0800, r25
    509c:	80 93 ff 07 	sts	0x07FF, r24
    50a0:	89 81       	ldd	r24, Y+1	; 0x01
    50a2:	9a 81       	ldd	r25, Y+2	; 0x02
    50a4:	90 93 02 08 	sts	0x0802, r25
    50a8:	80 93 01 08 	sts	0x0801, r24
    50ac:	80 91 8c 07 	lds	r24, 0x078C
    50b0:	8f 5f       	subi	r24, 0xFF	; 255
    50b2:	80 93 8c 07 	sts	0x078C, r24
    50b6:	0e 94 cb 2b 	call	0x5796	; 0x5796 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    50ba:	20 91 8e 07 	lds	r18, 0x078E
    50be:	30 91 8f 07 	lds	r19, 0x078F
    50c2:	8b 81       	ldd	r24, Y+3	; 0x03
    50c4:	9c 81       	ldd	r25, Y+4	; 0x04
    50c6:	82 17       	cp	r24, r18
    50c8:	93 07       	cpc	r25, r19
    50ca:	08 f4       	brcc	.+2      	; 0x50ce <xTaskIncrementTick+0x8c>
    50cc:	71 c0       	rjmp	.+226    	; 0x51b0 <xTaskIncrementTick+0x16e>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    50ce:	e0 91 ff 07 	lds	r30, 0x07FF
    50d2:	f0 91 00 08 	lds	r31, 0x0800
    50d6:	80 81       	ld	r24, Z
    50d8:	88 23       	and	r24, r24
    50da:	39 f4       	brne	.+14     	; 0x50ea <xTaskIncrementTick+0xa8>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    50dc:	8f ef       	ldi	r24, 0xFF	; 255
    50de:	9f ef       	ldi	r25, 0xFF	; 255
    50e0:	90 93 8f 07 	sts	0x078F, r25
    50e4:	80 93 8e 07 	sts	0x078E, r24
    50e8:	63 c0       	rjmp	.+198    	; 0x51b0 <xTaskIncrementTick+0x16e>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    50ea:	e0 91 ff 07 	lds	r30, 0x07FF
    50ee:	f0 91 00 08 	lds	r31, 0x0800
    50f2:	05 80       	ldd	r0, Z+5	; 0x05
    50f4:	f6 81       	ldd	r31, Z+6	; 0x06
    50f6:	e0 2d       	mov	r30, r0
    50f8:	86 81       	ldd	r24, Z+6	; 0x06
    50fa:	97 81       	ldd	r25, Z+7	; 0x07
    50fc:	99 87       	std	Y+9, r25	; 0x09
    50fe:	88 87       	std	Y+8, r24	; 0x08
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    5100:	e8 85       	ldd	r30, Y+8	; 0x08
    5102:	f9 85       	ldd	r31, Y+9	; 0x09
    5104:	82 81       	ldd	r24, Z+2	; 0x02
    5106:	93 81       	ldd	r25, Z+3	; 0x03
    5108:	9f 83       	std	Y+7, r25	; 0x07
    510a:	8e 83       	std	Y+6, r24	; 0x06

					if( xConstTickCount < xItemValue )
    510c:	2b 81       	ldd	r18, Y+3	; 0x03
    510e:	3c 81       	ldd	r19, Y+4	; 0x04
    5110:	8e 81       	ldd	r24, Y+6	; 0x06
    5112:	9f 81       	ldd	r25, Y+7	; 0x07
    5114:	28 17       	cp	r18, r24
    5116:	39 07       	cpc	r19, r25
    5118:	38 f4       	brcc	.+14     	; 0x5128 <xTaskIncrementTick+0xe6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    511a:	8e 81       	ldd	r24, Y+6	; 0x06
    511c:	9f 81       	ldd	r25, Y+7	; 0x07
    511e:	90 93 8f 07 	sts	0x078F, r25
    5122:	80 93 8e 07 	sts	0x078E, r24
    5126:	44 c0       	rjmp	.+136    	; 0x51b0 <xTaskIncrementTick+0x16e>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5128:	88 85       	ldd	r24, Y+8	; 0x08
    512a:	99 85       	ldd	r25, Y+9	; 0x09
    512c:	02 96       	adiw	r24, 0x02	; 2
    512e:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    5132:	e8 85       	ldd	r30, Y+8	; 0x08
    5134:	f9 85       	ldd	r31, Y+9	; 0x09
    5136:	84 89       	ldd	r24, Z+20	; 0x14
    5138:	95 89       	ldd	r25, Z+21	; 0x15
    513a:	00 97       	sbiw	r24, 0x00	; 0
    513c:	29 f0       	breq	.+10     	; 0x5148 <xTaskIncrementTick+0x106>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    513e:	88 85       	ldd	r24, Y+8	; 0x08
    5140:	99 85       	ldd	r25, Y+9	; 0x09
    5142:	0c 96       	adiw	r24, 0x0c	; 12
    5144:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    5148:	e8 85       	ldd	r30, Y+8	; 0x08
    514a:	f9 85       	ldd	r31, Y+9	; 0x09
    514c:	96 89       	ldd	r25, Z+22	; 0x16
    514e:	80 91 88 07 	lds	r24, 0x0788
    5152:	89 17       	cp	r24, r25
    5154:	28 f4       	brcc	.+10     	; 0x5160 <xTaskIncrementTick+0x11e>
    5156:	e8 85       	ldd	r30, Y+8	; 0x08
    5158:	f9 85       	ldd	r31, Y+9	; 0x09
    515a:	86 89       	ldd	r24, Z+22	; 0x16
    515c:	80 93 88 07 	sts	0x0788, r24
    5160:	e8 85       	ldd	r30, Y+8	; 0x08
    5162:	f9 85       	ldd	r31, Y+9	; 0x09
    5164:	86 89       	ldd	r24, Z+22	; 0x16
    5166:	28 2f       	mov	r18, r24
    5168:	30 e0       	ldi	r19, 0x00	; 0
    516a:	c9 01       	movw	r24, r18
    516c:	88 0f       	add	r24, r24
    516e:	99 1f       	adc	r25, r25
    5170:	88 0f       	add	r24, r24
    5172:	99 1f       	adc	r25, r25
    5174:	88 0f       	add	r24, r24
    5176:	99 1f       	adc	r25, r25
    5178:	82 0f       	add	r24, r18
    517a:	93 1f       	adc	r25, r19
    517c:	ac 01       	movw	r20, r24
    517e:	4d 56       	subi	r20, 0x6D	; 109
    5180:	58 4f       	sbci	r21, 0xF8	; 248
    5182:	88 85       	ldd	r24, Y+8	; 0x08
    5184:	99 85       	ldd	r25, Y+9	; 0x09
    5186:	9c 01       	movw	r18, r24
    5188:	2e 5f       	subi	r18, 0xFE	; 254
    518a:	3f 4f       	sbci	r19, 0xFF	; 255
    518c:	ca 01       	movw	r24, r20
    518e:	b9 01       	movw	r22, r18
    5190:	0e 94 b8 09 	call	0x1370	; 0x1370 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    5194:	e8 85       	ldd	r30, Y+8	; 0x08
    5196:	f9 85       	ldd	r31, Y+9	; 0x09
    5198:	96 89       	ldd	r25, Z+22	; 0x16
    519a:	e0 91 82 07 	lds	r30, 0x0782
    519e:	f0 91 83 07 	lds	r31, 0x0783
    51a2:	86 89       	ldd	r24, Z+22	; 0x16
    51a4:	98 17       	cp	r25, r24
    51a6:	08 f4       	brcc	.+2      	; 0x51aa <xTaskIncrementTick+0x168>
    51a8:	92 cf       	rjmp	.-220    	; 0x50ce <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    51aa:	81 e0       	ldi	r24, 0x01	; 1
    51ac:	8d 83       	std	Y+5, r24	; 0x05
    51ae:	8f cf       	rjmp	.-226    	; 0x50ce <xTaskIncrementTick+0x8c>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    51b0:	e0 91 82 07 	lds	r30, 0x0782
    51b4:	f0 91 83 07 	lds	r31, 0x0783
    51b8:	86 89       	ldd	r24, Z+22	; 0x16
    51ba:	28 2f       	mov	r18, r24
    51bc:	30 e0       	ldi	r19, 0x00	; 0
    51be:	c9 01       	movw	r24, r18
    51c0:	88 0f       	add	r24, r24
    51c2:	99 1f       	adc	r25, r25
    51c4:	88 0f       	add	r24, r24
    51c6:	99 1f       	adc	r25, r25
    51c8:	88 0f       	add	r24, r24
    51ca:	99 1f       	adc	r25, r25
    51cc:	82 0f       	add	r24, r18
    51ce:	93 1f       	adc	r25, r19
    51d0:	fc 01       	movw	r30, r24
    51d2:	ed 56       	subi	r30, 0x6D	; 109
    51d4:	f8 4f       	sbci	r31, 0xF8	; 248
    51d6:	80 81       	ld	r24, Z
    51d8:	82 30       	cpi	r24, 0x02	; 2
    51da:	40 f0       	brcs	.+16     	; 0x51ec <xTaskIncrementTick+0x1aa>
			{
				xSwitchRequired = pdTRUE;
    51dc:	81 e0       	ldi	r24, 0x01	; 1
    51de:	8d 83       	std	Y+5, r24	; 0x05
    51e0:	05 c0       	rjmp	.+10     	; 0x51ec <xTaskIncrementTick+0x1aa>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    51e2:	80 91 8a 07 	lds	r24, 0x078A
    51e6:	8f 5f       	subi	r24, 0xFF	; 255
    51e8:	80 93 8a 07 	sts	0x078A, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    51ec:	80 91 8b 07 	lds	r24, 0x078B
    51f0:	88 23       	and	r24, r24
    51f2:	11 f0       	breq	.+4      	; 0x51f8 <xTaskIncrementTick+0x1b6>
		{
			xSwitchRequired = pdTRUE;
    51f4:	81 e0       	ldi	r24, 0x01	; 1
    51f6:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    51f8:	8d 81       	ldd	r24, Y+5	; 0x05
}
    51fa:	29 96       	adiw	r28, 0x09	; 9
    51fc:	0f b6       	in	r0, 0x3f	; 63
    51fe:	f8 94       	cli
    5200:	de bf       	out	0x3e, r29	; 62
    5202:	0f be       	out	0x3f, r0	; 63
    5204:	cd bf       	out	0x3d, r28	; 61
    5206:	cf 91       	pop	r28
    5208:	df 91       	pop	r29
    520a:	08 95       	ret

0000520c <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    520c:	df 93       	push	r29
    520e:	cf 93       	push	r28
    5210:	00 d0       	rcall	.+0      	; 0x5212 <vTaskSwitchContext+0x6>
    5212:	0f 92       	push	r0
    5214:	cd b7       	in	r28, 0x3d	; 61
    5216:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    5218:	80 91 92 07 	lds	r24, 0x0792
    521c:	88 23       	and	r24, r24
    521e:	21 f0       	breq	.+8      	; 0x5228 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    5220:	81 e0       	ldi	r24, 0x01	; 1
    5222:	80 93 8b 07 	sts	0x078B, r24
    5226:	59 c0       	rjmp	.+178    	; 0x52da <vTaskSwitchContext+0xce>
	}
	else
	{
		xYieldPending = pdFALSE;
    5228:	10 92 8b 07 	sts	0x078B, r1
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    522c:	80 91 88 07 	lds	r24, 0x0788
    5230:	8b 83       	std	Y+3, r24	; 0x03
    5232:	03 c0       	rjmp	.+6      	; 0x523a <vTaskSwitchContext+0x2e>
    5234:	8b 81       	ldd	r24, Y+3	; 0x03
    5236:	81 50       	subi	r24, 0x01	; 1
    5238:	8b 83       	std	Y+3, r24	; 0x03
    523a:	8b 81       	ldd	r24, Y+3	; 0x03
    523c:	28 2f       	mov	r18, r24
    523e:	30 e0       	ldi	r19, 0x00	; 0
    5240:	c9 01       	movw	r24, r18
    5242:	88 0f       	add	r24, r24
    5244:	99 1f       	adc	r25, r25
    5246:	88 0f       	add	r24, r24
    5248:	99 1f       	adc	r25, r25
    524a:	88 0f       	add	r24, r24
    524c:	99 1f       	adc	r25, r25
    524e:	82 0f       	add	r24, r18
    5250:	93 1f       	adc	r25, r19
    5252:	fc 01       	movw	r30, r24
    5254:	ed 56       	subi	r30, 0x6D	; 109
    5256:	f8 4f       	sbci	r31, 0xF8	; 248
    5258:	80 81       	ld	r24, Z
    525a:	88 23       	and	r24, r24
    525c:	59 f3       	breq	.-42     	; 0x5234 <vTaskSwitchContext+0x28>
    525e:	8b 81       	ldd	r24, Y+3	; 0x03
    5260:	28 2f       	mov	r18, r24
    5262:	30 e0       	ldi	r19, 0x00	; 0
    5264:	c9 01       	movw	r24, r18
    5266:	88 0f       	add	r24, r24
    5268:	99 1f       	adc	r25, r25
    526a:	88 0f       	add	r24, r24
    526c:	99 1f       	adc	r25, r25
    526e:	88 0f       	add	r24, r24
    5270:	99 1f       	adc	r25, r25
    5272:	82 0f       	add	r24, r18
    5274:	93 1f       	adc	r25, r19
    5276:	8d 56       	subi	r24, 0x6D	; 109
    5278:	98 4f       	sbci	r25, 0xF8	; 248
    527a:	9a 83       	std	Y+2, r25	; 0x02
    527c:	89 83       	std	Y+1, r24	; 0x01
    527e:	e9 81       	ldd	r30, Y+1	; 0x01
    5280:	fa 81       	ldd	r31, Y+2	; 0x02
    5282:	01 80       	ldd	r0, Z+1	; 0x01
    5284:	f2 81       	ldd	r31, Z+2	; 0x02
    5286:	e0 2d       	mov	r30, r0
    5288:	82 81       	ldd	r24, Z+2	; 0x02
    528a:	93 81       	ldd	r25, Z+3	; 0x03
    528c:	e9 81       	ldd	r30, Y+1	; 0x01
    528e:	fa 81       	ldd	r31, Y+2	; 0x02
    5290:	92 83       	std	Z+2, r25	; 0x02
    5292:	81 83       	std	Z+1, r24	; 0x01
    5294:	e9 81       	ldd	r30, Y+1	; 0x01
    5296:	fa 81       	ldd	r31, Y+2	; 0x02
    5298:	21 81       	ldd	r18, Z+1	; 0x01
    529a:	32 81       	ldd	r19, Z+2	; 0x02
    529c:	89 81       	ldd	r24, Y+1	; 0x01
    529e:	9a 81       	ldd	r25, Y+2	; 0x02
    52a0:	03 96       	adiw	r24, 0x03	; 3
    52a2:	28 17       	cp	r18, r24
    52a4:	39 07       	cpc	r19, r25
    52a6:	59 f4       	brne	.+22     	; 0x52be <vTaskSwitchContext+0xb2>
    52a8:	e9 81       	ldd	r30, Y+1	; 0x01
    52aa:	fa 81       	ldd	r31, Y+2	; 0x02
    52ac:	01 80       	ldd	r0, Z+1	; 0x01
    52ae:	f2 81       	ldd	r31, Z+2	; 0x02
    52b0:	e0 2d       	mov	r30, r0
    52b2:	82 81       	ldd	r24, Z+2	; 0x02
    52b4:	93 81       	ldd	r25, Z+3	; 0x03
    52b6:	e9 81       	ldd	r30, Y+1	; 0x01
    52b8:	fa 81       	ldd	r31, Y+2	; 0x02
    52ba:	92 83       	std	Z+2, r25	; 0x02
    52bc:	81 83       	std	Z+1, r24	; 0x01
    52be:	e9 81       	ldd	r30, Y+1	; 0x01
    52c0:	fa 81       	ldd	r31, Y+2	; 0x02
    52c2:	01 80       	ldd	r0, Z+1	; 0x01
    52c4:	f2 81       	ldd	r31, Z+2	; 0x02
    52c6:	e0 2d       	mov	r30, r0
    52c8:	86 81       	ldd	r24, Z+6	; 0x06
    52ca:	97 81       	ldd	r25, Z+7	; 0x07
    52cc:	90 93 83 07 	sts	0x0783, r25
    52d0:	80 93 82 07 	sts	0x0782, r24
    52d4:	8b 81       	ldd	r24, Y+3	; 0x03
    52d6:	80 93 88 07 	sts	0x0788, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    52da:	0f 90       	pop	r0
    52dc:	0f 90       	pop	r0
    52de:	0f 90       	pop	r0
    52e0:	cf 91       	pop	r28
    52e2:	df 91       	pop	r29
    52e4:	08 95       	ret

000052e6 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    52e6:	df 93       	push	r29
    52e8:	cf 93       	push	r28
    52ea:	00 d0       	rcall	.+0      	; 0x52ec <vTaskPlaceOnEventList+0x6>
    52ec:	00 d0       	rcall	.+0      	; 0x52ee <vTaskPlaceOnEventList+0x8>
    52ee:	cd b7       	in	r28, 0x3d	; 61
    52f0:	de b7       	in	r29, 0x3e	; 62
    52f2:	9a 83       	std	Y+2, r25	; 0x02
    52f4:	89 83       	std	Y+1, r24	; 0x01
    52f6:	7c 83       	std	Y+4, r23	; 0x04
    52f8:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    52fa:	80 91 82 07 	lds	r24, 0x0782
    52fe:	90 91 83 07 	lds	r25, 0x0783
    5302:	9c 01       	movw	r18, r24
    5304:	24 5f       	subi	r18, 0xF4	; 244
    5306:	3f 4f       	sbci	r19, 0xFF	; 255
    5308:	89 81       	ldd	r24, Y+1	; 0x01
    530a:	9a 81       	ldd	r25, Y+2	; 0x02
    530c:	b9 01       	movw	r22, r18
    530e:	0e 94 fc 09 	call	0x13f8	; 0x13f8 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5312:	8b 81       	ldd	r24, Y+3	; 0x03
    5314:	9c 81       	ldd	r25, Y+4	; 0x04
    5316:	61 e0       	ldi	r22, 0x01	; 1
    5318:	0e 94 94 31 	call	0x6328	; 0x6328 <prvAddCurrentTaskToDelayedList>
}
    531c:	0f 90       	pop	r0
    531e:	0f 90       	pop	r0
    5320:	0f 90       	pop	r0
    5322:	0f 90       	pop	r0
    5324:	cf 91       	pop	r28
    5326:	df 91       	pop	r29
    5328:	08 95       	ret

0000532a <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    532a:	df 93       	push	r29
    532c:	cf 93       	push	r28
    532e:	00 d0       	rcall	.+0      	; 0x5330 <vTaskPlaceOnUnorderedEventList+0x6>
    5330:	00 d0       	rcall	.+0      	; 0x5332 <vTaskPlaceOnUnorderedEventList+0x8>
    5332:	00 d0       	rcall	.+0      	; 0x5334 <vTaskPlaceOnUnorderedEventList+0xa>
    5334:	cd b7       	in	r28, 0x3d	; 61
    5336:	de b7       	in	r29, 0x3e	; 62
    5338:	9a 83       	std	Y+2, r25	; 0x02
    533a:	89 83       	std	Y+1, r24	; 0x01
    533c:	7c 83       	std	Y+4, r23	; 0x04
    533e:	6b 83       	std	Y+3, r22	; 0x03
    5340:	5e 83       	std	Y+6, r21	; 0x06
    5342:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    5344:	e0 91 82 07 	lds	r30, 0x0782
    5348:	f0 91 83 07 	lds	r31, 0x0783
    534c:	8b 81       	ldd	r24, Y+3	; 0x03
    534e:	9c 81       	ldd	r25, Y+4	; 0x04
    5350:	90 68       	ori	r25, 0x80	; 128
    5352:	95 87       	std	Z+13, r25	; 0x0d
    5354:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    5356:	80 91 82 07 	lds	r24, 0x0782
    535a:	90 91 83 07 	lds	r25, 0x0783
    535e:	9c 01       	movw	r18, r24
    5360:	24 5f       	subi	r18, 0xF4	; 244
    5362:	3f 4f       	sbci	r19, 0xFF	; 255
    5364:	89 81       	ldd	r24, Y+1	; 0x01
    5366:	9a 81       	ldd	r25, Y+2	; 0x02
    5368:	b9 01       	movw	r22, r18
    536a:	0e 94 b8 09 	call	0x1370	; 0x1370 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    536e:	8d 81       	ldd	r24, Y+5	; 0x05
    5370:	9e 81       	ldd	r25, Y+6	; 0x06
    5372:	61 e0       	ldi	r22, 0x01	; 1
    5374:	0e 94 94 31 	call	0x6328	; 0x6328 <prvAddCurrentTaskToDelayedList>
}
    5378:	26 96       	adiw	r28, 0x06	; 6
    537a:	0f b6       	in	r0, 0x3f	; 63
    537c:	f8 94       	cli
    537e:	de bf       	out	0x3e, r29	; 62
    5380:	0f be       	out	0x3f, r0	; 63
    5382:	cd bf       	out	0x3d, r28	; 61
    5384:	cf 91       	pop	r28
    5386:	df 91       	pop	r29
    5388:	08 95       	ret

0000538a <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    538a:	df 93       	push	r29
    538c:	cf 93       	push	r28
    538e:	00 d0       	rcall	.+0      	; 0x5390 <xTaskRemoveFromEventList+0x6>
    5390:	00 d0       	rcall	.+0      	; 0x5392 <xTaskRemoveFromEventList+0x8>
    5392:	0f 92       	push	r0
    5394:	cd b7       	in	r28, 0x3d	; 61
    5396:	de b7       	in	r29, 0x3e	; 62
    5398:	9d 83       	std	Y+5, r25	; 0x05
    539a:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    539c:	ec 81       	ldd	r30, Y+4	; 0x04
    539e:	fd 81       	ldd	r31, Y+5	; 0x05
    53a0:	05 80       	ldd	r0, Z+5	; 0x05
    53a2:	f6 81       	ldd	r31, Z+6	; 0x06
    53a4:	e0 2d       	mov	r30, r0
    53a6:	86 81       	ldd	r24, Z+6	; 0x06
    53a8:	97 81       	ldd	r25, Z+7	; 0x07
    53aa:	9b 83       	std	Y+3, r25	; 0x03
    53ac:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    53ae:	8a 81       	ldd	r24, Y+2	; 0x02
    53b0:	9b 81       	ldd	r25, Y+3	; 0x03
    53b2:	0c 96       	adiw	r24, 0x0c	; 12
    53b4:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    53b8:	80 91 92 07 	lds	r24, 0x0792
    53bc:	88 23       	and	r24, r24
    53be:	61 f5       	brne	.+88     	; 0x5418 <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    53c0:	8a 81       	ldd	r24, Y+2	; 0x02
    53c2:	9b 81       	ldd	r25, Y+3	; 0x03
    53c4:	02 96       	adiw	r24, 0x02	; 2
    53c6:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    53ca:	ea 81       	ldd	r30, Y+2	; 0x02
    53cc:	fb 81       	ldd	r31, Y+3	; 0x03
    53ce:	96 89       	ldd	r25, Z+22	; 0x16
    53d0:	80 91 88 07 	lds	r24, 0x0788
    53d4:	89 17       	cp	r24, r25
    53d6:	28 f4       	brcc	.+10     	; 0x53e2 <xTaskRemoveFromEventList+0x58>
    53d8:	ea 81       	ldd	r30, Y+2	; 0x02
    53da:	fb 81       	ldd	r31, Y+3	; 0x03
    53dc:	86 89       	ldd	r24, Z+22	; 0x16
    53de:	80 93 88 07 	sts	0x0788, r24
    53e2:	ea 81       	ldd	r30, Y+2	; 0x02
    53e4:	fb 81       	ldd	r31, Y+3	; 0x03
    53e6:	86 89       	ldd	r24, Z+22	; 0x16
    53e8:	28 2f       	mov	r18, r24
    53ea:	30 e0       	ldi	r19, 0x00	; 0
    53ec:	c9 01       	movw	r24, r18
    53ee:	88 0f       	add	r24, r24
    53f0:	99 1f       	adc	r25, r25
    53f2:	88 0f       	add	r24, r24
    53f4:	99 1f       	adc	r25, r25
    53f6:	88 0f       	add	r24, r24
    53f8:	99 1f       	adc	r25, r25
    53fa:	82 0f       	add	r24, r18
    53fc:	93 1f       	adc	r25, r19
    53fe:	ac 01       	movw	r20, r24
    5400:	4d 56       	subi	r20, 0x6D	; 109
    5402:	58 4f       	sbci	r21, 0xF8	; 248
    5404:	8a 81       	ldd	r24, Y+2	; 0x02
    5406:	9b 81       	ldd	r25, Y+3	; 0x03
    5408:	9c 01       	movw	r18, r24
    540a:	2e 5f       	subi	r18, 0xFE	; 254
    540c:	3f 4f       	sbci	r19, 0xFF	; 255
    540e:	ca 01       	movw	r24, r20
    5410:	b9 01       	movw	r22, r18
    5412:	0e 94 b8 09 	call	0x1370	; 0x1370 <vListInsertEnd>
    5416:	0a c0       	rjmp	.+20     	; 0x542c <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    5418:	8a 81       	ldd	r24, Y+2	; 0x02
    541a:	9b 81       	ldd	r25, Y+3	; 0x03
    541c:	9c 01       	movw	r18, r24
    541e:	24 5f       	subi	r18, 0xF4	; 244
    5420:	3f 4f       	sbci	r19, 0xFF	; 255
    5422:	83 e0       	ldi	r24, 0x03	; 3
    5424:	98 e0       	ldi	r25, 0x08	; 8
    5426:	b9 01       	movw	r22, r18
    5428:	0e 94 b8 09 	call	0x1370	; 0x1370 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    542c:	ea 81       	ldd	r30, Y+2	; 0x02
    542e:	fb 81       	ldd	r31, Y+3	; 0x03
    5430:	96 89       	ldd	r25, Z+22	; 0x16
    5432:	e0 91 82 07 	lds	r30, 0x0782
    5436:	f0 91 83 07 	lds	r31, 0x0783
    543a:	86 89       	ldd	r24, Z+22	; 0x16
    543c:	89 17       	cp	r24, r25
    543e:	30 f4       	brcc	.+12     	; 0x544c <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    5440:	81 e0       	ldi	r24, 0x01	; 1
    5442:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    5444:	81 e0       	ldi	r24, 0x01	; 1
    5446:	80 93 8b 07 	sts	0x078B, r24
    544a:	01 c0       	rjmp	.+2      	; 0x544e <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    544c:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    544e:	89 81       	ldd	r24, Y+1	; 0x01
}
    5450:	0f 90       	pop	r0
    5452:	0f 90       	pop	r0
    5454:	0f 90       	pop	r0
    5456:	0f 90       	pop	r0
    5458:	0f 90       	pop	r0
    545a:	cf 91       	pop	r28
    545c:	df 91       	pop	r29
    545e:	08 95       	ret

00005460 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    5460:	df 93       	push	r29
    5462:	cf 93       	push	r28
    5464:	00 d0       	rcall	.+0      	; 0x5466 <vTaskRemoveFromUnorderedEventList+0x6>
    5466:	00 d0       	rcall	.+0      	; 0x5468 <vTaskRemoveFromUnorderedEventList+0x8>
    5468:	00 d0       	rcall	.+0      	; 0x546a <vTaskRemoveFromUnorderedEventList+0xa>
    546a:	cd b7       	in	r28, 0x3d	; 61
    546c:	de b7       	in	r29, 0x3e	; 62
    546e:	9c 83       	std	Y+4, r25	; 0x04
    5470:	8b 83       	std	Y+3, r24	; 0x03
    5472:	7e 83       	std	Y+6, r23	; 0x06
    5474:	6d 83       	std	Y+5, r22	; 0x05
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    5476:	8d 81       	ldd	r24, Y+5	; 0x05
    5478:	9e 81       	ldd	r25, Y+6	; 0x06
    547a:	90 68       	ori	r25, 0x80	; 128
    547c:	eb 81       	ldd	r30, Y+3	; 0x03
    547e:	fc 81       	ldd	r31, Y+4	; 0x04
    5480:	91 83       	std	Z+1, r25	; 0x01
    5482:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5484:	eb 81       	ldd	r30, Y+3	; 0x03
    5486:	fc 81       	ldd	r31, Y+4	; 0x04
    5488:	86 81       	ldd	r24, Z+6	; 0x06
    548a:	97 81       	ldd	r25, Z+7	; 0x07
    548c:	9a 83       	std	Y+2, r25	; 0x02
    548e:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    5490:	8b 81       	ldd	r24, Y+3	; 0x03
    5492:	9c 81       	ldd	r25, Y+4	; 0x04
    5494:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    5498:	89 81       	ldd	r24, Y+1	; 0x01
    549a:	9a 81       	ldd	r25, Y+2	; 0x02
    549c:	02 96       	adiw	r24, 0x02	; 2
    549e:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    54a2:	e9 81       	ldd	r30, Y+1	; 0x01
    54a4:	fa 81       	ldd	r31, Y+2	; 0x02
    54a6:	96 89       	ldd	r25, Z+22	; 0x16
    54a8:	80 91 88 07 	lds	r24, 0x0788
    54ac:	89 17       	cp	r24, r25
    54ae:	28 f4       	brcc	.+10     	; 0x54ba <vTaskRemoveFromUnorderedEventList+0x5a>
    54b0:	e9 81       	ldd	r30, Y+1	; 0x01
    54b2:	fa 81       	ldd	r31, Y+2	; 0x02
    54b4:	86 89       	ldd	r24, Z+22	; 0x16
    54b6:	80 93 88 07 	sts	0x0788, r24
    54ba:	e9 81       	ldd	r30, Y+1	; 0x01
    54bc:	fa 81       	ldd	r31, Y+2	; 0x02
    54be:	86 89       	ldd	r24, Z+22	; 0x16
    54c0:	28 2f       	mov	r18, r24
    54c2:	30 e0       	ldi	r19, 0x00	; 0
    54c4:	c9 01       	movw	r24, r18
    54c6:	88 0f       	add	r24, r24
    54c8:	99 1f       	adc	r25, r25
    54ca:	88 0f       	add	r24, r24
    54cc:	99 1f       	adc	r25, r25
    54ce:	88 0f       	add	r24, r24
    54d0:	99 1f       	adc	r25, r25
    54d2:	82 0f       	add	r24, r18
    54d4:	93 1f       	adc	r25, r19
    54d6:	ac 01       	movw	r20, r24
    54d8:	4d 56       	subi	r20, 0x6D	; 109
    54da:	58 4f       	sbci	r21, 0xF8	; 248
    54dc:	89 81       	ldd	r24, Y+1	; 0x01
    54de:	9a 81       	ldd	r25, Y+2	; 0x02
    54e0:	9c 01       	movw	r18, r24
    54e2:	2e 5f       	subi	r18, 0xFE	; 254
    54e4:	3f 4f       	sbci	r19, 0xFF	; 255
    54e6:	ca 01       	movw	r24, r20
    54e8:	b9 01       	movw	r22, r18
    54ea:	0e 94 b8 09 	call	0x1370	; 0x1370 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    54ee:	e9 81       	ldd	r30, Y+1	; 0x01
    54f0:	fa 81       	ldd	r31, Y+2	; 0x02
    54f2:	96 89       	ldd	r25, Z+22	; 0x16
    54f4:	e0 91 82 07 	lds	r30, 0x0782
    54f8:	f0 91 83 07 	lds	r31, 0x0783
    54fc:	86 89       	ldd	r24, Z+22	; 0x16
    54fe:	89 17       	cp	r24, r25
    5500:	18 f4       	brcc	.+6      	; 0x5508 <vTaskRemoveFromUnorderedEventList+0xa8>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    5502:	81 e0       	ldi	r24, 0x01	; 1
    5504:	80 93 8b 07 	sts	0x078B, r24
	}
}
    5508:	26 96       	adiw	r28, 0x06	; 6
    550a:	0f b6       	in	r0, 0x3f	; 63
    550c:	f8 94       	cli
    550e:	de bf       	out	0x3e, r29	; 62
    5510:	0f be       	out	0x3f, r0	; 63
    5512:	cd bf       	out	0x3d, r28	; 61
    5514:	cf 91       	pop	r28
    5516:	df 91       	pop	r29
    5518:	08 95       	ret

0000551a <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    551a:	df 93       	push	r29
    551c:	cf 93       	push	r28
    551e:	00 d0       	rcall	.+0      	; 0x5520 <vTaskSetTimeOutState+0x6>
    5520:	cd b7       	in	r28, 0x3d	; 61
    5522:	de b7       	in	r29, 0x3e	; 62
    5524:	9a 83       	std	Y+2, r25	; 0x02
    5526:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    5528:	0f b6       	in	r0, 0x3f	; 63
    552a:	f8 94       	cli
    552c:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    552e:	80 91 8c 07 	lds	r24, 0x078C
    5532:	e9 81       	ldd	r30, Y+1	; 0x01
    5534:	fa 81       	ldd	r31, Y+2	; 0x02
    5536:	80 83       	st	Z, r24
		pxTimeOut->xTimeOnEntering = xTickCount;
    5538:	80 91 86 07 	lds	r24, 0x0786
    553c:	90 91 87 07 	lds	r25, 0x0787
    5540:	e9 81       	ldd	r30, Y+1	; 0x01
    5542:	fa 81       	ldd	r31, Y+2	; 0x02
    5544:	92 83       	std	Z+2, r25	; 0x02
    5546:	81 83       	std	Z+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    5548:	0f 90       	pop	r0
    554a:	0f be       	out	0x3f, r0	; 63
}
    554c:	0f 90       	pop	r0
    554e:	0f 90       	pop	r0
    5550:	cf 91       	pop	r28
    5552:	df 91       	pop	r29
    5554:	08 95       	ret

00005556 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    5556:	df 93       	push	r29
    5558:	cf 93       	push	r28
    555a:	00 d0       	rcall	.+0      	; 0x555c <vTaskInternalSetTimeOutState+0x6>
    555c:	cd b7       	in	r28, 0x3d	; 61
    555e:	de b7       	in	r29, 0x3e	; 62
    5560:	9a 83       	std	Y+2, r25	; 0x02
    5562:	89 83       	std	Y+1, r24	; 0x01
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    5564:	80 91 8c 07 	lds	r24, 0x078C
    5568:	e9 81       	ldd	r30, Y+1	; 0x01
    556a:	fa 81       	ldd	r31, Y+2	; 0x02
    556c:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    556e:	80 91 86 07 	lds	r24, 0x0786
    5572:	90 91 87 07 	lds	r25, 0x0787
    5576:	e9 81       	ldd	r30, Y+1	; 0x01
    5578:	fa 81       	ldd	r31, Y+2	; 0x02
    557a:	92 83       	std	Z+2, r25	; 0x02
    557c:	81 83       	std	Z+1, r24	; 0x01
}
    557e:	0f 90       	pop	r0
    5580:	0f 90       	pop	r0
    5582:	cf 91       	pop	r28
    5584:	df 91       	pop	r29
    5586:	08 95       	ret

00005588 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    5588:	df 93       	push	r29
    558a:	cf 93       	push	r28
    558c:	cd b7       	in	r28, 0x3d	; 61
    558e:	de b7       	in	r29, 0x3e	; 62
    5590:	29 97       	sbiw	r28, 0x09	; 9
    5592:	0f b6       	in	r0, 0x3f	; 63
    5594:	f8 94       	cli
    5596:	de bf       	out	0x3e, r29	; 62
    5598:	0f be       	out	0x3f, r0	; 63
    559a:	cd bf       	out	0x3d, r28	; 61
    559c:	9f 83       	std	Y+7, r25	; 0x07
    559e:	8e 83       	std	Y+6, r24	; 0x06
    55a0:	79 87       	std	Y+9, r23	; 0x09
    55a2:	68 87       	std	Y+8, r22	; 0x08
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    55a4:	0f b6       	in	r0, 0x3f	; 63
    55a6:	f8 94       	cli
    55a8:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    55aa:	80 91 86 07 	lds	r24, 0x0786
    55ae:	90 91 87 07 	lds	r25, 0x0787
    55b2:	9c 83       	std	Y+4, r25	; 0x04
    55b4:	8b 83       	std	Y+3, r24	; 0x03
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    55b6:	ee 81       	ldd	r30, Y+6	; 0x06
    55b8:	ff 81       	ldd	r31, Y+7	; 0x07
    55ba:	21 81       	ldd	r18, Z+1	; 0x01
    55bc:	32 81       	ldd	r19, Z+2	; 0x02
    55be:	8b 81       	ldd	r24, Y+3	; 0x03
    55c0:	9c 81       	ldd	r25, Y+4	; 0x04
    55c2:	82 1b       	sub	r24, r18
    55c4:	93 0b       	sbc	r25, r19
    55c6:	9a 83       	std	Y+2, r25	; 0x02
    55c8:	89 83       	std	Y+1, r24	; 0x01
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    55ca:	e8 85       	ldd	r30, Y+8	; 0x08
    55cc:	f9 85       	ldd	r31, Y+9	; 0x09
    55ce:	80 81       	ld	r24, Z
    55d0:	91 81       	ldd	r25, Z+1	; 0x01
    55d2:	2f ef       	ldi	r18, 0xFF	; 255
    55d4:	8f 3f       	cpi	r24, 0xFF	; 255
    55d6:	92 07       	cpc	r25, r18
    55d8:	11 f4       	brne	.+4      	; 0x55de <xTaskCheckForTimeOut+0x56>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    55da:	1d 82       	std	Y+5, r1	; 0x05
    55dc:	36 c0       	rjmp	.+108    	; 0x564a <xTaskCheckForTimeOut+0xc2>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    55de:	ee 81       	ldd	r30, Y+6	; 0x06
    55e0:	ff 81       	ldd	r31, Y+7	; 0x07
    55e2:	90 81       	ld	r25, Z
    55e4:	80 91 8c 07 	lds	r24, 0x078C
    55e8:	98 17       	cp	r25, r24
    55ea:	61 f0       	breq	.+24     	; 0x5604 <xTaskCheckForTimeOut+0x7c>
    55ec:	ee 81       	ldd	r30, Y+6	; 0x06
    55ee:	ff 81       	ldd	r31, Y+7	; 0x07
    55f0:	21 81       	ldd	r18, Z+1	; 0x01
    55f2:	32 81       	ldd	r19, Z+2	; 0x02
    55f4:	8b 81       	ldd	r24, Y+3	; 0x03
    55f6:	9c 81       	ldd	r25, Y+4	; 0x04
    55f8:	82 17       	cp	r24, r18
    55fa:	93 07       	cpc	r25, r19
    55fc:	18 f0       	brcs	.+6      	; 0x5604 <xTaskCheckForTimeOut+0x7c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    55fe:	81 e0       	ldi	r24, 0x01	; 1
    5600:	8d 83       	std	Y+5, r24	; 0x05
    5602:	23 c0       	rjmp	.+70     	; 0x564a <xTaskCheckForTimeOut+0xc2>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    5604:	e8 85       	ldd	r30, Y+8	; 0x08
    5606:	f9 85       	ldd	r31, Y+9	; 0x09
    5608:	20 81       	ld	r18, Z
    560a:	31 81       	ldd	r19, Z+1	; 0x01
    560c:	89 81       	ldd	r24, Y+1	; 0x01
    560e:	9a 81       	ldd	r25, Y+2	; 0x02
    5610:	82 17       	cp	r24, r18
    5612:	93 07       	cpc	r25, r19
    5614:	a0 f4       	brcc	.+40     	; 0x563e <xTaskCheckForTimeOut+0xb6>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    5616:	e8 85       	ldd	r30, Y+8	; 0x08
    5618:	f9 85       	ldd	r31, Y+9	; 0x09
    561a:	20 81       	ld	r18, Z
    561c:	31 81       	ldd	r19, Z+1	; 0x01
    561e:	89 81       	ldd	r24, Y+1	; 0x01
    5620:	9a 81       	ldd	r25, Y+2	; 0x02
    5622:	a9 01       	movw	r20, r18
    5624:	48 1b       	sub	r20, r24
    5626:	59 0b       	sbc	r21, r25
    5628:	ca 01       	movw	r24, r20
    562a:	e8 85       	ldd	r30, Y+8	; 0x08
    562c:	f9 85       	ldd	r31, Y+9	; 0x09
    562e:	91 83       	std	Z+1, r25	; 0x01
    5630:	80 83       	st	Z, r24
			vTaskInternalSetTimeOutState( pxTimeOut );
    5632:	8e 81       	ldd	r24, Y+6	; 0x06
    5634:	9f 81       	ldd	r25, Y+7	; 0x07
    5636:	0e 94 ab 2a 	call	0x5556	; 0x5556 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    563a:	1d 82       	std	Y+5, r1	; 0x05
    563c:	06 c0       	rjmp	.+12     	; 0x564a <xTaskCheckForTimeOut+0xc2>
		}
		else
		{
			*pxTicksToWait = 0;
    563e:	e8 85       	ldd	r30, Y+8	; 0x08
    5640:	f9 85       	ldd	r31, Y+9	; 0x09
    5642:	11 82       	std	Z+1, r1	; 0x01
    5644:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    5646:	81 e0       	ldi	r24, 0x01	; 1
    5648:	8d 83       	std	Y+5, r24	; 0x05
		}
	}
	taskEXIT_CRITICAL();
    564a:	0f 90       	pop	r0
    564c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    564e:	8d 81       	ldd	r24, Y+5	; 0x05
}
    5650:	29 96       	adiw	r28, 0x09	; 9
    5652:	0f b6       	in	r0, 0x3f	; 63
    5654:	f8 94       	cli
    5656:	de bf       	out	0x3e, r29	; 62
    5658:	0f be       	out	0x3f, r0	; 63
    565a:	cd bf       	out	0x3d, r28	; 61
    565c:	cf 91       	pop	r28
    565e:	df 91       	pop	r29
    5660:	08 95       	ret

00005662 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    5662:	df 93       	push	r29
    5664:	cf 93       	push	r28
    5666:	cd b7       	in	r28, 0x3d	; 61
    5668:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    566a:	81 e0       	ldi	r24, 0x01	; 1
    566c:	80 93 8b 07 	sts	0x078B, r24
}
    5670:	cf 91       	pop	r28
    5672:	df 91       	pop	r29
    5674:	08 95       	ret

00005676 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    5676:	df 93       	push	r29
    5678:	cf 93       	push	r28
    567a:	00 d0       	rcall	.+0      	; 0x567c <prvIdleTask+0x6>
    567c:	cd b7       	in	r28, 0x3d	; 61
    567e:	de b7       	in	r29, 0x3e	; 62
    5680:	9a 83       	std	Y+2, r25	; 0x02
    5682:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    5684:	0e 94 86 2b 	call	0x570c	; 0x570c <prvCheckTasksWaitingTermination>
    5688:	fd cf       	rjmp	.-6      	; 0x5684 <prvIdleTask+0xe>

0000568a <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    568a:	df 93       	push	r29
    568c:	cf 93       	push	r28
    568e:	0f 92       	push	r0
    5690:	cd b7       	in	r28, 0x3d	; 61
    5692:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    5694:	19 82       	std	Y+1, r1	; 0x01
    5696:	13 c0       	rjmp	.+38     	; 0x56be <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    5698:	89 81       	ldd	r24, Y+1	; 0x01
    569a:	28 2f       	mov	r18, r24
    569c:	30 e0       	ldi	r19, 0x00	; 0
    569e:	c9 01       	movw	r24, r18
    56a0:	88 0f       	add	r24, r24
    56a2:	99 1f       	adc	r25, r25
    56a4:	88 0f       	add	r24, r24
    56a6:	99 1f       	adc	r25, r25
    56a8:	88 0f       	add	r24, r24
    56aa:	99 1f       	adc	r25, r25
    56ac:	82 0f       	add	r24, r18
    56ae:	93 1f       	adc	r25, r19
    56b0:	8d 56       	subi	r24, 0x6D	; 109
    56b2:	98 4f       	sbci	r25, 0xF8	; 248
    56b4:	0e 94 7e 09 	call	0x12fc	; 0x12fc <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    56b8:	89 81       	ldd	r24, Y+1	; 0x01
    56ba:	8f 5f       	subi	r24, 0xFF	; 255
    56bc:	89 83       	std	Y+1, r24	; 0x01
    56be:	89 81       	ldd	r24, Y+1	; 0x01
    56c0:	8a 30       	cpi	r24, 0x0A	; 10
    56c2:	50 f3       	brcs	.-44     	; 0x5698 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    56c4:	8d ee       	ldi	r24, 0xED	; 237
    56c6:	97 e0       	ldi	r25, 0x07	; 7
    56c8:	0e 94 7e 09 	call	0x12fc	; 0x12fc <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    56cc:	86 ef       	ldi	r24, 0xF6	; 246
    56ce:	97 e0       	ldi	r25, 0x07	; 7
    56d0:	0e 94 7e 09 	call	0x12fc	; 0x12fc <vListInitialise>
	vListInitialise( &xPendingReadyList );
    56d4:	83 e0       	ldi	r24, 0x03	; 3
    56d6:	98 e0       	ldi	r25, 0x08	; 8
    56d8:	0e 94 7e 09 	call	0x12fc	; 0x12fc <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    56dc:	8c e0       	ldi	r24, 0x0C	; 12
    56de:	98 e0       	ldi	r25, 0x08	; 8
    56e0:	0e 94 7e 09 	call	0x12fc	; 0x12fc <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    56e4:	85 e1       	ldi	r24, 0x15	; 21
    56e6:	98 e0       	ldi	r25, 0x08	; 8
    56e8:	0e 94 7e 09 	call	0x12fc	; 0x12fc <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    56ec:	8d ee       	ldi	r24, 0xED	; 237
    56ee:	97 e0       	ldi	r25, 0x07	; 7
    56f0:	90 93 00 08 	sts	0x0800, r25
    56f4:	80 93 ff 07 	sts	0x07FF, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    56f8:	86 ef       	ldi	r24, 0xF6	; 246
    56fa:	97 e0       	ldi	r25, 0x07	; 7
    56fc:	90 93 02 08 	sts	0x0802, r25
    5700:	80 93 01 08 	sts	0x0801, r24
}
    5704:	0f 90       	pop	r0
    5706:	cf 91       	pop	r28
    5708:	df 91       	pop	r29
    570a:	08 95       	ret

0000570c <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    570c:	df 93       	push	r29
    570e:	cf 93       	push	r28
    5710:	00 d0       	rcall	.+0      	; 0x5712 <prvCheckTasksWaitingTermination+0x6>
    5712:	cd b7       	in	r28, 0x3d	; 61
    5714:	de b7       	in	r29, 0x3e	; 62
    5716:	20 c0       	rjmp	.+64     	; 0x5758 <prvCheckTasksWaitingTermination+0x4c>

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			taskENTER_CRITICAL();
    5718:	0f b6       	in	r0, 0x3f	; 63
    571a:	f8 94       	cli
    571c:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    571e:	e0 91 11 08 	lds	r30, 0x0811
    5722:	f0 91 12 08 	lds	r31, 0x0812
    5726:	86 81       	ldd	r24, Z+6	; 0x06
    5728:	97 81       	ldd	r25, Z+7	; 0x07
    572a:	9a 83       	std	Y+2, r25	; 0x02
    572c:	89 83       	std	Y+1, r24	; 0x01
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    572e:	89 81       	ldd	r24, Y+1	; 0x01
    5730:	9a 81       	ldd	r25, Y+2	; 0x02
    5732:	02 96       	adiw	r24, 0x02	; 2
    5734:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <uxListRemove>
				--uxCurrentNumberOfTasks;
    5738:	80 91 85 07 	lds	r24, 0x0785
    573c:	81 50       	subi	r24, 0x01	; 1
    573e:	80 93 85 07 	sts	0x0785, r24
				--uxDeletedTasksWaitingCleanUp;
    5742:	80 91 84 07 	lds	r24, 0x0784
    5746:	81 50       	subi	r24, 0x01	; 1
    5748:	80 93 84 07 	sts	0x0784, r24
			}
			taskEXIT_CRITICAL();
    574c:	0f 90       	pop	r0
    574e:	0f be       	out	0x3f, r0	; 63

			prvDeleteTCB( pxTCB );
    5750:	89 81       	ldd	r24, Y+1	; 0x01
    5752:	9a 81       	ldd	r25, Y+2	; 0x02
    5754:	0e 94 b5 2b 	call	0x576a	; 0x576a <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    5758:	80 91 84 07 	lds	r24, 0x0784
    575c:	88 23       	and	r24, r24
    575e:	e1 f6       	brne	.-72     	; 0x5718 <prvCheckTasksWaitingTermination+0xc>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    5760:	0f 90       	pop	r0
    5762:	0f 90       	pop	r0
    5764:	cf 91       	pop	r28
    5766:	df 91       	pop	r29
    5768:	08 95       	ret

0000576a <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    576a:	df 93       	push	r29
    576c:	cf 93       	push	r28
    576e:	00 d0       	rcall	.+0      	; 0x5770 <prvDeleteTCB+0x6>
    5770:	cd b7       	in	r28, 0x3d	; 61
    5772:	de b7       	in	r29, 0x3e	; 62
    5774:	9a 83       	std	Y+2, r25	; 0x02
    5776:	89 83       	std	Y+1, r24	; 0x01

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    5778:	e9 81       	ldd	r30, Y+1	; 0x01
    577a:	fa 81       	ldd	r31, Y+2	; 0x02
    577c:	87 89       	ldd	r24, Z+23	; 0x17
    577e:	90 8d       	ldd	r25, Z+24	; 0x18
    5780:	0e 94 58 09 	call	0x12b0	; 0x12b0 <vPortFree>
			vPortFree( pxTCB );
    5784:	89 81       	ldd	r24, Y+1	; 0x01
    5786:	9a 81       	ldd	r25, Y+2	; 0x02
    5788:	0e 94 58 09 	call	0x12b0	; 0x12b0 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    578c:	0f 90       	pop	r0
    578e:	0f 90       	pop	r0
    5790:	cf 91       	pop	r28
    5792:	df 91       	pop	r29
    5794:	08 95       	ret

00005796 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    5796:	df 93       	push	r29
    5798:	cf 93       	push	r28
    579a:	00 d0       	rcall	.+0      	; 0x579c <prvResetNextTaskUnblockTime+0x6>
    579c:	cd b7       	in	r28, 0x3d	; 61
    579e:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    57a0:	e0 91 ff 07 	lds	r30, 0x07FF
    57a4:	f0 91 00 08 	lds	r31, 0x0800
    57a8:	80 81       	ld	r24, Z
    57aa:	88 23       	and	r24, r24
    57ac:	39 f4       	brne	.+14     	; 0x57bc <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    57ae:	8f ef       	ldi	r24, 0xFF	; 255
    57b0:	9f ef       	ldi	r25, 0xFF	; 255
    57b2:	90 93 8f 07 	sts	0x078F, r25
    57b6:	80 93 8e 07 	sts	0x078E, r24
    57ba:	13 c0       	rjmp	.+38     	; 0x57e2 <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    57bc:	e0 91 ff 07 	lds	r30, 0x07FF
    57c0:	f0 91 00 08 	lds	r31, 0x0800
    57c4:	05 80       	ldd	r0, Z+5	; 0x05
    57c6:	f6 81       	ldd	r31, Z+6	; 0x06
    57c8:	e0 2d       	mov	r30, r0
    57ca:	86 81       	ldd	r24, Z+6	; 0x06
    57cc:	97 81       	ldd	r25, Z+7	; 0x07
    57ce:	9a 83       	std	Y+2, r25	; 0x02
    57d0:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    57d2:	e9 81       	ldd	r30, Y+1	; 0x01
    57d4:	fa 81       	ldd	r31, Y+2	; 0x02
    57d6:	82 81       	ldd	r24, Z+2	; 0x02
    57d8:	93 81       	ldd	r25, Z+3	; 0x03
    57da:	90 93 8f 07 	sts	0x078F, r25
    57de:	80 93 8e 07 	sts	0x078E, r24
	}
}
    57e2:	0f 90       	pop	r0
    57e4:	0f 90       	pop	r0
    57e6:	cf 91       	pop	r28
    57e8:	df 91       	pop	r29
    57ea:	08 95       	ret

000057ec <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    57ec:	df 93       	push	r29
    57ee:	cf 93       	push	r28
    57f0:	00 d0       	rcall	.+0      	; 0x57f2 <xTaskGetCurrentTaskHandle+0x6>
    57f2:	cd b7       	in	r28, 0x3d	; 61
    57f4:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    57f6:	80 91 82 07 	lds	r24, 0x0782
    57fa:	90 91 83 07 	lds	r25, 0x0783
    57fe:	9a 83       	std	Y+2, r25	; 0x02
    5800:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    5802:	89 81       	ldd	r24, Y+1	; 0x01
    5804:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    5806:	0f 90       	pop	r0
    5808:	0f 90       	pop	r0
    580a:	cf 91       	pop	r28
    580c:	df 91       	pop	r29
    580e:	08 95       	ret

00005810 <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    5810:	df 93       	push	r29
    5812:	cf 93       	push	r28
    5814:	00 d0       	rcall	.+0      	; 0x5816 <xTaskPriorityInherit+0x6>
    5816:	00 d0       	rcall	.+0      	; 0x5818 <xTaskPriorityInherit+0x8>
    5818:	0f 92       	push	r0
    581a:	cd b7       	in	r28, 0x3d	; 61
    581c:	de b7       	in	r29, 0x3e	; 62
    581e:	9d 83       	std	Y+5, r25	; 0x05
    5820:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
    5822:	8c 81       	ldd	r24, Y+4	; 0x04
    5824:	9d 81       	ldd	r25, Y+5	; 0x05
    5826:	9b 83       	std	Y+3, r25	; 0x03
    5828:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xReturn = pdFALSE;
    582a:	19 82       	std	Y+1, r1	; 0x01

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL.  _RB_ Is this still
		needed as interrupts can no longer use mutexes? */
		if( pxMutexHolder != NULL )
    582c:	8c 81       	ldd	r24, Y+4	; 0x04
    582e:	9d 81       	ldd	r25, Y+5	; 0x05
    5830:	00 97       	sbiw	r24, 0x00	; 0
    5832:	09 f4       	brne	.+2      	; 0x5836 <xTaskPriorityInherit+0x26>
    5834:	82 c0       	rjmp	.+260    	; 0x593a <xTaskPriorityInherit+0x12a>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
    5836:	ea 81       	ldd	r30, Y+2	; 0x02
    5838:	fb 81       	ldd	r31, Y+3	; 0x03
    583a:	96 89       	ldd	r25, Z+22	; 0x16
    583c:	e0 91 82 07 	lds	r30, 0x0782
    5840:	f0 91 83 07 	lds	r31, 0x0783
    5844:	86 89       	ldd	r24, Z+22	; 0x16
    5846:	98 17       	cp	r25, r24
    5848:	08 f0       	brcs	.+2      	; 0x584c <xTaskPriorityInherit+0x3c>
    584a:	6b c0       	rjmp	.+214    	; 0x5922 <xTaskPriorityInherit+0x112>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    584c:	ea 81       	ldd	r30, Y+2	; 0x02
    584e:	fb 81       	ldd	r31, Y+3	; 0x03
    5850:	84 85       	ldd	r24, Z+12	; 0x0c
    5852:	95 85       	ldd	r25, Z+13	; 0x0d
    5854:	99 23       	and	r25, r25
    5856:	7c f0       	brlt	.+30     	; 0x5876 <xTaskPriorityInherit+0x66>
				{
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5858:	e0 91 82 07 	lds	r30, 0x0782
    585c:	f0 91 83 07 	lds	r31, 0x0783
    5860:	86 89       	ldd	r24, Z+22	; 0x16
    5862:	28 2f       	mov	r18, r24
    5864:	30 e0       	ldi	r19, 0x00	; 0
    5866:	8a e0       	ldi	r24, 0x0A	; 10
    5868:	90 e0       	ldi	r25, 0x00	; 0
    586a:	82 1b       	sub	r24, r18
    586c:	93 0b       	sbc	r25, r19
    586e:	ea 81       	ldd	r30, Y+2	; 0x02
    5870:	fb 81       	ldd	r31, Y+3	; 0x03
    5872:	95 87       	std	Z+13, r25	; 0x0d
    5874:	84 87       	std	Z+12, r24	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
    5876:	ea 81       	ldd	r30, Y+2	; 0x02
    5878:	fb 81       	ldd	r31, Y+3	; 0x03
    587a:	42 85       	ldd	r20, Z+10	; 0x0a
    587c:	53 85       	ldd	r21, Z+11	; 0x0b
    587e:	ea 81       	ldd	r30, Y+2	; 0x02
    5880:	fb 81       	ldd	r31, Y+3	; 0x03
    5882:	86 89       	ldd	r24, Z+22	; 0x16
    5884:	28 2f       	mov	r18, r24
    5886:	30 e0       	ldi	r19, 0x00	; 0
    5888:	c9 01       	movw	r24, r18
    588a:	88 0f       	add	r24, r24
    588c:	99 1f       	adc	r25, r25
    588e:	88 0f       	add	r24, r24
    5890:	99 1f       	adc	r25, r25
    5892:	88 0f       	add	r24, r24
    5894:	99 1f       	adc	r25, r25
    5896:	82 0f       	add	r24, r18
    5898:	93 1f       	adc	r25, r19
    589a:	8d 56       	subi	r24, 0x6D	; 109
    589c:	98 4f       	sbci	r25, 0xF8	; 248
    589e:	48 17       	cp	r20, r24
    58a0:	59 07       	cpc	r21, r25
    58a2:	a1 f5       	brne	.+104    	; 0x590c <xTaskPriorityInherit+0xfc>
				{
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    58a4:	8a 81       	ldd	r24, Y+2	; 0x02
    58a6:	9b 81       	ldd	r25, Y+3	; 0x03
    58a8:	02 96       	adiw	r24, 0x02	; 2
    58aa:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    58ae:	e0 91 82 07 	lds	r30, 0x0782
    58b2:	f0 91 83 07 	lds	r31, 0x0783
    58b6:	86 89       	ldd	r24, Z+22	; 0x16
    58b8:	ea 81       	ldd	r30, Y+2	; 0x02
    58ba:	fb 81       	ldd	r31, Y+3	; 0x03
    58bc:	86 8b       	std	Z+22, r24	; 0x16
					prvAddTaskToReadyList( pxMutexHolderTCB );
    58be:	ea 81       	ldd	r30, Y+2	; 0x02
    58c0:	fb 81       	ldd	r31, Y+3	; 0x03
    58c2:	96 89       	ldd	r25, Z+22	; 0x16
    58c4:	80 91 88 07 	lds	r24, 0x0788
    58c8:	89 17       	cp	r24, r25
    58ca:	28 f4       	brcc	.+10     	; 0x58d6 <xTaskPriorityInherit+0xc6>
    58cc:	ea 81       	ldd	r30, Y+2	; 0x02
    58ce:	fb 81       	ldd	r31, Y+3	; 0x03
    58d0:	86 89       	ldd	r24, Z+22	; 0x16
    58d2:	80 93 88 07 	sts	0x0788, r24
    58d6:	ea 81       	ldd	r30, Y+2	; 0x02
    58d8:	fb 81       	ldd	r31, Y+3	; 0x03
    58da:	86 89       	ldd	r24, Z+22	; 0x16
    58dc:	28 2f       	mov	r18, r24
    58de:	30 e0       	ldi	r19, 0x00	; 0
    58e0:	c9 01       	movw	r24, r18
    58e2:	88 0f       	add	r24, r24
    58e4:	99 1f       	adc	r25, r25
    58e6:	88 0f       	add	r24, r24
    58e8:	99 1f       	adc	r25, r25
    58ea:	88 0f       	add	r24, r24
    58ec:	99 1f       	adc	r25, r25
    58ee:	82 0f       	add	r24, r18
    58f0:	93 1f       	adc	r25, r19
    58f2:	ac 01       	movw	r20, r24
    58f4:	4d 56       	subi	r20, 0x6D	; 109
    58f6:	58 4f       	sbci	r21, 0xF8	; 248
    58f8:	8a 81       	ldd	r24, Y+2	; 0x02
    58fa:	9b 81       	ldd	r25, Y+3	; 0x03
    58fc:	9c 01       	movw	r18, r24
    58fe:	2e 5f       	subi	r18, 0xFE	; 254
    5900:	3f 4f       	sbci	r19, 0xFF	; 255
    5902:	ca 01       	movw	r24, r20
    5904:	b9 01       	movw	r22, r18
    5906:	0e 94 b8 09 	call	0x1370	; 0x1370 <vListInsertEnd>
    590a:	08 c0       	rjmp	.+16     	; 0x591c <xTaskPriorityInherit+0x10c>
				}
				else
				{
					/* Just inherit the priority. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    590c:	e0 91 82 07 	lds	r30, 0x0782
    5910:	f0 91 83 07 	lds	r31, 0x0783
    5914:	86 89       	ldd	r24, Z+22	; 0x16
    5916:	ea 81       	ldd	r30, Y+2	; 0x02
    5918:	fb 81       	ldd	r31, Y+3	; 0x03
    591a:	86 8b       	std	Z+22, r24	; 0x16
				}

				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

				/* Inheritance occurred. */
				xReturn = pdTRUE;
    591c:	81 e0       	ldi	r24, 0x01	; 1
    591e:	89 83       	std	Y+1, r24	; 0x01
    5920:	0c c0       	rjmp	.+24     	; 0x593a <xTaskPriorityInherit+0x12a>
			}
			else
			{
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
    5922:	ea 81       	ldd	r30, Y+2	; 0x02
    5924:	fb 81       	ldd	r31, Y+3	; 0x03
    5926:	91 a1       	ldd	r25, Z+33	; 0x21
    5928:	e0 91 82 07 	lds	r30, 0x0782
    592c:	f0 91 83 07 	lds	r31, 0x0783
    5930:	86 89       	ldd	r24, Z+22	; 0x16
    5932:	98 17       	cp	r25, r24
    5934:	10 f4       	brcc	.+4      	; 0x593a <xTaskPriorityInherit+0x12a>
					current priority of the mutex holder is not lower than the
					priority of the task attempting to take the mutex.
					Therefore the mutex holder must have already inherited a
					priority, but inheritance would have occurred if that had
					not been the case. */
					xReturn = pdTRUE;
    5936:	81 e0       	ldi	r24, 0x01	; 1
    5938:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    593a:	89 81       	ldd	r24, Y+1	; 0x01
	}
    593c:	0f 90       	pop	r0
    593e:	0f 90       	pop	r0
    5940:	0f 90       	pop	r0
    5942:	0f 90       	pop	r0
    5944:	0f 90       	pop	r0
    5946:	cf 91       	pop	r28
    5948:	df 91       	pop	r29
    594a:	08 95       	ret

0000594c <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    594c:	df 93       	push	r29
    594e:	cf 93       	push	r28
    5950:	00 d0       	rcall	.+0      	; 0x5952 <xTaskPriorityDisinherit+0x6>
    5952:	00 d0       	rcall	.+0      	; 0x5954 <xTaskPriorityDisinherit+0x8>
    5954:	0f 92       	push	r0
    5956:	cd b7       	in	r28, 0x3d	; 61
    5958:	de b7       	in	r29, 0x3e	; 62
    595a:	9d 83       	std	Y+5, r25	; 0x05
    595c:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t * const pxTCB = pxMutexHolder;
    595e:	8c 81       	ldd	r24, Y+4	; 0x04
    5960:	9d 81       	ldd	r25, Y+5	; 0x05
    5962:	9b 83       	std	Y+3, r25	; 0x03
    5964:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xReturn = pdFALSE;
    5966:	19 82       	std	Y+1, r1	; 0x01

		if( pxMutexHolder != NULL )
    5968:	8c 81       	ldd	r24, Y+4	; 0x04
    596a:	9d 81       	ldd	r25, Y+5	; 0x05
    596c:	00 97       	sbiw	r24, 0x00	; 0
    596e:	09 f4       	brne	.+2      	; 0x5972 <xTaskPriorityDisinherit+0x26>
    5970:	56 c0       	rjmp	.+172    	; 0x5a1e <xTaskPriorityDisinherit+0xd2>
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    5972:	ea 81       	ldd	r30, Y+2	; 0x02
    5974:	fb 81       	ldd	r31, Y+3	; 0x03
    5976:	82 a1       	ldd	r24, Z+34	; 0x22
    5978:	81 50       	subi	r24, 0x01	; 1
    597a:	ea 81       	ldd	r30, Y+2	; 0x02
    597c:	fb 81       	ldd	r31, Y+3	; 0x03
    597e:	82 a3       	std	Z+34, r24	; 0x22

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    5980:	ea 81       	ldd	r30, Y+2	; 0x02
    5982:	fb 81       	ldd	r31, Y+3	; 0x03
    5984:	96 89       	ldd	r25, Z+22	; 0x16
    5986:	ea 81       	ldd	r30, Y+2	; 0x02
    5988:	fb 81       	ldd	r31, Y+3	; 0x03
    598a:	81 a1       	ldd	r24, Z+33	; 0x21
    598c:	98 17       	cp	r25, r24
    598e:	09 f4       	brne	.+2      	; 0x5992 <xTaskPriorityDisinherit+0x46>
    5990:	46 c0       	rjmp	.+140    	; 0x5a1e <xTaskPriorityDisinherit+0xd2>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    5992:	ea 81       	ldd	r30, Y+2	; 0x02
    5994:	fb 81       	ldd	r31, Y+3	; 0x03
    5996:	82 a1       	ldd	r24, Z+34	; 0x22
    5998:	88 23       	and	r24, r24
    599a:	09 f0       	breq	.+2      	; 0x599e <xTaskPriorityDisinherit+0x52>
    599c:	40 c0       	rjmp	.+128    	; 0x5a1e <xTaskPriorityDisinherit+0xd2>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding task then it must be the running state task.  Remove
					the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    599e:	8a 81       	ldd	r24, Y+2	; 0x02
    59a0:	9b 81       	ldd	r25, Y+3	; 0x03
    59a2:	02 96       	adiw	r24, 0x02	; 2
    59a4:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    59a8:	ea 81       	ldd	r30, Y+2	; 0x02
    59aa:	fb 81       	ldd	r31, Y+3	; 0x03
    59ac:	81 a1       	ldd	r24, Z+33	; 0x21
    59ae:	ea 81       	ldd	r30, Y+2	; 0x02
    59b0:	fb 81       	ldd	r31, Y+3	; 0x03
    59b2:	86 8b       	std	Z+22, r24	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    59b4:	ea 81       	ldd	r30, Y+2	; 0x02
    59b6:	fb 81       	ldd	r31, Y+3	; 0x03
    59b8:	86 89       	ldd	r24, Z+22	; 0x16
    59ba:	28 2f       	mov	r18, r24
    59bc:	30 e0       	ldi	r19, 0x00	; 0
    59be:	8a e0       	ldi	r24, 0x0A	; 10
    59c0:	90 e0       	ldi	r25, 0x00	; 0
    59c2:	82 1b       	sub	r24, r18
    59c4:	93 0b       	sbc	r25, r19
    59c6:	ea 81       	ldd	r30, Y+2	; 0x02
    59c8:	fb 81       	ldd	r31, Y+3	; 0x03
    59ca:	95 87       	std	Z+13, r25	; 0x0d
    59cc:	84 87       	std	Z+12, r24	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    59ce:	ea 81       	ldd	r30, Y+2	; 0x02
    59d0:	fb 81       	ldd	r31, Y+3	; 0x03
    59d2:	96 89       	ldd	r25, Z+22	; 0x16
    59d4:	80 91 88 07 	lds	r24, 0x0788
    59d8:	89 17       	cp	r24, r25
    59da:	28 f4       	brcc	.+10     	; 0x59e6 <xTaskPriorityDisinherit+0x9a>
    59dc:	ea 81       	ldd	r30, Y+2	; 0x02
    59de:	fb 81       	ldd	r31, Y+3	; 0x03
    59e0:	86 89       	ldd	r24, Z+22	; 0x16
    59e2:	80 93 88 07 	sts	0x0788, r24
    59e6:	ea 81       	ldd	r30, Y+2	; 0x02
    59e8:	fb 81       	ldd	r31, Y+3	; 0x03
    59ea:	86 89       	ldd	r24, Z+22	; 0x16
    59ec:	28 2f       	mov	r18, r24
    59ee:	30 e0       	ldi	r19, 0x00	; 0
    59f0:	c9 01       	movw	r24, r18
    59f2:	88 0f       	add	r24, r24
    59f4:	99 1f       	adc	r25, r25
    59f6:	88 0f       	add	r24, r24
    59f8:	99 1f       	adc	r25, r25
    59fa:	88 0f       	add	r24, r24
    59fc:	99 1f       	adc	r25, r25
    59fe:	82 0f       	add	r24, r18
    5a00:	93 1f       	adc	r25, r19
    5a02:	ac 01       	movw	r20, r24
    5a04:	4d 56       	subi	r20, 0x6D	; 109
    5a06:	58 4f       	sbci	r21, 0xF8	; 248
    5a08:	8a 81       	ldd	r24, Y+2	; 0x02
    5a0a:	9b 81       	ldd	r25, Y+3	; 0x03
    5a0c:	9c 01       	movw	r18, r24
    5a0e:	2e 5f       	subi	r18, 0xFE	; 254
    5a10:	3f 4f       	sbci	r19, 0xFF	; 255
    5a12:	ca 01       	movw	r24, r20
    5a14:	b9 01       	movw	r22, r18
    5a16:	0e 94 b8 09 	call	0x1370	; 0x1370 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    5a1a:	81 e0       	ldi	r24, 0x01	; 1
    5a1c:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    5a1e:	89 81       	ldd	r24, Y+1	; 0x01
	}
    5a20:	0f 90       	pop	r0
    5a22:	0f 90       	pop	r0
    5a24:	0f 90       	pop	r0
    5a26:	0f 90       	pop	r0
    5a28:	0f 90       	pop	r0
    5a2a:	cf 91       	pop	r28
    5a2c:	df 91       	pop	r29
    5a2e:	08 95       	ret

00005a30 <vTaskPriorityDisinheritAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
	{
    5a30:	df 93       	push	r29
    5a32:	cf 93       	push	r28
    5a34:	cd b7       	in	r28, 0x3d	; 61
    5a36:	de b7       	in	r29, 0x3e	; 62
    5a38:	28 97       	sbiw	r28, 0x08	; 8
    5a3a:	0f b6       	in	r0, 0x3f	; 63
    5a3c:	f8 94       	cli
    5a3e:	de bf       	out	0x3e, r29	; 62
    5a40:	0f be       	out	0x3f, r0	; 63
    5a42:	cd bf       	out	0x3d, r28	; 61
    5a44:	9f 83       	std	Y+7, r25	; 0x07
    5a46:	8e 83       	std	Y+6, r24	; 0x06
    5a48:	68 87       	std	Y+8, r22	; 0x08
	TCB_t * const pxTCB = pxMutexHolder;
    5a4a:	8e 81       	ldd	r24, Y+6	; 0x06
    5a4c:	9f 81       	ldd	r25, Y+7	; 0x07
    5a4e:	9d 83       	std	Y+5, r25	; 0x05
    5a50:	8c 83       	std	Y+4, r24	; 0x04
	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
    5a52:	81 e0       	ldi	r24, 0x01	; 1
    5a54:	89 83       	std	Y+1, r24	; 0x01

		if( pxMutexHolder != NULL )
    5a56:	8e 81       	ldd	r24, Y+6	; 0x06
    5a58:	9f 81       	ldd	r25, Y+7	; 0x07
    5a5a:	00 97       	sbiw	r24, 0x00	; 0
    5a5c:	09 f4       	brne	.+2      	; 0x5a60 <vTaskPriorityDisinheritAfterTimeout+0x30>
    5a5e:	74 c0       	rjmp	.+232    	; 0x5b48 <vTaskPriorityDisinheritAfterTimeout+0x118>

			/* Determine the priority to which the priority of the task that
			holds the mutex should be set.  This will be the greater of the
			holding task's base priority and the priority of the highest
			priority task that is waiting to obtain the mutex. */
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
    5a60:	ec 81       	ldd	r30, Y+4	; 0x04
    5a62:	fd 81       	ldd	r31, Y+5	; 0x05
    5a64:	91 a1       	ldd	r25, Z+33	; 0x21
    5a66:	88 85       	ldd	r24, Y+8	; 0x08
    5a68:	98 17       	cp	r25, r24
    5a6a:	18 f4       	brcc	.+6      	; 0x5a72 <vTaskPriorityDisinheritAfterTimeout+0x42>
			{
				uxPriorityToUse = uxHighestPriorityWaitingTask;
    5a6c:	88 85       	ldd	r24, Y+8	; 0x08
    5a6e:	8a 83       	std	Y+2, r24	; 0x02
    5a70:	04 c0       	rjmp	.+8      	; 0x5a7a <vTaskPriorityDisinheritAfterTimeout+0x4a>
			}
			else
			{
				uxPriorityToUse = pxTCB->uxBasePriority;
    5a72:	ec 81       	ldd	r30, Y+4	; 0x04
    5a74:	fd 81       	ldd	r31, Y+5	; 0x05
    5a76:	81 a1       	ldd	r24, Z+33	; 0x21
    5a78:	8a 83       	std	Y+2, r24	; 0x02
			}

			/* Does the priority need to change? */
			if( pxTCB->uxPriority != uxPriorityToUse )
    5a7a:	ec 81       	ldd	r30, Y+4	; 0x04
    5a7c:	fd 81       	ldd	r31, Y+5	; 0x05
    5a7e:	96 89       	ldd	r25, Z+22	; 0x16
    5a80:	8a 81       	ldd	r24, Y+2	; 0x02
    5a82:	98 17       	cp	r25, r24
    5a84:	09 f4       	brne	.+2      	; 0x5a88 <vTaskPriorityDisinheritAfterTimeout+0x58>
    5a86:	60 c0       	rjmp	.+192    	; 0x5b48 <vTaskPriorityDisinheritAfterTimeout+0x118>
			{
				/* Only disinherit if no other mutexes are held.  This is a
				simplification in the priority inheritance implementation.  If
				the task that holds the mutex is also holding other mutexes then
				the other mutexes may have caused the priority inheritance. */
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
    5a88:	ec 81       	ldd	r30, Y+4	; 0x04
    5a8a:	fd 81       	ldd	r31, Y+5	; 0x05
    5a8c:	92 a1       	ldd	r25, Z+34	; 0x22
    5a8e:	89 81       	ldd	r24, Y+1	; 0x01
    5a90:	98 17       	cp	r25, r24
    5a92:	09 f0       	breq	.+2      	; 0x5a96 <vTaskPriorityDisinheritAfterTimeout+0x66>
    5a94:	59 c0       	rjmp	.+178    	; 0x5b48 <vTaskPriorityDisinheritAfterTimeout+0x118>

					/* Disinherit the priority, remembering the previous
					priority to facilitate determining the subject task's
					state. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					uxPriorityUsedOnEntry = pxTCB->uxPriority;
    5a96:	ec 81       	ldd	r30, Y+4	; 0x04
    5a98:	fd 81       	ldd	r31, Y+5	; 0x05
    5a9a:	86 89       	ldd	r24, Z+22	; 0x16
    5a9c:	8b 83       	std	Y+3, r24	; 0x03
					pxTCB->uxPriority = uxPriorityToUse;
    5a9e:	ec 81       	ldd	r30, Y+4	; 0x04
    5aa0:	fd 81       	ldd	r31, Y+5	; 0x05
    5aa2:	8a 81       	ldd	r24, Y+2	; 0x02
    5aa4:	86 8b       	std	Z+22, r24	; 0x16

					/* Only reset the event list item value if the value is not
					being used for anything else. */
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    5aa6:	ec 81       	ldd	r30, Y+4	; 0x04
    5aa8:	fd 81       	ldd	r31, Y+5	; 0x05
    5aaa:	84 85       	ldd	r24, Z+12	; 0x0c
    5aac:	95 85       	ldd	r25, Z+13	; 0x0d
    5aae:	99 23       	and	r25, r25
    5ab0:	5c f0       	brlt	.+22     	; 0x5ac8 <vTaskPriorityDisinheritAfterTimeout+0x98>
					{
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5ab2:	8a 81       	ldd	r24, Y+2	; 0x02
    5ab4:	28 2f       	mov	r18, r24
    5ab6:	30 e0       	ldi	r19, 0x00	; 0
    5ab8:	8a e0       	ldi	r24, 0x0A	; 10
    5aba:	90 e0       	ldi	r25, 0x00	; 0
    5abc:	82 1b       	sub	r24, r18
    5abe:	93 0b       	sbc	r25, r19
    5ac0:	ec 81       	ldd	r30, Y+4	; 0x04
    5ac2:	fd 81       	ldd	r31, Y+5	; 0x05
    5ac4:	95 87       	std	Z+13, r25	; 0x0d
    5ac6:	84 87       	std	Z+12, r24	; 0x0c
					then the task that holds the mutex could be in either the
					Ready, Blocked or Suspended states.  Only remove the task
					from its current state list if it is in the Ready state as
					the task's priority is going to change and there is one
					Ready list per priority. */
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    5ac8:	ec 81       	ldd	r30, Y+4	; 0x04
    5aca:	fd 81       	ldd	r31, Y+5	; 0x05
    5acc:	42 85       	ldd	r20, Z+10	; 0x0a
    5ace:	53 85       	ldd	r21, Z+11	; 0x0b
    5ad0:	8b 81       	ldd	r24, Y+3	; 0x03
    5ad2:	28 2f       	mov	r18, r24
    5ad4:	30 e0       	ldi	r19, 0x00	; 0
    5ad6:	c9 01       	movw	r24, r18
    5ad8:	88 0f       	add	r24, r24
    5ada:	99 1f       	adc	r25, r25
    5adc:	88 0f       	add	r24, r24
    5ade:	99 1f       	adc	r25, r25
    5ae0:	88 0f       	add	r24, r24
    5ae2:	99 1f       	adc	r25, r25
    5ae4:	82 0f       	add	r24, r18
    5ae6:	93 1f       	adc	r25, r19
    5ae8:	8d 56       	subi	r24, 0x6D	; 109
    5aea:	98 4f       	sbci	r25, 0xF8	; 248
    5aec:	48 17       	cp	r20, r24
    5aee:	59 07       	cpc	r21, r25
    5af0:	59 f5       	brne	.+86     	; 0x5b48 <vTaskPriorityDisinheritAfterTimeout+0x118>
					{
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    5af2:	8c 81       	ldd	r24, Y+4	; 0x04
    5af4:	9d 81       	ldd	r25, Y+5	; 0x05
    5af6:	02 96       	adiw	r24, 0x02	; 2
    5af8:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <uxListRemove>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}

						prvAddTaskToReadyList( pxTCB );
    5afc:	ec 81       	ldd	r30, Y+4	; 0x04
    5afe:	fd 81       	ldd	r31, Y+5	; 0x05
    5b00:	96 89       	ldd	r25, Z+22	; 0x16
    5b02:	80 91 88 07 	lds	r24, 0x0788
    5b06:	89 17       	cp	r24, r25
    5b08:	28 f4       	brcc	.+10     	; 0x5b14 <vTaskPriorityDisinheritAfterTimeout+0xe4>
    5b0a:	ec 81       	ldd	r30, Y+4	; 0x04
    5b0c:	fd 81       	ldd	r31, Y+5	; 0x05
    5b0e:	86 89       	ldd	r24, Z+22	; 0x16
    5b10:	80 93 88 07 	sts	0x0788, r24
    5b14:	ec 81       	ldd	r30, Y+4	; 0x04
    5b16:	fd 81       	ldd	r31, Y+5	; 0x05
    5b18:	86 89       	ldd	r24, Z+22	; 0x16
    5b1a:	28 2f       	mov	r18, r24
    5b1c:	30 e0       	ldi	r19, 0x00	; 0
    5b1e:	c9 01       	movw	r24, r18
    5b20:	88 0f       	add	r24, r24
    5b22:	99 1f       	adc	r25, r25
    5b24:	88 0f       	add	r24, r24
    5b26:	99 1f       	adc	r25, r25
    5b28:	88 0f       	add	r24, r24
    5b2a:	99 1f       	adc	r25, r25
    5b2c:	82 0f       	add	r24, r18
    5b2e:	93 1f       	adc	r25, r19
    5b30:	ac 01       	movw	r20, r24
    5b32:	4d 56       	subi	r20, 0x6D	; 109
    5b34:	58 4f       	sbci	r21, 0xF8	; 248
    5b36:	8c 81       	ldd	r24, Y+4	; 0x04
    5b38:	9d 81       	ldd	r25, Y+5	; 0x05
    5b3a:	9c 01       	movw	r18, r24
    5b3c:	2e 5f       	subi	r18, 0xFE	; 254
    5b3e:	3f 4f       	sbci	r19, 0xFF	; 255
    5b40:	ca 01       	movw	r24, r20
    5b42:	b9 01       	movw	r22, r18
    5b44:	0e 94 b8 09 	call	0x1370	; 0x1370 <vListInsertEnd>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    5b48:	28 96       	adiw	r28, 0x08	; 8
    5b4a:	0f b6       	in	r0, 0x3f	; 63
    5b4c:	f8 94       	cli
    5b4e:	de bf       	out	0x3e, r29	; 62
    5b50:	0f be       	out	0x3f, r0	; 63
    5b52:	cd bf       	out	0x3d, r28	; 61
    5b54:	cf 91       	pop	r28
    5b56:	df 91       	pop	r29
    5b58:	08 95       	ret

00005b5a <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    5b5a:	df 93       	push	r29
    5b5c:	cf 93       	push	r28
    5b5e:	00 d0       	rcall	.+0      	; 0x5b60 <uxTaskResetEventItemValue+0x6>
    5b60:	cd b7       	in	r28, 0x3d	; 61
    5b62:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    5b64:	e0 91 82 07 	lds	r30, 0x0782
    5b68:	f0 91 83 07 	lds	r31, 0x0783
    5b6c:	84 85       	ldd	r24, Z+12	; 0x0c
    5b6e:	95 85       	ldd	r25, Z+13	; 0x0d
    5b70:	9a 83       	std	Y+2, r25	; 0x02
    5b72:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5b74:	a0 91 82 07 	lds	r26, 0x0782
    5b78:	b0 91 83 07 	lds	r27, 0x0783
    5b7c:	e0 91 82 07 	lds	r30, 0x0782
    5b80:	f0 91 83 07 	lds	r31, 0x0783
    5b84:	86 89       	ldd	r24, Z+22	; 0x16
    5b86:	28 2f       	mov	r18, r24
    5b88:	30 e0       	ldi	r19, 0x00	; 0
    5b8a:	8a e0       	ldi	r24, 0x0A	; 10
    5b8c:	90 e0       	ldi	r25, 0x00	; 0
    5b8e:	82 1b       	sub	r24, r18
    5b90:	93 0b       	sbc	r25, r19
    5b92:	1d 96       	adiw	r26, 0x0d	; 13
    5b94:	9c 93       	st	X, r25
    5b96:	8e 93       	st	-X, r24
    5b98:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    5b9a:	89 81       	ldd	r24, Y+1	; 0x01
    5b9c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    5b9e:	0f 90       	pop	r0
    5ba0:	0f 90       	pop	r0
    5ba2:	cf 91       	pop	r28
    5ba4:	df 91       	pop	r29
    5ba6:	08 95       	ret

00005ba8 <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
	{
    5ba8:	df 93       	push	r29
    5baa:	cf 93       	push	r28
    5bac:	cd b7       	in	r28, 0x3d	; 61
    5bae:	de b7       	in	r29, 0x3e	; 62
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    5bb0:	80 91 82 07 	lds	r24, 0x0782
    5bb4:	90 91 83 07 	lds	r25, 0x0783
    5bb8:	00 97       	sbiw	r24, 0x00	; 0
    5bba:	39 f0       	breq	.+14     	; 0x5bca <pvTaskIncrementMutexHeldCount+0x22>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    5bbc:	e0 91 82 07 	lds	r30, 0x0782
    5bc0:	f0 91 83 07 	lds	r31, 0x0783
    5bc4:	82 a1       	ldd	r24, Z+34	; 0x22
    5bc6:	8f 5f       	subi	r24, 0xFF	; 255
    5bc8:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    5bca:	80 91 82 07 	lds	r24, 0x0782
    5bce:	90 91 83 07 	lds	r25, 0x0783
	}
    5bd2:	cf 91       	pop	r28
    5bd4:	df 91       	pop	r29
    5bd6:	08 95       	ret

00005bd8 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    5bd8:	df 93       	push	r29
    5bda:	cf 93       	push	r28
    5bdc:	cd b7       	in	r28, 0x3d	; 61
    5bde:	de b7       	in	r29, 0x3e	; 62
    5be0:	27 97       	sbiw	r28, 0x07	; 7
    5be2:	0f b6       	in	r0, 0x3f	; 63
    5be4:	f8 94       	cli
    5be6:	de bf       	out	0x3e, r29	; 62
    5be8:	0f be       	out	0x3f, r0	; 63
    5bea:	cd bf       	out	0x3d, r28	; 61
    5bec:	8d 83       	std	Y+5, r24	; 0x05
    5bee:	7f 83       	std	Y+7, r23	; 0x07
    5bf0:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    5bf2:	0f b6       	in	r0, 0x3f	; 63
    5bf4:	f8 94       	cli
    5bf6:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    5bf8:	e0 91 82 07 	lds	r30, 0x0782
    5bfc:	f0 91 83 07 	lds	r31, 0x0783
    5c00:	83 a1       	ldd	r24, Z+35	; 0x23
    5c02:	94 a1       	ldd	r25, Z+36	; 0x24
    5c04:	a5 a1       	ldd	r26, Z+37	; 0x25
    5c06:	b6 a1       	ldd	r27, Z+38	; 0x26
    5c08:	00 97       	sbiw	r24, 0x00	; 0
    5c0a:	a1 05       	cpc	r26, r1
    5c0c:	b1 05       	cpc	r27, r1
    5c0e:	89 f4       	brne	.+34     	; 0x5c32 <ulTaskNotifyTake+0x5a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    5c10:	e0 91 82 07 	lds	r30, 0x0782
    5c14:	f0 91 83 07 	lds	r31, 0x0783
    5c18:	81 e0       	ldi	r24, 0x01	; 1
    5c1a:	87 a3       	std	Z+39, r24	; 0x27

				if( xTicksToWait > ( TickType_t ) 0 )
    5c1c:	8e 81       	ldd	r24, Y+6	; 0x06
    5c1e:	9f 81       	ldd	r25, Y+7	; 0x07
    5c20:	00 97       	sbiw	r24, 0x00	; 0
    5c22:	39 f0       	breq	.+14     	; 0x5c32 <ulTaskNotifyTake+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5c24:	8e 81       	ldd	r24, Y+6	; 0x06
    5c26:	9f 81       	ldd	r25, Y+7	; 0x07
    5c28:	61 e0       	ldi	r22, 0x01	; 1
    5c2a:	0e 94 94 31 	call	0x6328	; 0x6328 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    5c2e:	0e 94 e2 11 	call	0x23c4	; 0x23c4 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    5c32:	0f 90       	pop	r0
    5c34:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    5c36:	0f b6       	in	r0, 0x3f	; 63
    5c38:	f8 94       	cli
    5c3a:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    5c3c:	e0 91 82 07 	lds	r30, 0x0782
    5c40:	f0 91 83 07 	lds	r31, 0x0783
    5c44:	83 a1       	ldd	r24, Z+35	; 0x23
    5c46:	94 a1       	ldd	r25, Z+36	; 0x24
    5c48:	a5 a1       	ldd	r26, Z+37	; 0x25
    5c4a:	b6 a1       	ldd	r27, Z+38	; 0x26
    5c4c:	89 83       	std	Y+1, r24	; 0x01
    5c4e:	9a 83       	std	Y+2, r25	; 0x02
    5c50:	ab 83       	std	Y+3, r26	; 0x03
    5c52:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    5c54:	89 81       	ldd	r24, Y+1	; 0x01
    5c56:	9a 81       	ldd	r25, Y+2	; 0x02
    5c58:	ab 81       	ldd	r26, Y+3	; 0x03
    5c5a:	bc 81       	ldd	r27, Y+4	; 0x04
    5c5c:	00 97       	sbiw	r24, 0x00	; 0
    5c5e:	a1 05       	cpc	r26, r1
    5c60:	b1 05       	cpc	r27, r1
    5c62:	d9 f0       	breq	.+54     	; 0x5c9a <ulTaskNotifyTake+0xc2>
			{
				if( xClearCountOnExit != pdFALSE )
    5c64:	8d 81       	ldd	r24, Y+5	; 0x05
    5c66:	88 23       	and	r24, r24
    5c68:	49 f0       	breq	.+18     	; 0x5c7c <ulTaskNotifyTake+0xa4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    5c6a:	e0 91 82 07 	lds	r30, 0x0782
    5c6e:	f0 91 83 07 	lds	r31, 0x0783
    5c72:	13 a2       	std	Z+35, r1	; 0x23
    5c74:	14 a2       	std	Z+36, r1	; 0x24
    5c76:	15 a2       	std	Z+37, r1	; 0x25
    5c78:	16 a2       	std	Z+38, r1	; 0x26
    5c7a:	0f c0       	rjmp	.+30     	; 0x5c9a <ulTaskNotifyTake+0xc2>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    5c7c:	e0 91 82 07 	lds	r30, 0x0782
    5c80:	f0 91 83 07 	lds	r31, 0x0783
    5c84:	89 81       	ldd	r24, Y+1	; 0x01
    5c86:	9a 81       	ldd	r25, Y+2	; 0x02
    5c88:	ab 81       	ldd	r26, Y+3	; 0x03
    5c8a:	bc 81       	ldd	r27, Y+4	; 0x04
    5c8c:	01 97       	sbiw	r24, 0x01	; 1
    5c8e:	a1 09       	sbc	r26, r1
    5c90:	b1 09       	sbc	r27, r1
    5c92:	83 a3       	std	Z+35, r24	; 0x23
    5c94:	94 a3       	std	Z+36, r25	; 0x24
    5c96:	a5 a3       	std	Z+37, r26	; 0x25
    5c98:	b6 a3       	std	Z+38, r27	; 0x26
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    5c9a:	e0 91 82 07 	lds	r30, 0x0782
    5c9e:	f0 91 83 07 	lds	r31, 0x0783
    5ca2:	17 a2       	std	Z+39, r1	; 0x27
		}
		taskEXIT_CRITICAL();
    5ca4:	0f 90       	pop	r0
    5ca6:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    5ca8:	89 81       	ldd	r24, Y+1	; 0x01
    5caa:	9a 81       	ldd	r25, Y+2	; 0x02
    5cac:	ab 81       	ldd	r26, Y+3	; 0x03
    5cae:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    5cb0:	bc 01       	movw	r22, r24
    5cb2:	cd 01       	movw	r24, r26
    5cb4:	27 96       	adiw	r28, 0x07	; 7
    5cb6:	0f b6       	in	r0, 0x3f	; 63
    5cb8:	f8 94       	cli
    5cba:	de bf       	out	0x3e, r29	; 62
    5cbc:	0f be       	out	0x3f, r0	; 63
    5cbe:	cd bf       	out	0x3d, r28	; 61
    5cc0:	cf 91       	pop	r28
    5cc2:	df 91       	pop	r29
    5cc4:	08 95       	ret

00005cc6 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    5cc6:	ef 92       	push	r14
    5cc8:	ff 92       	push	r15
    5cca:	0f 93       	push	r16
    5ccc:	1f 93       	push	r17
    5cce:	df 93       	push	r29
    5cd0:	cf 93       	push	r28
    5cd2:	cd b7       	in	r28, 0x3d	; 61
    5cd4:	de b7       	in	r29, 0x3e	; 62
    5cd6:	2d 97       	sbiw	r28, 0x0d	; 13
    5cd8:	0f b6       	in	r0, 0x3f	; 63
    5cda:	f8 94       	cli
    5cdc:	de bf       	out	0x3e, r29	; 62
    5cde:	0f be       	out	0x3f, r0	; 63
    5ce0:	cd bf       	out	0x3d, r28	; 61
    5ce2:	6a 83       	std	Y+2, r22	; 0x02
    5ce4:	7b 83       	std	Y+3, r23	; 0x03
    5ce6:	8c 83       	std	Y+4, r24	; 0x04
    5ce8:	9d 83       	std	Y+5, r25	; 0x05
    5cea:	2e 83       	std	Y+6, r18	; 0x06
    5cec:	3f 83       	std	Y+7, r19	; 0x07
    5cee:	48 87       	std	Y+8, r20	; 0x08
    5cf0:	59 87       	std	Y+9, r21	; 0x09
    5cf2:	1b 87       	std	Y+11, r17	; 0x0b
    5cf4:	0a 87       	std	Y+10, r16	; 0x0a
    5cf6:	fd 86       	std	Y+13, r15	; 0x0d
    5cf8:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    5cfa:	0f b6       	in	r0, 0x3f	; 63
    5cfc:	f8 94       	cli
    5cfe:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    5d00:	e0 91 82 07 	lds	r30, 0x0782
    5d04:	f0 91 83 07 	lds	r31, 0x0783
    5d08:	87 a1       	ldd	r24, Z+39	; 0x27
    5d0a:	82 30       	cpi	r24, 0x02	; 2
    5d0c:	49 f1       	breq	.+82     	; 0x5d60 <xTaskNotifyWait+0x9a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    5d0e:	e0 91 82 07 	lds	r30, 0x0782
    5d12:	f0 91 83 07 	lds	r31, 0x0783
    5d16:	23 a1       	ldd	r18, Z+35	; 0x23
    5d18:	34 a1       	ldd	r19, Z+36	; 0x24
    5d1a:	45 a1       	ldd	r20, Z+37	; 0x25
    5d1c:	56 a1       	ldd	r21, Z+38	; 0x26
    5d1e:	8a 81       	ldd	r24, Y+2	; 0x02
    5d20:	9b 81       	ldd	r25, Y+3	; 0x03
    5d22:	ac 81       	ldd	r26, Y+4	; 0x04
    5d24:	bd 81       	ldd	r27, Y+5	; 0x05
    5d26:	80 95       	com	r24
    5d28:	90 95       	com	r25
    5d2a:	a0 95       	com	r26
    5d2c:	b0 95       	com	r27
    5d2e:	82 23       	and	r24, r18
    5d30:	93 23       	and	r25, r19
    5d32:	a4 23       	and	r26, r20
    5d34:	b5 23       	and	r27, r21
    5d36:	83 a3       	std	Z+35, r24	; 0x23
    5d38:	94 a3       	std	Z+36, r25	; 0x24
    5d3a:	a5 a3       	std	Z+37, r26	; 0x25
    5d3c:	b6 a3       	std	Z+38, r27	; 0x26

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    5d3e:	e0 91 82 07 	lds	r30, 0x0782
    5d42:	f0 91 83 07 	lds	r31, 0x0783
    5d46:	81 e0       	ldi	r24, 0x01	; 1
    5d48:	87 a3       	std	Z+39, r24	; 0x27

				if( xTicksToWait > ( TickType_t ) 0 )
    5d4a:	8c 85       	ldd	r24, Y+12	; 0x0c
    5d4c:	9d 85       	ldd	r25, Y+13	; 0x0d
    5d4e:	00 97       	sbiw	r24, 0x00	; 0
    5d50:	39 f0       	breq	.+14     	; 0x5d60 <xTaskNotifyWait+0x9a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5d52:	8c 85       	ldd	r24, Y+12	; 0x0c
    5d54:	9d 85       	ldd	r25, Y+13	; 0x0d
    5d56:	61 e0       	ldi	r22, 0x01	; 1
    5d58:	0e 94 94 31 	call	0x6328	; 0x6328 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    5d5c:	0e 94 e2 11 	call	0x23c4	; 0x23c4 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    5d60:	0f 90       	pop	r0
    5d62:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    5d64:	0f b6       	in	r0, 0x3f	; 63
    5d66:	f8 94       	cli
    5d68:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    5d6a:	8a 85       	ldd	r24, Y+10	; 0x0a
    5d6c:	9b 85       	ldd	r25, Y+11	; 0x0b
    5d6e:	00 97       	sbiw	r24, 0x00	; 0
    5d70:	71 f0       	breq	.+28     	; 0x5d8e <xTaskNotifyWait+0xc8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    5d72:	e0 91 82 07 	lds	r30, 0x0782
    5d76:	f0 91 83 07 	lds	r31, 0x0783
    5d7a:	83 a1       	ldd	r24, Z+35	; 0x23
    5d7c:	94 a1       	ldd	r25, Z+36	; 0x24
    5d7e:	a5 a1       	ldd	r26, Z+37	; 0x25
    5d80:	b6 a1       	ldd	r27, Z+38	; 0x26
    5d82:	ea 85       	ldd	r30, Y+10	; 0x0a
    5d84:	fb 85       	ldd	r31, Y+11	; 0x0b
    5d86:	80 83       	st	Z, r24
    5d88:	91 83       	std	Z+1, r25	; 0x01
    5d8a:	a2 83       	std	Z+2, r26	; 0x02
    5d8c:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    5d8e:	e0 91 82 07 	lds	r30, 0x0782
    5d92:	f0 91 83 07 	lds	r31, 0x0783
    5d96:	87 a1       	ldd	r24, Z+39	; 0x27
    5d98:	82 30       	cpi	r24, 0x02	; 2
    5d9a:	11 f0       	breq	.+4      	; 0x5da0 <xTaskNotifyWait+0xda>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    5d9c:	19 82       	std	Y+1, r1	; 0x01
    5d9e:	1a c0       	rjmp	.+52     	; 0x5dd4 <xTaskNotifyWait+0x10e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    5da0:	e0 91 82 07 	lds	r30, 0x0782
    5da4:	f0 91 83 07 	lds	r31, 0x0783
    5da8:	23 a1       	ldd	r18, Z+35	; 0x23
    5daa:	34 a1       	ldd	r19, Z+36	; 0x24
    5dac:	45 a1       	ldd	r20, Z+37	; 0x25
    5dae:	56 a1       	ldd	r21, Z+38	; 0x26
    5db0:	8e 81       	ldd	r24, Y+6	; 0x06
    5db2:	9f 81       	ldd	r25, Y+7	; 0x07
    5db4:	a8 85       	ldd	r26, Y+8	; 0x08
    5db6:	b9 85       	ldd	r27, Y+9	; 0x09
    5db8:	80 95       	com	r24
    5dba:	90 95       	com	r25
    5dbc:	a0 95       	com	r26
    5dbe:	b0 95       	com	r27
    5dc0:	82 23       	and	r24, r18
    5dc2:	93 23       	and	r25, r19
    5dc4:	a4 23       	and	r26, r20
    5dc6:	b5 23       	and	r27, r21
    5dc8:	83 a3       	std	Z+35, r24	; 0x23
    5dca:	94 a3       	std	Z+36, r25	; 0x24
    5dcc:	a5 a3       	std	Z+37, r26	; 0x25
    5dce:	b6 a3       	std	Z+38, r27	; 0x26
				xReturn = pdTRUE;
    5dd0:	81 e0       	ldi	r24, 0x01	; 1
    5dd2:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    5dd4:	e0 91 82 07 	lds	r30, 0x0782
    5dd8:	f0 91 83 07 	lds	r31, 0x0783
    5ddc:	17 a2       	std	Z+39, r1	; 0x27
		}
		taskEXIT_CRITICAL();
    5dde:	0f 90       	pop	r0
    5de0:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    5de2:	89 81       	ldd	r24, Y+1	; 0x01
	}
    5de4:	2d 96       	adiw	r28, 0x0d	; 13
    5de6:	0f b6       	in	r0, 0x3f	; 63
    5de8:	f8 94       	cli
    5dea:	de bf       	out	0x3e, r29	; 62
    5dec:	0f be       	out	0x3f, r0	; 63
    5dee:	cd bf       	out	0x3d, r28	; 61
    5df0:	cf 91       	pop	r28
    5df2:	df 91       	pop	r29
    5df4:	1f 91       	pop	r17
    5df6:	0f 91       	pop	r16
    5df8:	ff 90       	pop	r15
    5dfa:	ef 90       	pop	r14
    5dfc:	08 95       	ret

00005dfe <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    5dfe:	0f 93       	push	r16
    5e00:	1f 93       	push	r17
    5e02:	df 93       	push	r29
    5e04:	cf 93       	push	r28
    5e06:	cd b7       	in	r28, 0x3d	; 61
    5e08:	de b7       	in	r29, 0x3e	; 62
    5e0a:	2f 97       	sbiw	r28, 0x0f	; 15
    5e0c:	0f b6       	in	r0, 0x3f	; 63
    5e0e:	f8 94       	cli
    5e10:	de bf       	out	0x3e, r29	; 62
    5e12:	0f be       	out	0x3f, r0	; 63
    5e14:	cd bf       	out	0x3d, r28	; 61
    5e16:	9e 83       	std	Y+6, r25	; 0x06
    5e18:	8d 83       	std	Y+5, r24	; 0x05
    5e1a:	4f 83       	std	Y+7, r20	; 0x07
    5e1c:	58 87       	std	Y+8, r21	; 0x08
    5e1e:	69 87       	std	Y+9, r22	; 0x09
    5e20:	7a 87       	std	Y+10, r23	; 0x0a
    5e22:	2b 87       	std	Y+11, r18	; 0x0b
    5e24:	1d 87       	std	Y+13, r17	; 0x0d
    5e26:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    5e28:	81 e0       	ldi	r24, 0x01	; 1
    5e2a:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
    5e2c:	8d 81       	ldd	r24, Y+5	; 0x05
    5e2e:	9e 81       	ldd	r25, Y+6	; 0x06
    5e30:	9c 83       	std	Y+4, r25	; 0x04
    5e32:	8b 83       	std	Y+3, r24	; 0x03

		taskENTER_CRITICAL();
    5e34:	0f b6       	in	r0, 0x3f	; 63
    5e36:	f8 94       	cli
    5e38:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    5e3a:	8c 85       	ldd	r24, Y+12	; 0x0c
    5e3c:	9d 85       	ldd	r25, Y+13	; 0x0d
    5e3e:	00 97       	sbiw	r24, 0x00	; 0
    5e40:	61 f0       	breq	.+24     	; 0x5e5a <xTaskGenericNotify+0x5c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    5e42:	eb 81       	ldd	r30, Y+3	; 0x03
    5e44:	fc 81       	ldd	r31, Y+4	; 0x04
    5e46:	83 a1       	ldd	r24, Z+35	; 0x23
    5e48:	94 a1       	ldd	r25, Z+36	; 0x24
    5e4a:	a5 a1       	ldd	r26, Z+37	; 0x25
    5e4c:	b6 a1       	ldd	r27, Z+38	; 0x26
    5e4e:	ec 85       	ldd	r30, Y+12	; 0x0c
    5e50:	fd 85       	ldd	r31, Y+13	; 0x0d
    5e52:	80 83       	st	Z, r24
    5e54:	91 83       	std	Z+1, r25	; 0x01
    5e56:	a2 83       	std	Z+2, r26	; 0x02
    5e58:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    5e5a:	eb 81       	ldd	r30, Y+3	; 0x03
    5e5c:	fc 81       	ldd	r31, Y+4	; 0x04
    5e5e:	87 a1       	ldd	r24, Z+39	; 0x27
    5e60:	89 83       	std	Y+1, r24	; 0x01

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    5e62:	eb 81       	ldd	r30, Y+3	; 0x03
    5e64:	fc 81       	ldd	r31, Y+4	; 0x04
    5e66:	82 e0       	ldi	r24, 0x02	; 2
    5e68:	87 a3       	std	Z+39, r24	; 0x27

			switch( eAction )
    5e6a:	8b 85       	ldd	r24, Y+11	; 0x0b
    5e6c:	28 2f       	mov	r18, r24
    5e6e:	30 e0       	ldi	r19, 0x00	; 0
    5e70:	3f 87       	std	Y+15, r19	; 0x0f
    5e72:	2e 87       	std	Y+14, r18	; 0x0e
    5e74:	8e 85       	ldd	r24, Y+14	; 0x0e
    5e76:	9f 85       	ldd	r25, Y+15	; 0x0f
    5e78:	82 30       	cpi	r24, 0x02	; 2
    5e7a:	91 05       	cpc	r25, r1
    5e7c:	59 f1       	breq	.+86     	; 0x5ed4 <xTaskGenericNotify+0xd6>
    5e7e:	2e 85       	ldd	r18, Y+14	; 0x0e
    5e80:	3f 85       	ldd	r19, Y+15	; 0x0f
    5e82:	23 30       	cpi	r18, 0x03	; 3
    5e84:	31 05       	cpc	r19, r1
    5e86:	34 f4       	brge	.+12     	; 0x5e94 <xTaskGenericNotify+0x96>
    5e88:	8e 85       	ldd	r24, Y+14	; 0x0e
    5e8a:	9f 85       	ldd	r25, Y+15	; 0x0f
    5e8c:	81 30       	cpi	r24, 0x01	; 1
    5e8e:	91 05       	cpc	r25, r1
    5e90:	61 f0       	breq	.+24     	; 0x5eaa <xTaskGenericNotify+0xac>
    5e92:	4a c0       	rjmp	.+148    	; 0x5f28 <xTaskGenericNotify+0x12a>
    5e94:	2e 85       	ldd	r18, Y+14	; 0x0e
    5e96:	3f 85       	ldd	r19, Y+15	; 0x0f
    5e98:	23 30       	cpi	r18, 0x03	; 3
    5e9a:	31 05       	cpc	r19, r1
    5e9c:	59 f1       	breq	.+86     	; 0x5ef4 <xTaskGenericNotify+0xf6>
    5e9e:	8e 85       	ldd	r24, Y+14	; 0x0e
    5ea0:	9f 85       	ldd	r25, Y+15	; 0x0f
    5ea2:	84 30       	cpi	r24, 0x04	; 4
    5ea4:	91 05       	cpc	r25, r1
    5ea6:	89 f1       	breq	.+98     	; 0x5f0a <xTaskGenericNotify+0x10c>
    5ea8:	3f c0       	rjmp	.+126    	; 0x5f28 <xTaskGenericNotify+0x12a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    5eaa:	eb 81       	ldd	r30, Y+3	; 0x03
    5eac:	fc 81       	ldd	r31, Y+4	; 0x04
    5eae:	23 a1       	ldd	r18, Z+35	; 0x23
    5eb0:	34 a1       	ldd	r19, Z+36	; 0x24
    5eb2:	45 a1       	ldd	r20, Z+37	; 0x25
    5eb4:	56 a1       	ldd	r21, Z+38	; 0x26
    5eb6:	8f 81       	ldd	r24, Y+7	; 0x07
    5eb8:	98 85       	ldd	r25, Y+8	; 0x08
    5eba:	a9 85       	ldd	r26, Y+9	; 0x09
    5ebc:	ba 85       	ldd	r27, Y+10	; 0x0a
    5ebe:	82 2b       	or	r24, r18
    5ec0:	93 2b       	or	r25, r19
    5ec2:	a4 2b       	or	r26, r20
    5ec4:	b5 2b       	or	r27, r21
    5ec6:	eb 81       	ldd	r30, Y+3	; 0x03
    5ec8:	fc 81       	ldd	r31, Y+4	; 0x04
    5eca:	83 a3       	std	Z+35, r24	; 0x23
    5ecc:	94 a3       	std	Z+36, r25	; 0x24
    5ece:	a5 a3       	std	Z+37, r26	; 0x25
    5ed0:	b6 a3       	std	Z+38, r27	; 0x26
    5ed2:	2a c0       	rjmp	.+84     	; 0x5f28 <xTaskGenericNotify+0x12a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    5ed4:	eb 81       	ldd	r30, Y+3	; 0x03
    5ed6:	fc 81       	ldd	r31, Y+4	; 0x04
    5ed8:	83 a1       	ldd	r24, Z+35	; 0x23
    5eda:	94 a1       	ldd	r25, Z+36	; 0x24
    5edc:	a5 a1       	ldd	r26, Z+37	; 0x25
    5ede:	b6 a1       	ldd	r27, Z+38	; 0x26
    5ee0:	01 96       	adiw	r24, 0x01	; 1
    5ee2:	a1 1d       	adc	r26, r1
    5ee4:	b1 1d       	adc	r27, r1
    5ee6:	eb 81       	ldd	r30, Y+3	; 0x03
    5ee8:	fc 81       	ldd	r31, Y+4	; 0x04
    5eea:	83 a3       	std	Z+35, r24	; 0x23
    5eec:	94 a3       	std	Z+36, r25	; 0x24
    5eee:	a5 a3       	std	Z+37, r26	; 0x25
    5ef0:	b6 a3       	std	Z+38, r27	; 0x26
    5ef2:	1a c0       	rjmp	.+52     	; 0x5f28 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    5ef4:	eb 81       	ldd	r30, Y+3	; 0x03
    5ef6:	fc 81       	ldd	r31, Y+4	; 0x04
    5ef8:	8f 81       	ldd	r24, Y+7	; 0x07
    5efa:	98 85       	ldd	r25, Y+8	; 0x08
    5efc:	a9 85       	ldd	r26, Y+9	; 0x09
    5efe:	ba 85       	ldd	r27, Y+10	; 0x0a
    5f00:	83 a3       	std	Z+35, r24	; 0x23
    5f02:	94 a3       	std	Z+36, r25	; 0x24
    5f04:	a5 a3       	std	Z+37, r26	; 0x25
    5f06:	b6 a3       	std	Z+38, r27	; 0x26
    5f08:	0f c0       	rjmp	.+30     	; 0x5f28 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    5f0a:	89 81       	ldd	r24, Y+1	; 0x01
    5f0c:	82 30       	cpi	r24, 0x02	; 2
    5f0e:	59 f0       	breq	.+22     	; 0x5f26 <xTaskGenericNotify+0x128>
					{
						pxTCB->ulNotifiedValue = ulValue;
    5f10:	eb 81       	ldd	r30, Y+3	; 0x03
    5f12:	fc 81       	ldd	r31, Y+4	; 0x04
    5f14:	8f 81       	ldd	r24, Y+7	; 0x07
    5f16:	98 85       	ldd	r25, Y+8	; 0x08
    5f18:	a9 85       	ldd	r26, Y+9	; 0x09
    5f1a:	ba 85       	ldd	r27, Y+10	; 0x0a
    5f1c:	83 a3       	std	Z+35, r24	; 0x23
    5f1e:	94 a3       	std	Z+36, r25	; 0x24
    5f20:	a5 a3       	std	Z+37, r26	; 0x25
    5f22:	b6 a3       	std	Z+38, r27	; 0x26
    5f24:	01 c0       	rjmp	.+2      	; 0x5f28 <xTaskGenericNotify+0x12a>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    5f26:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5f28:	89 81       	ldd	r24, Y+1	; 0x01
    5f2a:	81 30       	cpi	r24, 0x01	; 1
    5f2c:	b9 f5       	brne	.+110    	; 0x5f9c <xTaskGenericNotify+0x19e>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5f2e:	8b 81       	ldd	r24, Y+3	; 0x03
    5f30:	9c 81       	ldd	r25, Y+4	; 0x04
    5f32:	02 96       	adiw	r24, 0x02	; 2
    5f34:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    5f38:	eb 81       	ldd	r30, Y+3	; 0x03
    5f3a:	fc 81       	ldd	r31, Y+4	; 0x04
    5f3c:	96 89       	ldd	r25, Z+22	; 0x16
    5f3e:	80 91 88 07 	lds	r24, 0x0788
    5f42:	89 17       	cp	r24, r25
    5f44:	28 f4       	brcc	.+10     	; 0x5f50 <xTaskGenericNotify+0x152>
    5f46:	eb 81       	ldd	r30, Y+3	; 0x03
    5f48:	fc 81       	ldd	r31, Y+4	; 0x04
    5f4a:	86 89       	ldd	r24, Z+22	; 0x16
    5f4c:	80 93 88 07 	sts	0x0788, r24
    5f50:	eb 81       	ldd	r30, Y+3	; 0x03
    5f52:	fc 81       	ldd	r31, Y+4	; 0x04
    5f54:	86 89       	ldd	r24, Z+22	; 0x16
    5f56:	28 2f       	mov	r18, r24
    5f58:	30 e0       	ldi	r19, 0x00	; 0
    5f5a:	c9 01       	movw	r24, r18
    5f5c:	88 0f       	add	r24, r24
    5f5e:	99 1f       	adc	r25, r25
    5f60:	88 0f       	add	r24, r24
    5f62:	99 1f       	adc	r25, r25
    5f64:	88 0f       	add	r24, r24
    5f66:	99 1f       	adc	r25, r25
    5f68:	82 0f       	add	r24, r18
    5f6a:	93 1f       	adc	r25, r19
    5f6c:	ac 01       	movw	r20, r24
    5f6e:	4d 56       	subi	r20, 0x6D	; 109
    5f70:	58 4f       	sbci	r21, 0xF8	; 248
    5f72:	8b 81       	ldd	r24, Y+3	; 0x03
    5f74:	9c 81       	ldd	r25, Y+4	; 0x04
    5f76:	9c 01       	movw	r18, r24
    5f78:	2e 5f       	subi	r18, 0xFE	; 254
    5f7a:	3f 4f       	sbci	r19, 0xFF	; 255
    5f7c:	ca 01       	movw	r24, r20
    5f7e:	b9 01       	movw	r22, r18
    5f80:	0e 94 b8 09 	call	0x1370	; 0x1370 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5f84:	eb 81       	ldd	r30, Y+3	; 0x03
    5f86:	fc 81       	ldd	r31, Y+4	; 0x04
    5f88:	96 89       	ldd	r25, Z+22	; 0x16
    5f8a:	e0 91 82 07 	lds	r30, 0x0782
    5f8e:	f0 91 83 07 	lds	r31, 0x0783
    5f92:	86 89       	ldd	r24, Z+22	; 0x16
    5f94:	89 17       	cp	r24, r25
    5f96:	10 f4       	brcc	.+4      	; 0x5f9c <xTaskGenericNotify+0x19e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    5f98:	0e 94 e2 11 	call	0x23c4	; 0x23c4 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    5f9c:	0f 90       	pop	r0
    5f9e:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    5fa0:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    5fa2:	2f 96       	adiw	r28, 0x0f	; 15
    5fa4:	0f b6       	in	r0, 0x3f	; 63
    5fa6:	f8 94       	cli
    5fa8:	de bf       	out	0x3e, r29	; 62
    5faa:	0f be       	out	0x3f, r0	; 63
    5fac:	cd bf       	out	0x3d, r28	; 61
    5fae:	cf 91       	pop	r28
    5fb0:	df 91       	pop	r29
    5fb2:	1f 91       	pop	r17
    5fb4:	0f 91       	pop	r16
    5fb6:	08 95       	ret

00005fb8 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    5fb8:	ef 92       	push	r14
    5fba:	ff 92       	push	r15
    5fbc:	0f 93       	push	r16
    5fbe:	1f 93       	push	r17
    5fc0:	df 93       	push	r29
    5fc2:	cf 93       	push	r28
    5fc4:	cd b7       	in	r28, 0x3d	; 61
    5fc6:	de b7       	in	r29, 0x3e	; 62
    5fc8:	62 97       	sbiw	r28, 0x12	; 18
    5fca:	0f b6       	in	r0, 0x3f	; 63
    5fcc:	f8 94       	cli
    5fce:	de bf       	out	0x3e, r29	; 62
    5fd0:	0f be       	out	0x3f, r0	; 63
    5fd2:	cd bf       	out	0x3d, r28	; 61
    5fd4:	9f 83       	std	Y+7, r25	; 0x07
    5fd6:	8e 83       	std	Y+6, r24	; 0x06
    5fd8:	48 87       	std	Y+8, r20	; 0x08
    5fda:	59 87       	std	Y+9, r21	; 0x09
    5fdc:	6a 87       	std	Y+10, r22	; 0x0a
    5fde:	7b 87       	std	Y+11, r23	; 0x0b
    5fe0:	2c 87       	std	Y+12, r18	; 0x0c
    5fe2:	1e 87       	std	Y+14, r17	; 0x0e
    5fe4:	0d 87       	std	Y+13, r16	; 0x0d
    5fe6:	f8 8a       	std	Y+16, r15	; 0x10
    5fe8:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    5fea:	81 e0       	ldi	r24, 0x01	; 1
    5fec:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    5fee:	8e 81       	ldd	r24, Y+6	; 0x06
    5ff0:	9f 81       	ldd	r25, Y+7	; 0x07
    5ff2:	9d 83       	std	Y+5, r25	; 0x05
    5ff4:	8c 83       	std	Y+4, r24	; 0x04

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5ff6:	19 82       	std	Y+1, r1	; 0x01
		{
			if( pulPreviousNotificationValue != NULL )
    5ff8:	8d 85       	ldd	r24, Y+13	; 0x0d
    5ffa:	9e 85       	ldd	r25, Y+14	; 0x0e
    5ffc:	00 97       	sbiw	r24, 0x00	; 0
    5ffe:	61 f0       	breq	.+24     	; 0x6018 <xTaskGenericNotifyFromISR+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    6000:	ec 81       	ldd	r30, Y+4	; 0x04
    6002:	fd 81       	ldd	r31, Y+5	; 0x05
    6004:	83 a1       	ldd	r24, Z+35	; 0x23
    6006:	94 a1       	ldd	r25, Z+36	; 0x24
    6008:	a5 a1       	ldd	r26, Z+37	; 0x25
    600a:	b6 a1       	ldd	r27, Z+38	; 0x26
    600c:	ed 85       	ldd	r30, Y+13	; 0x0d
    600e:	fe 85       	ldd	r31, Y+14	; 0x0e
    6010:	80 83       	st	Z, r24
    6012:	91 83       	std	Z+1, r25	; 0x01
    6014:	a2 83       	std	Z+2, r26	; 0x02
    6016:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    6018:	ec 81       	ldd	r30, Y+4	; 0x04
    601a:	fd 81       	ldd	r31, Y+5	; 0x05
    601c:	87 a1       	ldd	r24, Z+39	; 0x27
    601e:	8b 83       	std	Y+3, r24	; 0x03
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    6020:	ec 81       	ldd	r30, Y+4	; 0x04
    6022:	fd 81       	ldd	r31, Y+5	; 0x05
    6024:	82 e0       	ldi	r24, 0x02	; 2
    6026:	87 a3       	std	Z+39, r24	; 0x27

			switch( eAction )
    6028:	8c 85       	ldd	r24, Y+12	; 0x0c
    602a:	28 2f       	mov	r18, r24
    602c:	30 e0       	ldi	r19, 0x00	; 0
    602e:	3a 8b       	std	Y+18, r19	; 0x12
    6030:	29 8b       	std	Y+17, r18	; 0x11
    6032:	89 89       	ldd	r24, Y+17	; 0x11
    6034:	9a 89       	ldd	r25, Y+18	; 0x12
    6036:	82 30       	cpi	r24, 0x02	; 2
    6038:	91 05       	cpc	r25, r1
    603a:	59 f1       	breq	.+86     	; 0x6092 <xTaskGenericNotifyFromISR+0xda>
    603c:	29 89       	ldd	r18, Y+17	; 0x11
    603e:	3a 89       	ldd	r19, Y+18	; 0x12
    6040:	23 30       	cpi	r18, 0x03	; 3
    6042:	31 05       	cpc	r19, r1
    6044:	34 f4       	brge	.+12     	; 0x6052 <xTaskGenericNotifyFromISR+0x9a>
    6046:	89 89       	ldd	r24, Y+17	; 0x11
    6048:	9a 89       	ldd	r25, Y+18	; 0x12
    604a:	81 30       	cpi	r24, 0x01	; 1
    604c:	91 05       	cpc	r25, r1
    604e:	61 f0       	breq	.+24     	; 0x6068 <xTaskGenericNotifyFromISR+0xb0>
    6050:	4a c0       	rjmp	.+148    	; 0x60e6 <xTaskGenericNotifyFromISR+0x12e>
    6052:	29 89       	ldd	r18, Y+17	; 0x11
    6054:	3a 89       	ldd	r19, Y+18	; 0x12
    6056:	23 30       	cpi	r18, 0x03	; 3
    6058:	31 05       	cpc	r19, r1
    605a:	59 f1       	breq	.+86     	; 0x60b2 <xTaskGenericNotifyFromISR+0xfa>
    605c:	89 89       	ldd	r24, Y+17	; 0x11
    605e:	9a 89       	ldd	r25, Y+18	; 0x12
    6060:	84 30       	cpi	r24, 0x04	; 4
    6062:	91 05       	cpc	r25, r1
    6064:	89 f1       	breq	.+98     	; 0x60c8 <xTaskGenericNotifyFromISR+0x110>
    6066:	3f c0       	rjmp	.+126    	; 0x60e6 <xTaskGenericNotifyFromISR+0x12e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    6068:	ec 81       	ldd	r30, Y+4	; 0x04
    606a:	fd 81       	ldd	r31, Y+5	; 0x05
    606c:	23 a1       	ldd	r18, Z+35	; 0x23
    606e:	34 a1       	ldd	r19, Z+36	; 0x24
    6070:	45 a1       	ldd	r20, Z+37	; 0x25
    6072:	56 a1       	ldd	r21, Z+38	; 0x26
    6074:	88 85       	ldd	r24, Y+8	; 0x08
    6076:	99 85       	ldd	r25, Y+9	; 0x09
    6078:	aa 85       	ldd	r26, Y+10	; 0x0a
    607a:	bb 85       	ldd	r27, Y+11	; 0x0b
    607c:	82 2b       	or	r24, r18
    607e:	93 2b       	or	r25, r19
    6080:	a4 2b       	or	r26, r20
    6082:	b5 2b       	or	r27, r21
    6084:	ec 81       	ldd	r30, Y+4	; 0x04
    6086:	fd 81       	ldd	r31, Y+5	; 0x05
    6088:	83 a3       	std	Z+35, r24	; 0x23
    608a:	94 a3       	std	Z+36, r25	; 0x24
    608c:	a5 a3       	std	Z+37, r26	; 0x25
    608e:	b6 a3       	std	Z+38, r27	; 0x26
    6090:	2a c0       	rjmp	.+84     	; 0x60e6 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    6092:	ec 81       	ldd	r30, Y+4	; 0x04
    6094:	fd 81       	ldd	r31, Y+5	; 0x05
    6096:	83 a1       	ldd	r24, Z+35	; 0x23
    6098:	94 a1       	ldd	r25, Z+36	; 0x24
    609a:	a5 a1       	ldd	r26, Z+37	; 0x25
    609c:	b6 a1       	ldd	r27, Z+38	; 0x26
    609e:	01 96       	adiw	r24, 0x01	; 1
    60a0:	a1 1d       	adc	r26, r1
    60a2:	b1 1d       	adc	r27, r1
    60a4:	ec 81       	ldd	r30, Y+4	; 0x04
    60a6:	fd 81       	ldd	r31, Y+5	; 0x05
    60a8:	83 a3       	std	Z+35, r24	; 0x23
    60aa:	94 a3       	std	Z+36, r25	; 0x24
    60ac:	a5 a3       	std	Z+37, r26	; 0x25
    60ae:	b6 a3       	std	Z+38, r27	; 0x26
    60b0:	1a c0       	rjmp	.+52     	; 0x60e6 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    60b2:	ec 81       	ldd	r30, Y+4	; 0x04
    60b4:	fd 81       	ldd	r31, Y+5	; 0x05
    60b6:	88 85       	ldd	r24, Y+8	; 0x08
    60b8:	99 85       	ldd	r25, Y+9	; 0x09
    60ba:	aa 85       	ldd	r26, Y+10	; 0x0a
    60bc:	bb 85       	ldd	r27, Y+11	; 0x0b
    60be:	83 a3       	std	Z+35, r24	; 0x23
    60c0:	94 a3       	std	Z+36, r25	; 0x24
    60c2:	a5 a3       	std	Z+37, r26	; 0x25
    60c4:	b6 a3       	std	Z+38, r27	; 0x26
    60c6:	0f c0       	rjmp	.+30     	; 0x60e6 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    60c8:	8b 81       	ldd	r24, Y+3	; 0x03
    60ca:	82 30       	cpi	r24, 0x02	; 2
    60cc:	59 f0       	breq	.+22     	; 0x60e4 <xTaskGenericNotifyFromISR+0x12c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    60ce:	ec 81       	ldd	r30, Y+4	; 0x04
    60d0:	fd 81       	ldd	r31, Y+5	; 0x05
    60d2:	88 85       	ldd	r24, Y+8	; 0x08
    60d4:	99 85       	ldd	r25, Y+9	; 0x09
    60d6:	aa 85       	ldd	r26, Y+10	; 0x0a
    60d8:	bb 85       	ldd	r27, Y+11	; 0x0b
    60da:	83 a3       	std	Z+35, r24	; 0x23
    60dc:	94 a3       	std	Z+36, r25	; 0x24
    60de:	a5 a3       	std	Z+37, r26	; 0x25
    60e0:	b6 a3       	std	Z+38, r27	; 0x26
    60e2:	01 c0       	rjmp	.+2      	; 0x60e6 <xTaskGenericNotifyFromISR+0x12e>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    60e4:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    60e6:	8b 81       	ldd	r24, Y+3	; 0x03
    60e8:	81 30       	cpi	r24, 0x01	; 1
    60ea:	09 f0       	breq	.+2      	; 0x60ee <xTaskGenericNotifyFromISR+0x136>
    60ec:	4f c0       	rjmp	.+158    	; 0x618c <xTaskGenericNotifyFromISR+0x1d4>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    60ee:	80 91 92 07 	lds	r24, 0x0792
    60f2:	88 23       	and	r24, r24
    60f4:	61 f5       	brne	.+88     	; 0x614e <xTaskGenericNotifyFromISR+0x196>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    60f6:	8c 81       	ldd	r24, Y+4	; 0x04
    60f8:	9d 81       	ldd	r25, Y+5	; 0x05
    60fa:	02 96       	adiw	r24, 0x02	; 2
    60fc:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    6100:	ec 81       	ldd	r30, Y+4	; 0x04
    6102:	fd 81       	ldd	r31, Y+5	; 0x05
    6104:	96 89       	ldd	r25, Z+22	; 0x16
    6106:	80 91 88 07 	lds	r24, 0x0788
    610a:	89 17       	cp	r24, r25
    610c:	28 f4       	brcc	.+10     	; 0x6118 <xTaskGenericNotifyFromISR+0x160>
    610e:	ec 81       	ldd	r30, Y+4	; 0x04
    6110:	fd 81       	ldd	r31, Y+5	; 0x05
    6112:	86 89       	ldd	r24, Z+22	; 0x16
    6114:	80 93 88 07 	sts	0x0788, r24
    6118:	ec 81       	ldd	r30, Y+4	; 0x04
    611a:	fd 81       	ldd	r31, Y+5	; 0x05
    611c:	86 89       	ldd	r24, Z+22	; 0x16
    611e:	28 2f       	mov	r18, r24
    6120:	30 e0       	ldi	r19, 0x00	; 0
    6122:	c9 01       	movw	r24, r18
    6124:	88 0f       	add	r24, r24
    6126:	99 1f       	adc	r25, r25
    6128:	88 0f       	add	r24, r24
    612a:	99 1f       	adc	r25, r25
    612c:	88 0f       	add	r24, r24
    612e:	99 1f       	adc	r25, r25
    6130:	82 0f       	add	r24, r18
    6132:	93 1f       	adc	r25, r19
    6134:	ac 01       	movw	r20, r24
    6136:	4d 56       	subi	r20, 0x6D	; 109
    6138:	58 4f       	sbci	r21, 0xF8	; 248
    613a:	8c 81       	ldd	r24, Y+4	; 0x04
    613c:	9d 81       	ldd	r25, Y+5	; 0x05
    613e:	9c 01       	movw	r18, r24
    6140:	2e 5f       	subi	r18, 0xFE	; 254
    6142:	3f 4f       	sbci	r19, 0xFF	; 255
    6144:	ca 01       	movw	r24, r20
    6146:	b9 01       	movw	r22, r18
    6148:	0e 94 b8 09 	call	0x1370	; 0x1370 <vListInsertEnd>
    614c:	0a c0       	rjmp	.+20     	; 0x6162 <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    614e:	8c 81       	ldd	r24, Y+4	; 0x04
    6150:	9d 81       	ldd	r25, Y+5	; 0x05
    6152:	9c 01       	movw	r18, r24
    6154:	24 5f       	subi	r18, 0xF4	; 244
    6156:	3f 4f       	sbci	r19, 0xFF	; 255
    6158:	83 e0       	ldi	r24, 0x03	; 3
    615a:	98 e0       	ldi	r25, 0x08	; 8
    615c:	b9 01       	movw	r22, r18
    615e:	0e 94 b8 09 	call	0x1370	; 0x1370 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    6162:	ec 81       	ldd	r30, Y+4	; 0x04
    6164:	fd 81       	ldd	r31, Y+5	; 0x05
    6166:	96 89       	ldd	r25, Z+22	; 0x16
    6168:	e0 91 82 07 	lds	r30, 0x0782
    616c:	f0 91 83 07 	lds	r31, 0x0783
    6170:	86 89       	ldd	r24, Z+22	; 0x16
    6172:	89 17       	cp	r24, r25
    6174:	58 f4       	brcc	.+22     	; 0x618c <xTaskGenericNotifyFromISR+0x1d4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    6176:	8f 85       	ldd	r24, Y+15	; 0x0f
    6178:	98 89       	ldd	r25, Y+16	; 0x10
    617a:	00 97       	sbiw	r24, 0x00	; 0
    617c:	21 f0       	breq	.+8      	; 0x6186 <xTaskGenericNotifyFromISR+0x1ce>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    617e:	ef 85       	ldd	r30, Y+15	; 0x0f
    6180:	f8 89       	ldd	r31, Y+16	; 0x10
    6182:	81 e0       	ldi	r24, 0x01	; 1
    6184:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    6186:	81 e0       	ldi	r24, 0x01	; 1
    6188:	80 93 8b 07 	sts	0x078B, r24
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    618c:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    618e:	62 96       	adiw	r28, 0x12	; 18
    6190:	0f b6       	in	r0, 0x3f	; 63
    6192:	f8 94       	cli
    6194:	de bf       	out	0x3e, r29	; 62
    6196:	0f be       	out	0x3f, r0	; 63
    6198:	cd bf       	out	0x3d, r28	; 61
    619a:	cf 91       	pop	r28
    619c:	df 91       	pop	r29
    619e:	1f 91       	pop	r17
    61a0:	0f 91       	pop	r16
    61a2:	ff 90       	pop	r15
    61a4:	ef 90       	pop	r14
    61a6:	08 95       	ret

000061a8 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    61a8:	df 93       	push	r29
    61aa:	cf 93       	push	r28
    61ac:	cd b7       	in	r28, 0x3d	; 61
    61ae:	de b7       	in	r29, 0x3e	; 62
    61b0:	28 97       	sbiw	r28, 0x08	; 8
    61b2:	0f b6       	in	r0, 0x3f	; 63
    61b4:	f8 94       	cli
    61b6:	de bf       	out	0x3e, r29	; 62
    61b8:	0f be       	out	0x3f, r0	; 63
    61ba:	cd bf       	out	0x3d, r28	; 61
    61bc:	9e 83       	std	Y+6, r25	; 0x06
    61be:	8d 83       	std	Y+5, r24	; 0x05
    61c0:	78 87       	std	Y+8, r23	; 0x08
    61c2:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    61c4:	8d 81       	ldd	r24, Y+5	; 0x05
    61c6:	9e 81       	ldd	r25, Y+6	; 0x06
    61c8:	9c 83       	std	Y+4, r25	; 0x04
    61ca:	8b 83       	std	Y+3, r24	; 0x03

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    61cc:	19 82       	std	Y+1, r1	; 0x01
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    61ce:	eb 81       	ldd	r30, Y+3	; 0x03
    61d0:	fc 81       	ldd	r31, Y+4	; 0x04
    61d2:	87 a1       	ldd	r24, Z+39	; 0x27
    61d4:	8a 83       	std	Y+2, r24	; 0x02
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    61d6:	eb 81       	ldd	r30, Y+3	; 0x03
    61d8:	fc 81       	ldd	r31, Y+4	; 0x04
    61da:	82 e0       	ldi	r24, 0x02	; 2
    61dc:	87 a3       	std	Z+39, r24	; 0x27

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    61de:	eb 81       	ldd	r30, Y+3	; 0x03
    61e0:	fc 81       	ldd	r31, Y+4	; 0x04
    61e2:	83 a1       	ldd	r24, Z+35	; 0x23
    61e4:	94 a1       	ldd	r25, Z+36	; 0x24
    61e6:	a5 a1       	ldd	r26, Z+37	; 0x25
    61e8:	b6 a1       	ldd	r27, Z+38	; 0x26
    61ea:	01 96       	adiw	r24, 0x01	; 1
    61ec:	a1 1d       	adc	r26, r1
    61ee:	b1 1d       	adc	r27, r1
    61f0:	eb 81       	ldd	r30, Y+3	; 0x03
    61f2:	fc 81       	ldd	r31, Y+4	; 0x04
    61f4:	83 a3       	std	Z+35, r24	; 0x23
    61f6:	94 a3       	std	Z+36, r25	; 0x24
    61f8:	a5 a3       	std	Z+37, r26	; 0x25
    61fa:	b6 a3       	std	Z+38, r27	; 0x26

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    61fc:	8a 81       	ldd	r24, Y+2	; 0x02
    61fe:	81 30       	cpi	r24, 0x01	; 1
    6200:	09 f0       	breq	.+2      	; 0x6204 <vTaskNotifyGiveFromISR+0x5c>
    6202:	4f c0       	rjmp	.+158    	; 0x62a2 <vTaskNotifyGiveFromISR+0xfa>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    6204:	80 91 92 07 	lds	r24, 0x0792
    6208:	88 23       	and	r24, r24
    620a:	61 f5       	brne	.+88     	; 0x6264 <vTaskNotifyGiveFromISR+0xbc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    620c:	8b 81       	ldd	r24, Y+3	; 0x03
    620e:	9c 81       	ldd	r25, Y+4	; 0x04
    6210:	02 96       	adiw	r24, 0x02	; 2
    6212:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    6216:	eb 81       	ldd	r30, Y+3	; 0x03
    6218:	fc 81       	ldd	r31, Y+4	; 0x04
    621a:	96 89       	ldd	r25, Z+22	; 0x16
    621c:	80 91 88 07 	lds	r24, 0x0788
    6220:	89 17       	cp	r24, r25
    6222:	28 f4       	brcc	.+10     	; 0x622e <vTaskNotifyGiveFromISR+0x86>
    6224:	eb 81       	ldd	r30, Y+3	; 0x03
    6226:	fc 81       	ldd	r31, Y+4	; 0x04
    6228:	86 89       	ldd	r24, Z+22	; 0x16
    622a:	80 93 88 07 	sts	0x0788, r24
    622e:	eb 81       	ldd	r30, Y+3	; 0x03
    6230:	fc 81       	ldd	r31, Y+4	; 0x04
    6232:	86 89       	ldd	r24, Z+22	; 0x16
    6234:	28 2f       	mov	r18, r24
    6236:	30 e0       	ldi	r19, 0x00	; 0
    6238:	c9 01       	movw	r24, r18
    623a:	88 0f       	add	r24, r24
    623c:	99 1f       	adc	r25, r25
    623e:	88 0f       	add	r24, r24
    6240:	99 1f       	adc	r25, r25
    6242:	88 0f       	add	r24, r24
    6244:	99 1f       	adc	r25, r25
    6246:	82 0f       	add	r24, r18
    6248:	93 1f       	adc	r25, r19
    624a:	ac 01       	movw	r20, r24
    624c:	4d 56       	subi	r20, 0x6D	; 109
    624e:	58 4f       	sbci	r21, 0xF8	; 248
    6250:	8b 81       	ldd	r24, Y+3	; 0x03
    6252:	9c 81       	ldd	r25, Y+4	; 0x04
    6254:	9c 01       	movw	r18, r24
    6256:	2e 5f       	subi	r18, 0xFE	; 254
    6258:	3f 4f       	sbci	r19, 0xFF	; 255
    625a:	ca 01       	movw	r24, r20
    625c:	b9 01       	movw	r22, r18
    625e:	0e 94 b8 09 	call	0x1370	; 0x1370 <vListInsertEnd>
    6262:	0a c0       	rjmp	.+20     	; 0x6278 <vTaskNotifyGiveFromISR+0xd0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    6264:	8b 81       	ldd	r24, Y+3	; 0x03
    6266:	9c 81       	ldd	r25, Y+4	; 0x04
    6268:	9c 01       	movw	r18, r24
    626a:	24 5f       	subi	r18, 0xF4	; 244
    626c:	3f 4f       	sbci	r19, 0xFF	; 255
    626e:	83 e0       	ldi	r24, 0x03	; 3
    6270:	98 e0       	ldi	r25, 0x08	; 8
    6272:	b9 01       	movw	r22, r18
    6274:	0e 94 b8 09 	call	0x1370	; 0x1370 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    6278:	eb 81       	ldd	r30, Y+3	; 0x03
    627a:	fc 81       	ldd	r31, Y+4	; 0x04
    627c:	96 89       	ldd	r25, Z+22	; 0x16
    627e:	e0 91 82 07 	lds	r30, 0x0782
    6282:	f0 91 83 07 	lds	r31, 0x0783
    6286:	86 89       	ldd	r24, Z+22	; 0x16
    6288:	89 17       	cp	r24, r25
    628a:	58 f4       	brcc	.+22     	; 0x62a2 <vTaskNotifyGiveFromISR+0xfa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    628c:	8f 81       	ldd	r24, Y+7	; 0x07
    628e:	98 85       	ldd	r25, Y+8	; 0x08
    6290:	00 97       	sbiw	r24, 0x00	; 0
    6292:	21 f0       	breq	.+8      	; 0x629c <vTaskNotifyGiveFromISR+0xf4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    6294:	ef 81       	ldd	r30, Y+7	; 0x07
    6296:	f8 85       	ldd	r31, Y+8	; 0x08
    6298:	81 e0       	ldi	r24, 0x01	; 1
    629a:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    629c:	81 e0       	ldi	r24, 0x01	; 1
    629e:	80 93 8b 07 	sts	0x078B, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    62a2:	28 96       	adiw	r28, 0x08	; 8
    62a4:	0f b6       	in	r0, 0x3f	; 63
    62a6:	f8 94       	cli
    62a8:	de bf       	out	0x3e, r29	; 62
    62aa:	0f be       	out	0x3f, r0	; 63
    62ac:	cd bf       	out	0x3d, r28	; 61
    62ae:	cf 91       	pop	r28
    62b0:	df 91       	pop	r29
    62b2:	08 95       	ret

000062b4 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    62b4:	df 93       	push	r29
    62b6:	cf 93       	push	r28
    62b8:	cd b7       	in	r28, 0x3d	; 61
    62ba:	de b7       	in	r29, 0x3e	; 62
    62bc:	27 97       	sbiw	r28, 0x07	; 7
    62be:	0f b6       	in	r0, 0x3f	; 63
    62c0:	f8 94       	cli
    62c2:	de bf       	out	0x3e, r29	; 62
    62c4:	0f be       	out	0x3f, r0	; 63
    62c6:	cd bf       	out	0x3d, r28	; 61
    62c8:	9d 83       	std	Y+5, r25	; 0x05
    62ca:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    62cc:	8c 81       	ldd	r24, Y+4	; 0x04
    62ce:	9d 81       	ldd	r25, Y+5	; 0x05
    62d0:	00 97       	sbiw	r24, 0x00	; 0
    62d2:	39 f4       	brne	.+14     	; 0x62e2 <xTaskNotifyStateClear+0x2e>
    62d4:	80 91 82 07 	lds	r24, 0x0782
    62d8:	90 91 83 07 	lds	r25, 0x0783
    62dc:	9f 83       	std	Y+7, r25	; 0x07
    62de:	8e 83       	std	Y+6, r24	; 0x06
    62e0:	04 c0       	rjmp	.+8      	; 0x62ea <xTaskNotifyStateClear+0x36>
    62e2:	8c 81       	ldd	r24, Y+4	; 0x04
    62e4:	9d 81       	ldd	r25, Y+5	; 0x05
    62e6:	9f 83       	std	Y+7, r25	; 0x07
    62e8:	8e 83       	std	Y+6, r24	; 0x06
    62ea:	8e 81       	ldd	r24, Y+6	; 0x06
    62ec:	9f 81       	ldd	r25, Y+7	; 0x07
    62ee:	9b 83       	std	Y+3, r25	; 0x03
    62f0:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    62f2:	0f b6       	in	r0, 0x3f	; 63
    62f4:	f8 94       	cli
    62f6:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    62f8:	ea 81       	ldd	r30, Y+2	; 0x02
    62fa:	fb 81       	ldd	r31, Y+3	; 0x03
    62fc:	87 a1       	ldd	r24, Z+39	; 0x27
    62fe:	82 30       	cpi	r24, 0x02	; 2
    6300:	31 f4       	brne	.+12     	; 0x630e <xTaskNotifyStateClear+0x5a>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    6302:	ea 81       	ldd	r30, Y+2	; 0x02
    6304:	fb 81       	ldd	r31, Y+3	; 0x03
    6306:	17 a2       	std	Z+39, r1	; 0x27
				xReturn = pdPASS;
    6308:	81 e0       	ldi	r24, 0x01	; 1
    630a:	89 83       	std	Y+1, r24	; 0x01
    630c:	01 c0       	rjmp	.+2      	; 0x6310 <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
    630e:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    6310:	0f 90       	pop	r0
    6312:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    6314:	89 81       	ldd	r24, Y+1	; 0x01
	}
    6316:	27 96       	adiw	r28, 0x07	; 7
    6318:	0f b6       	in	r0, 0x3f	; 63
    631a:	f8 94       	cli
    631c:	de bf       	out	0x3e, r29	; 62
    631e:	0f be       	out	0x3f, r0	; 63
    6320:	cd bf       	out	0x3d, r28	; 61
    6322:	cf 91       	pop	r28
    6324:	df 91       	pop	r29
    6326:	08 95       	ret

00006328 <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    6328:	df 93       	push	r29
    632a:	cf 93       	push	r28
    632c:	cd b7       	in	r28, 0x3d	; 61
    632e:	de b7       	in	r29, 0x3e	; 62
    6330:	27 97       	sbiw	r28, 0x07	; 7
    6332:	0f b6       	in	r0, 0x3f	; 63
    6334:	f8 94       	cli
    6336:	de bf       	out	0x3e, r29	; 62
    6338:	0f be       	out	0x3f, r0	; 63
    633a:	cd bf       	out	0x3d, r28	; 61
    633c:	9e 83       	std	Y+6, r25	; 0x06
    633e:	8d 83       	std	Y+5, r24	; 0x05
    6340:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    6342:	80 91 86 07 	lds	r24, 0x0786
    6346:	90 91 87 07 	lds	r25, 0x0787
    634a:	9a 83       	std	Y+2, r25	; 0x02
    634c:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    634e:	80 91 82 07 	lds	r24, 0x0782
    6352:	90 91 83 07 	lds	r25, 0x0783
    6356:	02 96       	adiw	r24, 0x02	; 2
    6358:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    635c:	8d 81       	ldd	r24, Y+5	; 0x05
    635e:	9e 81       	ldd	r25, Y+6	; 0x06
    6360:	2f ef       	ldi	r18, 0xFF	; 255
    6362:	8f 3f       	cpi	r24, 0xFF	; 255
    6364:	92 07       	cpc	r25, r18
    6366:	81 f4       	brne	.+32     	; 0x6388 <prvAddCurrentTaskToDelayedList+0x60>
    6368:	8f 81       	ldd	r24, Y+7	; 0x07
    636a:	88 23       	and	r24, r24
    636c:	69 f0       	breq	.+26     	; 0x6388 <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    636e:	80 91 82 07 	lds	r24, 0x0782
    6372:	90 91 83 07 	lds	r25, 0x0783
    6376:	9c 01       	movw	r18, r24
    6378:	2e 5f       	subi	r18, 0xFE	; 254
    637a:	3f 4f       	sbci	r19, 0xFF	; 255
    637c:	85 e1       	ldi	r24, 0x15	; 21
    637e:	98 e0       	ldi	r25, 0x08	; 8
    6380:	b9 01       	movw	r22, r18
    6382:	0e 94 b8 09 	call	0x1370	; 0x1370 <vListInsertEnd>
    6386:	43 c0       	rjmp	.+134    	; 0x640e <prvAddCurrentTaskToDelayedList+0xe6>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    6388:	29 81       	ldd	r18, Y+1	; 0x01
    638a:	3a 81       	ldd	r19, Y+2	; 0x02
    638c:	8d 81       	ldd	r24, Y+5	; 0x05
    638e:	9e 81       	ldd	r25, Y+6	; 0x06
    6390:	82 0f       	add	r24, r18
    6392:	93 1f       	adc	r25, r19
    6394:	9c 83       	std	Y+4, r25	; 0x04
    6396:	8b 83       	std	Y+3, r24	; 0x03

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    6398:	e0 91 82 07 	lds	r30, 0x0782
    639c:	f0 91 83 07 	lds	r31, 0x0783
    63a0:	8b 81       	ldd	r24, Y+3	; 0x03
    63a2:	9c 81       	ldd	r25, Y+4	; 0x04
    63a4:	93 83       	std	Z+3, r25	; 0x03
    63a6:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xConstTickCount )
    63a8:	2b 81       	ldd	r18, Y+3	; 0x03
    63aa:	3c 81       	ldd	r19, Y+4	; 0x04
    63ac:	89 81       	ldd	r24, Y+1	; 0x01
    63ae:	9a 81       	ldd	r25, Y+2	; 0x02
    63b0:	28 17       	cp	r18, r24
    63b2:	39 07       	cpc	r19, r25
    63b4:	70 f4       	brcc	.+28     	; 0x63d2 <prvAddCurrentTaskToDelayedList+0xaa>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    63b6:	80 91 01 08 	lds	r24, 0x0801
    63ba:	90 91 02 08 	lds	r25, 0x0802
    63be:	20 91 82 07 	lds	r18, 0x0782
    63c2:	30 91 83 07 	lds	r19, 0x0783
    63c6:	2e 5f       	subi	r18, 0xFE	; 254
    63c8:	3f 4f       	sbci	r19, 0xFF	; 255
    63ca:	b9 01       	movw	r22, r18
    63cc:	0e 94 fc 09 	call	0x13f8	; 0x13f8 <vListInsert>
    63d0:	1e c0       	rjmp	.+60     	; 0x640e <prvAddCurrentTaskToDelayedList+0xe6>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    63d2:	40 91 ff 07 	lds	r20, 0x07FF
    63d6:	50 91 00 08 	lds	r21, 0x0800
    63da:	80 91 82 07 	lds	r24, 0x0782
    63de:	90 91 83 07 	lds	r25, 0x0783
    63e2:	9c 01       	movw	r18, r24
    63e4:	2e 5f       	subi	r18, 0xFE	; 254
    63e6:	3f 4f       	sbci	r19, 0xFF	; 255
    63e8:	ca 01       	movw	r24, r20
    63ea:	b9 01       	movw	r22, r18
    63ec:	0e 94 fc 09 	call	0x13f8	; 0x13f8 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    63f0:	20 91 8e 07 	lds	r18, 0x078E
    63f4:	30 91 8f 07 	lds	r19, 0x078F
    63f8:	8b 81       	ldd	r24, Y+3	; 0x03
    63fa:	9c 81       	ldd	r25, Y+4	; 0x04
    63fc:	82 17       	cp	r24, r18
    63fe:	93 07       	cpc	r25, r19
    6400:	30 f4       	brcc	.+12     	; 0x640e <prvAddCurrentTaskToDelayedList+0xe6>
				{
					xNextTaskUnblockTime = xTimeToWake;
    6402:	8b 81       	ldd	r24, Y+3	; 0x03
    6404:	9c 81       	ldd	r25, Y+4	; 0x04
    6406:	90 93 8f 07 	sts	0x078F, r25
    640a:	80 93 8e 07 	sts	0x078E, r24

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    640e:	27 96       	adiw	r28, 0x07	; 7
    6410:	0f b6       	in	r0, 0x3f	; 63
    6412:	f8 94       	cli
    6414:	de bf       	out	0x3e, r29	; 62
    6416:	0f be       	out	0x3f, r0	; 63
    6418:	cd bf       	out	0x3d, r28	; 61
    641a:	cf 91       	pop	r28
    641c:	df 91       	pop	r29
    641e:	08 95       	ret

00006420 <__mulsi3>:
    6420:	62 9f       	mul	r22, r18
    6422:	d0 01       	movw	r26, r0
    6424:	73 9f       	mul	r23, r19
    6426:	f0 01       	movw	r30, r0
    6428:	82 9f       	mul	r24, r18
    642a:	e0 0d       	add	r30, r0
    642c:	f1 1d       	adc	r31, r1
    642e:	64 9f       	mul	r22, r20
    6430:	e0 0d       	add	r30, r0
    6432:	f1 1d       	adc	r31, r1
    6434:	92 9f       	mul	r25, r18
    6436:	f0 0d       	add	r31, r0
    6438:	83 9f       	mul	r24, r19
    643a:	f0 0d       	add	r31, r0
    643c:	74 9f       	mul	r23, r20
    643e:	f0 0d       	add	r31, r0
    6440:	65 9f       	mul	r22, r21
    6442:	f0 0d       	add	r31, r0
    6444:	99 27       	eor	r25, r25
    6446:	72 9f       	mul	r23, r18
    6448:	b0 0d       	add	r27, r0
    644a:	e1 1d       	adc	r30, r1
    644c:	f9 1f       	adc	r31, r25
    644e:	63 9f       	mul	r22, r19
    6450:	b0 0d       	add	r27, r0
    6452:	e1 1d       	adc	r30, r1
    6454:	f9 1f       	adc	r31, r25
    6456:	bd 01       	movw	r22, r26
    6458:	cf 01       	movw	r24, r30
    645a:	11 24       	eor	r1, r1
    645c:	08 95       	ret

0000645e <__divmodhi4>:
    645e:	97 fb       	bst	r25, 7
    6460:	09 2e       	mov	r0, r25
    6462:	07 26       	eor	r0, r23
    6464:	0a d0       	rcall	.+20     	; 0x647a <__divmodhi4_neg1>
    6466:	77 fd       	sbrc	r23, 7
    6468:	04 d0       	rcall	.+8      	; 0x6472 <__divmodhi4_neg2>
    646a:	0c d0       	rcall	.+24     	; 0x6484 <__udivmodhi4>
    646c:	06 d0       	rcall	.+12     	; 0x647a <__divmodhi4_neg1>
    646e:	00 20       	and	r0, r0
    6470:	1a f4       	brpl	.+6      	; 0x6478 <__divmodhi4_exit>

00006472 <__divmodhi4_neg2>:
    6472:	70 95       	com	r23
    6474:	61 95       	neg	r22
    6476:	7f 4f       	sbci	r23, 0xFF	; 255

00006478 <__divmodhi4_exit>:
    6478:	08 95       	ret

0000647a <__divmodhi4_neg1>:
    647a:	f6 f7       	brtc	.-4      	; 0x6478 <__divmodhi4_exit>
    647c:	90 95       	com	r25
    647e:	81 95       	neg	r24
    6480:	9f 4f       	sbci	r25, 0xFF	; 255
    6482:	08 95       	ret

00006484 <__udivmodhi4>:
    6484:	aa 1b       	sub	r26, r26
    6486:	bb 1b       	sub	r27, r27
    6488:	51 e1       	ldi	r21, 0x11	; 17
    648a:	07 c0       	rjmp	.+14     	; 0x649a <__udivmodhi4_ep>

0000648c <__udivmodhi4_loop>:
    648c:	aa 1f       	adc	r26, r26
    648e:	bb 1f       	adc	r27, r27
    6490:	a6 17       	cp	r26, r22
    6492:	b7 07       	cpc	r27, r23
    6494:	10 f0       	brcs	.+4      	; 0x649a <__udivmodhi4_ep>
    6496:	a6 1b       	sub	r26, r22
    6498:	b7 0b       	sbc	r27, r23

0000649a <__udivmodhi4_ep>:
    649a:	88 1f       	adc	r24, r24
    649c:	99 1f       	adc	r25, r25
    649e:	5a 95       	dec	r21
    64a0:	a9 f7       	brne	.-22     	; 0x648c <__udivmodhi4_loop>
    64a2:	80 95       	com	r24
    64a4:	90 95       	com	r25
    64a6:	bc 01       	movw	r22, r24
    64a8:	cd 01       	movw	r24, r26
    64aa:	08 95       	ret

000064ac <__prologue_saves__>:
    64ac:	2f 92       	push	r2
    64ae:	3f 92       	push	r3
    64b0:	4f 92       	push	r4
    64b2:	5f 92       	push	r5
    64b4:	6f 92       	push	r6
    64b6:	7f 92       	push	r7
    64b8:	8f 92       	push	r8
    64ba:	9f 92       	push	r9
    64bc:	af 92       	push	r10
    64be:	bf 92       	push	r11
    64c0:	cf 92       	push	r12
    64c2:	df 92       	push	r13
    64c4:	ef 92       	push	r14
    64c6:	ff 92       	push	r15
    64c8:	0f 93       	push	r16
    64ca:	1f 93       	push	r17
    64cc:	cf 93       	push	r28
    64ce:	df 93       	push	r29
    64d0:	cd b7       	in	r28, 0x3d	; 61
    64d2:	de b7       	in	r29, 0x3e	; 62
    64d4:	ca 1b       	sub	r28, r26
    64d6:	db 0b       	sbc	r29, r27
    64d8:	0f b6       	in	r0, 0x3f	; 63
    64da:	f8 94       	cli
    64dc:	de bf       	out	0x3e, r29	; 62
    64de:	0f be       	out	0x3f, r0	; 63
    64e0:	cd bf       	out	0x3d, r28	; 61
    64e2:	09 94       	ijmp

000064e4 <__epilogue_restores__>:
    64e4:	2a 88       	ldd	r2, Y+18	; 0x12
    64e6:	39 88       	ldd	r3, Y+17	; 0x11
    64e8:	48 88       	ldd	r4, Y+16	; 0x10
    64ea:	5f 84       	ldd	r5, Y+15	; 0x0f
    64ec:	6e 84       	ldd	r6, Y+14	; 0x0e
    64ee:	7d 84       	ldd	r7, Y+13	; 0x0d
    64f0:	8c 84       	ldd	r8, Y+12	; 0x0c
    64f2:	9b 84       	ldd	r9, Y+11	; 0x0b
    64f4:	aa 84       	ldd	r10, Y+10	; 0x0a
    64f6:	b9 84       	ldd	r11, Y+9	; 0x09
    64f8:	c8 84       	ldd	r12, Y+8	; 0x08
    64fa:	df 80       	ldd	r13, Y+7	; 0x07
    64fc:	ee 80       	ldd	r14, Y+6	; 0x06
    64fe:	fd 80       	ldd	r15, Y+5	; 0x05
    6500:	0c 81       	ldd	r16, Y+4	; 0x04
    6502:	1b 81       	ldd	r17, Y+3	; 0x03
    6504:	aa 81       	ldd	r26, Y+2	; 0x02
    6506:	b9 81       	ldd	r27, Y+1	; 0x01
    6508:	ce 0f       	add	r28, r30
    650a:	d1 1d       	adc	r29, r1
    650c:	0f b6       	in	r0, 0x3f	; 63
    650e:	f8 94       	cli
    6510:	de bf       	out	0x3e, r29	; 62
    6512:	0f be       	out	0x3f, r0	; 63
    6514:	cd bf       	out	0x3d, r28	; 61
    6516:	ed 01       	movw	r28, r26
    6518:	08 95       	ret

0000651a <memcpy>:
    651a:	fb 01       	movw	r30, r22
    651c:	dc 01       	movw	r26, r24
    651e:	02 c0       	rjmp	.+4      	; 0x6524 <memcpy+0xa>
    6520:	01 90       	ld	r0, Z+
    6522:	0d 92       	st	X+, r0
    6524:	41 50       	subi	r20, 0x01	; 1
    6526:	50 40       	sbci	r21, 0x00	; 0
    6528:	d8 f7       	brcc	.-10     	; 0x6520 <memcpy+0x6>
    652a:	08 95       	ret

0000652c <memset>:
    652c:	dc 01       	movw	r26, r24
    652e:	01 c0       	rjmp	.+2      	; 0x6532 <memset+0x6>
    6530:	6d 93       	st	X+, r22
    6532:	41 50       	subi	r20, 0x01	; 1
    6534:	50 40       	sbci	r21, 0x00	; 0
    6536:	e0 f7       	brcc	.-8      	; 0x6530 <memset+0x4>
    6538:	08 95       	ret

0000653a <_exit>:
    653a:	f8 94       	cli

0000653c <__stop_program>:
    653c:	ff cf       	rjmp	.-2      	; 0x653c <__stop_program>
